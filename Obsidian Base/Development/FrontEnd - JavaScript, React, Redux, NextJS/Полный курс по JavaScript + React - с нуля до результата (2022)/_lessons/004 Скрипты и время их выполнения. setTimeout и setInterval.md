### **004 Скрипты и время их выполнения. setTimeout и setInterval**

- Примерно так можно написать setTimeout() в обычных условиях. Первым аргументом функция принимает колбэк-функцию, вторым аргументом – таймаут. Все остальные аргументы – это аргументы для вложенной колбэк-функции
![](_png/Pasted%20image%2020220909164720.png)
- Так же мы можем вложить именованную функцию в таймаут. Тут нужно заметить, что внури мы не вызываем функцию, а просто вкладываем её имя. Как видно, могут выполняться и функции, расположенные ниже их вызова
![](_png/Pasted%20image%2020220909164725.png)
- Когда мы передаём setTimeout() в переменную, мы передаём числовой идентификатор этой функции. Делается это для того, чтобы чётко определять различные setTimeout в коде, так как таких асинхронных функций может быть много

- И так же мы можем очистить интервал и отменить его выполнение
![](_png/Pasted%20image%2020220909164740.png)
- Таким способом мы можем задать таймаут для определённой кнопки. Так же через таймаут часто задают всплытие каких-нибудь модальных окон на сайтах
![](_png/Pasted%20image%2020220909164816.png)
![](_png/Pasted%20image%2020220909164841.png)
- И так же мы можем воспользоваться не только таймаутом, но и задать выполнение функции по интервалу (в примере каждые 3 секунды) через **setInterval****()**
![](_png/Pasted%20image%2020220909164854.png)
- И уже в таким случае наш код сможет добраться до переменной с интервалом. Однако тут мы встречаемся с другой проблемой: **clearInterval** не выполнится, так как он идёт в синхронном потоке кода. Дело в том, что на момент выполнения у него не будет никакого значения, вместо него в нём будет undefined (**clearInterval****(****longTO** **=** **undefined****)**)
![](_png/Pasted%20image%2020220909164900.png)
- Чтобы очистка интервала не выходила из потока, нам нужно задать в самой функции определённое условие, по которому будет выполнятся очистка интервала изнутри самого этого интервала
![](_png/Pasted%20image%2020220909164906.png)
![](_png/Pasted%20image%2020220909164912.png)
- И сейчас мы подбираемся к проблеме, которая заключается в том, что setInterval не учитывает то, сколько времени выполняется функция внутри него. Он просто выполняет функцию раз в определённое время, которое ему задали. Сама же функция внутри него может выполняться и гораздо дольше.

И тут уже приходит рекурсивный **setTimeout****()**. Он, в свою очередь, сначала выполняет функцию и уже только потом ожидает выделенное время. Создаётся такой таймаут через перевызов по его идентификатору (переменной)
![](_png/Pasted%20image%2020220909164919.png)
- И тут уже представлено создание анимации блока, который перемещается по боксу при нажатии на кнопку.

Первым делом, получаем нашу кнопку, через которую будем запускать анимацию.

Во-вторых, создадим анимацию, внутри которой будем хранить сам бокс, который будем перемещать. Там же инициализируем наш счётчик позиции и идентификатор сетИнтервала. Так же внутри расположим функцию, которая будет менять позицию каждый кадр. Эта функция будет помещена в интервал.

Конечной точкой нашего блока будет сдвиг до конца блока (тут 600 бокс и 120 движущийся блок – 480 длина пути). Проверка будет выполняться, пока позиция не будет равна нужному нам числу. После мы очищаем интервал

Интересная особенность: даже если написать периодичнсть в интервале = 0, то всё равно на уровне кода она может иметь минимум в 4 миллисекунды.
![](_png/Pasted%20image%2020220909164930.png)
![](_png/Pasted%20image%2020220909164937.png)