## 001 Шрифты и цвета


Создаём какой-нибудь контент на странице 

`index.tsx`
```TSX
export default function Home(): JSX.Element {
	return (
		<div>
			<p> Какой-то текст </p>
		</div>
	);
}
```

Подключаем шрифты в наше приложение через основную страницу

`_app.tsx`
```TSX
import '../styles/globals.css';
import type { AppProps } from 'next/app';
import React from 'react';

export default function App({ Component, pageProps }: AppProps): JSX.Element {
	return (
		<>
			<head>
				<title>Second Page</title>
				<link key={2} rel="icon" href="/favicon2.ico" />

				{/* подключем шрифты из гугла */}

				<link rel="preconnect" href="https://fonts.googleapis.com" />
				<link rel="preconnect" href="https://fonts.gstatic.com" />
				<link
					href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300;400;500;700&display=swap"
					rel="stylesheet"
				/>
			</head>
			<Component {...pageProps} />
		</>
	);
}
```

И тут уже создаём переменные в нашем базовом ==CSS== и через `var()` эти переменные используем
`global.css`
```CSS
/* тут мы будем хранить все переменные*/
:root {
	--black: #3b434e;
	--white: #ebebeb;
	--background: #f5f6f8;
	--primary: #7653fc;
	--red: #fc836d;
	--green: #1dc37e;
	--light-green: #c8f8e4;
	--font-family: "Noto Sans", sans-serif;
}

html,
body {
	padding: 0;
	margin: 0;
	/* используем кастомный цвет */
	color: var(--black);
	background: var(--background);

	/* меняем шрифт */
	font-family: var(--font-family);
}

a {
	color: inherit;
	text-decoration: none;
}

* {
	box-sizing: border-box;
}
```

## 002 Первый компонент

==Компонент== - это функция, которая на вход в себя принимает какие-либо параметры (пропсы, дефолтные пропсы или не принимает ничего вообще) и возвращает на выходе JSX-элемент

- Компоненты кидаем в отдельную папку `components` в корне проекта
- Под каждый компонент создаём отдельную папку
- Стили стоит выносить внутри документа таким образом: `имя_модуля.module.css`
- Так же стоит отдельно выносить пропсы: `имя_модуля.props.ts`

![](_png/Pasted%20image%2020221226120523.png)

Заранее определим, какой компонент нам нужен:
- Он должен генерировать в зависимости от значения пропса `tag` определённый тег от `h1` до `h3`
- Он должен выводить вложенное внутрь него значение

И первым делом, мы определим интерфейс передаваемых пропсов в наш компонент. Он на вход получает `tag` от `h1` до `h6` (с запасом). 
Для данных, которые вкладываются между тегами (то есть, в нашем случае, выводимый на страницу текст) в `React` предусмотрен тип `ReactNode`, который типизирует `children` элемент

`components > Htag > Htag.props.ts`
```TS
import { ReactNode } from 'react';

export interface IHtagProps {
	tag: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';
	children: ReactNode;
}
```

Далее нужно заранее установить `sass`

```bash
npm i sass
```

Пропишем заранее стили для разных тегов текста на странице. Так как тут будет использоваться модульная система стилей, то нужно будет после названия стилей прописать `.module`, который определит файл стилей как модульные стили 

`components > Htag > Htag.module.scss`
```SCSS
.h1 {
	margin: 0;
	font-weight: 500;
	font-size: 26px;
	line-height: 35px;
}

.h2 {
	margin: 0;
	font-weight: 500;
	font-size: 22px;
	line-height: 30px;
}

.h3 {
	margin: 0;
	font-weight: 600;
	font-size: 20px;
	line-height: 27px;
}
```

Далее мы пишем сам компонент оглавления `Htag`, который в себя принимает пропсы по интерфейсу. 
Первый вариант рендера нужного нам тега: прописать отдельно условия для каждого рендера

`components > Htag > Htag.tsx`
```TSX
import { IHtagProps } from './Htag.props';
import styles from './Htag.module.scss';

export const Htag = ({ tag, children }: IHtagProps): JSX.Element => {
	return (
		<>
			{tag == 'h1' && <h1>{children}</h1>}
			{tag == 'h2' && <h2>{children}</h2>}
			{tag == 'h3' && <h3>{children}</h3>}
		</>
	);
};
```

Ну и второй вариант через `switch-case`. Его преймущество заключается в том, что он прощу читается.

Так же для использования стилей из отдельного файла используется модульная система, что позволяет обратиться к стилям в удобном формате `имя_импорта.имя_класса` => `styles.h1`

`Htag.tsx`
```TSX
import { IHtagProps } from './Htag.props';
import styles from './Htag.module.scss';

export const Htag = ({ tag, children }: IHtagProps): JSX.Element => {
	switch (tag) {
		case 'h1':
			return <h1 className={styles.h1}>{children}</h1>;
		case 'h2':
			return <h2 className={styles.h2}>{children}</h2>;
		case 'h3':
			return <h3 className={styles.h3}>{children}</h3>;
		default:
			return <></>;
	}
};
```

Далее идёт очень важный трюк: мы можем экспортировать внутри `index.ts` компоненты, чтобы сократить путь для доступа к ним из других компонентов

`components > index.ts`
```TS
export * from './Htag/Htag';
```

И вот так выглядит сам импорт элемента на основной странице и  его использование

`pages > index.tsx`
```TSX
import { Htag } from '../components';

export default function Home(): JSX.Element {
	return (
		<>
			<Htag tag="h1">Какой-то текст</Htag>
		</>
	);
}
```

![](_png/Pasted%20image%2020221226132610.png)

## 003 Update - Библиотека classnames

Установка

```bash
npm i classnames
```

Импорт

```js
import cn from 'classnames';
```

Использование: 
Данный модуль позволяет по условию подключать классы к нужным нам объектам

```JS
cn('foo', 'bar'); // => 'foo bar'
cn('foo', { bar: true }); // => 'foo bar'
cn({ 'foo-bar': true }); // => 'foo-bar'
cn({ 'foo-bar': false }); // => ''
cn({ foo: true }, { bar: true }); // => 'foo bar'
cn({ foo: true, bar: true }); // => 'foo bar'

// lots of arguments of various types
cn('foo', { bar: true, duck: false }, 'baz', { quux: true }); // => 'foo bar baz quux'

// other falsy values are just ignored
cn(null, false, 'bar', undefined, 0, 1, { baz: null }, ''); // => 'bar 1'
```

## 004 Classnames







## 005 HTMLProps







## 006 Updated - Детали HTMLprops







## 008 Работа с svg







## 009 Дополнительно - SVG в NextJS 11







## 010 Дополнительно - Обновление SVGR







## 011 Упражнение - Компонент p







## 012 Компонент тэга







