#SSR #NextJS 
## 001 Переменные окружения

Переменные окружения хранят в себе значения, к которым мы можем получить доступ как из фронта, так и из бэка. 
Данные переменные могут хранить разные значения, например, домен. Домен для тестов, бека и фронта может быть разный и поэтому мы можем хранить разные значения. 

![](_png/Pasted%20image%2020230122172149.png)

Внутри переменных окружения можно использовать другие переменные

![](_png/Pasted%20image%2020230122172250.png)

Типы `.env` файлов

![](_png/Pasted%20image%2020230122172456.png)

Доступны переменные на сервере и доступны на фронте с приставкой `NEXT_PUBLIC_`

![](_png/Pasted%20image%2020230122172712.png)

Так же в нексте существуют отдельные функции для работы с переменными окружения

![](_png/Pasted%20image%2020230122172838.png)

Создадим файл с локальными данными окружения и запишем в него домен

`.emv.local`
```env
NEXT_PUBLIC_DOMAIN=https://owltop.ru
```

## 002 Как работает SSR

Стандартно процесс рендеринга страницы начинается с прогрузки `HTML` затем `CSS` и уже только после `JS`

![](_png/Pasted%20image%2020230122183208.png)

В текущих реалиях использования SPA, у нас грузится сначала всегда наш JS код, который и формирует приложение

![](_png/Pasted%20image%2020230122183324.png)

`Client-side Rendering` представляет из себя стандартную модель рендеринга страницы, которая отправляет клиенту весь код и собирает страницу на его ПК.
`Server-side Rendering` представляет из себя более прогрессивный способ генерации приложения, который позволяет рендерить страницу для каждого пользователя отдельно.
Плюсом является то, что `SSR` позволяет гораздо быстрее загрузить страницу, но так же он и нагружает сильно сервер, так как мы рендерим страницу для каждого пользователя на каждый его запрос

![](_png/Pasted%20image%2020230122183516.png)

==Гидратация== - это процесс, во время которого `JS` проходится по `HTML` и добавляет в него все недостающие элементы (обработчики, методы, элементы), не меняя структуру страницы, которую уже имеет пользователь.
Зачастую гидратация происходит на базе `nodeJS` - конкретно на движке `V8`

![](_png/Pasted%20image%2020230122184212.png)

>[!warning] Минусы SSR:
> - Первым делом, что нужно отметить, так это то, чтобы сохранить мощности сервера, зачастую используется кеширование данных, которые сервер уже успел отрендерить и отдать клиенту
> - Приложение становится интерактивным только после гидратации
> - Рендеринг на сервере очень сложно реализуемая процедура, которую настроить самому будет затратно по времени. Вместо этого используются фреймворки по типу `NextJS` и `NuxtJS`
> 
![](_png/Pasted%20image%2020230122184204.png)

>[!info] Преймущества, которые даёт SSR:
> - Огромный прирост к SEO
> 	- + к производительности
> 	- Лучше ответ от сервера
> 	- Отсутствие костылей в индексации SPA
> - Конечный пользователь видит первую отрисовку намного быстрее
> - Нагрузка от слабых устройств переходит на сильный сервер
>
>![](_png/Pasted%20image%2020230122190141.png)

Если мы работаем с `CSR`, то наша структура для оптимизации SEO выглядит так:
- Запрос отправляется на NGINX
- NGINX определяет бот это или пользователь
- Если пользователь, то ему грузится SPA
- Если бот, то отправляется запрос в prerender
- prerender отправляет запрос на генерацию HTML в SPA и тот возвращает сгенерированный код

Главный минус такого подхода заключается в том, что на все запросы и пререндереры тратится достаточно большое количество времени (4-5 секунд) и поэтому обычно на него делается кеширование

В `SSR` неважно от кого придёт запрос он всегда отрендерит страницу и вернёт сгенерированное приложение с данной страницей

![](_png/Pasted%20image%2020230122190759.png)

Что делает некст?
- Отправляется запрос от клиента 
- Некст его обрабатывает
- Если у нас `SSR`, то он сгенерирует код и отправит его пользователю
- Если у нас `CSR`, то он достанет основные данные со всех роутов и закинет их в кеш браузера, чтобы страницы быстро подгружались (зачастую куда выгоднее, чем `SSR` ввиду отсутствия частых перезагрузок)

Так же если на сайте появились изменения, то некст осуществляет инвалидацию кеша - проверяет его, и если данные не совпадают с сервером, то он перезагружает невалидные данные

![](_png/Pasted%20image%2020230122191618.png)

Приложение на `SSR` на десктопе имеет самую высокую производительность. Уже без `SSR` она падает сильно.
Уже на мобильных устройствах с ==3G== мы видим самую сильную просадку при загрузке ==SPA==. Телефоны - это самая уязвимая группа для таких приложений.

![](_png/Pasted%20image%2020230122192134.png)

Реальные метрики, из чего складывается производительность:
- Самый важный показатель - ==Time to Interactive== показывает нам, сколько времени нужно ожидать, чтобы начать пользоваться страницей.
- ==Total Blocking Time== на `SSR` имеет меньшее время, так как клиент получает готовую страницу и у него происходит только гидратация, чтобы обогатить страницу 
- Последний показатель ==Layout Shift== показывает нам, насколько сдвигаются блоки на странице при её загрузке. На `SSR`, показатель минимален, так как сразу получаем готовую страницу 

Тут стоит сразу сказать, что если мы создаём какое-то клиентское приложение, то для него лучше использовать `SSR`. Если мы строим графики, дэшборды, показываем сложные анимации и всё остальное, то тут стоит использовать `CSR`.

![](_png/Pasted%20image%2020230122192312.png)

## 003 SSR в NextJS



![](_png/Pasted%20image%2020230122193534.png)

У нас имеются три метода, которые импользуются для получения данных SSR и CSR
- Они используются только на сервере
- Они могут применяться только на страницах (не на компонентах и нигде-либо ещё - это специфика ==NextJS==)

![](_png/Pasted%20image%2020230122194635.png)

Функцию `getStaticProps` мы используем, когда:
- Данные для страницы уже имеются на этапе сборки
- Данные не представляют из себя персональные и могут быть доступны любому пользователю
- Страница доступа для индексирования сайтами

![](_png/Pasted%20image%2020230122194834.png)

Примерно так выглядит данная функция:
- Вверху располагается сама страница, которая у нас рендерится
- Далее мы экспортируем `getStaticProps`, которая возвращает полученные статические пропсы (которые можно определить по интерфейсу, который передаётся в дженерике)
- На вход эта функция принимает в себя ==контекст==
- Далее мы отправляем запрос на бэк
- Получаем результат
- Возвращаем результат, удовлетворяя интерфейсу

В результате мы получаем пропсы, которые в результате передаются на нашу страницу:
Страница `Page` получает пропс `res` из функции `getStaticProps`

Так же в самом низу указан тип пропсов - это мы делаем для того, чтобы всегда работала проверка на типы

![](_png/Pasted%20image%2020230122195131.png)

Данные, которые мы можем передать в контекст:
- `params` - это те параметры, которые могут быть переданы для генерации определённой страницы
- `preview` позволяет нам отобразить определённые изменения на странице, но без генерации этой страницы (`previewData` - это уже сами данные для превью режима) 
- Локали уже позволяет адаптировать страницу под разные языки. Пример: `/ru` или `/en` у сайтов.

![](_png/Pasted%20image%2020230122195817.png)

Так же мы можем возвращать разные данные в функции `getStaticProps`:
- `props` - возвращает сами данные для генерации страницы
- `revalidate` - определяет количество времени, после которого страница будет сгенерирована заново (генерируется заново она статически)
- `redirect` - позволяет перенаправлять пользователя на определённый `destination`. Так же можно перенаправлять по определённому условию `premanent` (всегда перенаправлять или нет)
- `notFound` - позволяет вывести страницу 404, если мы, например, не получили данные при запросе на нужную для нас апишку

==Ревалидация== - ==Инкрементальная статическая генерация== - после выкладки приложения, страницы с заданным временем ревалидации будут генерироваться заново (или первый раз, если ранее страницы не было), подтягивая новый контент.

![](_png/Pasted%20image%2020230122200252.png)







## 004 Использование getStaticProps









## 005 Использование getStaticPaths





