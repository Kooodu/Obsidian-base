
### 001 React Hooks

В обычной жизни, когда нам нужно просто вывести компонент без изменения его жизненного цикла, состояния и прочих вводных - мы можем пользоваться просто функциональными компонентами. В старом реакте нельзя было пользоваться функциональными компонентами, если мы хотели менять его состояние во времени. 

На данный момент после версии ==React 16.8== мы наконец можем пользоваться хуками, которые позволяют изменять состояние функциональных компонентов без использования классов и их возможностей. 

На данный момент классовым компонентом обязательно является только `Error Boundaries`

![](_png/Pasted%20image%2020221227131704.png)

Сейчас рекомендуется использовать только функциональные компоненты, так как они упрощают разработку веб-приложения - облегчают визуальное представление и разбиение кода на компоненты

![](_png/Pasted%20image%2020221227131756.png)

Всего имеются 3 основных компонента: 
- `useState` - позволяет работать с состоянием компонента
- `useEffect` - позволяет подписаться на изменение жизненного цикла объекта и производить изменения. Может, например, срабатывать при изменении пропса компонента
- `useContext` - позволяет использовать глобальный контекст (записывать в него значение и читать)

И 7 дополнительных:
- `useReducer` - позволяет контролировать состояние объекта, как и `useState`, но больше подходит под стиль работы ==Redux==
- `useCallback` - позволяет выполнить функцию при изменении входящих параметров
- `useMemo` - позволяет запомнить результат функции и не будет требовать перерендера компонента при изменении входящих параметров
- `useRef` - отвечает за получение ссылки с компонента на имя в дом-дереве
- `useLayoutEffect` - это эффект, который триггерится после построения дом-дерева (не стоит использовать, так как он может затормозить все анимации) 
- `useImperativeHandle` - позволяет прокидывать на родительские компоненты какие-либо референсы
- `useDebugValue` - позволяет отображать в ==DevTools== какую-либо величину для дебага


![](_png/Pasted%20image%2020221227132152.png)

### 002 useState

Данная функция позволяет управлять состоянием объекта и менять его. Она возвращает tuple из самого значения состояния и функции, которая позволяет менять данное состояние. Сама функция принимает в себя любое значение, а в дженерике передаваемый в неё тип данных

![](_png/Pasted%20image%2020221227133458.png)

Состояний в одном компоненте может быть сколько угодно - деструктуризация на плечах программиста

![](_png/Pasted%20image%2020221227133550.png)

Возвращать мы всегда должны абсолютно новый объект, который будет иметь полностью тот же вид, но другое значение. *Мутировать объекты - нельзя*

![](_png/Pasted%20image%2020221227133638.png)

Так же мы можем для инициализации нового состояния (со своим значением) определить функцию, которая вернёт уже готовое значение состояния

![](_png/Pasted%20image%2020221227133745.png)

Добавим небольшой код, в котором мы определим состояние счётчика и будем имеющимися двумя кнопками менять это состояние.
Конкретно функция `setCounter()` позволяет нам поменять внутри себя значение `counter`. Данная функция принимает в себя значение состояния и возвращает всегда новый объект (старое значение состояния утилизируется) 

`index.tsx`
```JSX
import { useState } from 'react';
import { Button, Htag, Paragraph, Tag } from '../components';

export default function Home(): JSX.Element {
	const [counter, setCounter] = useState<number>(0);

	return (
		<>
			<Htag tag="h1">{counter}</Htag>
			<Button appearance="primary" arrow="right" onClick={() => setCounter((x)=>++x)}>
				Кнопка прибавления числа
			</Button>
			<Button appearance="ghost" arrow="down" onClick={() => setCounter((x) => --x)}>
				Кнопка убавления числа
			</Button>
			<Paragraph size="l">БОЛЬШОЙ: Текста очень много</Paragraph>
			<Paragraph size="m">СРЕДНИЙ: Текста очень много</Paragraph>
			<Paragraph size="s">МАЛЕНЬКИЙ: Текста очень много</Paragraph>
			<Tag color="green" size="m">
				-10000
			</Tag>
			<Tag size="m" color="primary" href="www.google.com">
				Google
			</Tag>
		</>
	);
}
```

И теперь можно покликать на кнопки, что позволит уменьшить и увеличить значение данного счётчика

![](_png/Pasted%20image%2020221227135206.png)

Если вместо `useState` мы попытаемся использовать обычное изменение значения, то у нас ничего не получится. Дело будет заключаться в том, что хук даёт распоряжение реакту перерендерить само значение и связанные с ним компоненты и поэтому они на странице обновятся. При обычном изменении значения реакт не будет знать, что страницу нужно перерендерить и значение не будет перед нами меняться

![](_png/Pasted%20image%2020221227134848.png)

### 003 useEffect

Функция `useEffect` выполняется сразу после изменение какой-любо величины, которую мы определили в качестве зависимости. Сама функция внутри себя выполняет определённую логику (на эффект на странице). И далее по желанию можно вернуть функцию, которая будет что-то выполнять. 

![](_png/Pasted%20image%2020221227140747.png)

1) Если мы передадим пустой массив зависимостей, то функция выполнится один раз ровно во время первого появления компонента на странице
2) Во втором случае функция будет выполняться каждый раз, когда будет выполняться любой перерендер страницы (эта функция будет происходить асинхронно и рендер не будет ждать выполнения этого эффекта)
3) Если мы выполняем какую-то функцию и возвращаем другую функцию и так же мы подписаны на пустой массив, то эффект будет срабатывать только при исчезновении компонента со страницы
4) Самый частый. Выполняется только при изменении параметра, на который подписан `useEffect`

![](_png/Pasted%20image%2020221227141140.png)
![](_png/Pasted%20image%2020221227141416.png)

Тут эффект срабатывает при каждом нажатии и при размонитровке компонента

`index.tsx`
```TSX
const [counter, setCounter] = useState<number>(0);

useEffect(() => {
	console.log('Counter ' + counter);
	return function cleanup() {
		console.log('Umount');
	};
});
```

![](_png/Pasted%20image%2020221227142013.png)

Тут эффект сработает только один раз

`index.tsx`
```TSX
useEffect(() => {
	console.log('Counter ' + counter);
	return function cleanup() {
		console.log('Umount');
	};
}, []);
```

![](_png/Pasted%20image%2020221227142219.png)

Так же можно использовать сразу несколько `useEffect`.И теперь у нас можно увидеть, когда компонент смонитровался и появился.

`index.tsx`
```TSX
useEffect(() => {
	console.log('Counter ' + counter);
	return function cleanup() {
		console.log('Umount');
	};
}, []);

useEffect(() => {
	console.log('Mounted');
}, []);
```

![](_png/Pasted%20image%2020221227145609.png)

### 004 Правила использования Hooks

1) Все хуки нужно вызывать как из самого компонента либо из пользовательских компонентов. Тем самым мы обеспечиваем выполнение хуков в течение жизненного цикла компонента. 
2) Так же хуки всегда должны использоваться только на верхнем уровне компонента. Вкладывание хуков - запрещено. Пример снизу показывает неправильную реализацию работы хука:
![](_png/Pasted%20image%2020221227150613.png)
Тут уже представлен правильный пример, где условие находится внутри хука:
![](_png/Pasted%20image%2020221227150722.png)

Установим дополнительно плагин еслинта для реакт-хуков

```bash
npm install eslint-plugin-react-hooks --save-dev
```

Добавляем данную строчку

```JSON
{
	"extends": [
		"plugin:react-hooks/recommended"
	]
}
```

С такими настройками нам теперь нельзя вкладывать хуки в другие вложения

![](_png/Pasted%20image%2020221227160347.png)

### 005 Архитектура компонента рейтинга

Рейтинг будет на входе получать значение рейтинга. На него будет воздействовать наведение мышкой. На выходе будет управляться установкой нового рейтинга и функциями при нажатии.

![](_png/Pasted%20image%2020221227160550.png)

### 006 Компонент рейтинга - 1







### 007 Компонент рейтинга - 2







