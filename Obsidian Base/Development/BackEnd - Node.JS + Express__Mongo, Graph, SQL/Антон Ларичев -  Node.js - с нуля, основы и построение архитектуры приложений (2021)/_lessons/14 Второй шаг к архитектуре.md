## 078 Улучшение архитектуры

Далее мы идём улучшать нашу архитектуру. 
Первым делом, запрос должен идти не напрямую в `middleware`, а через `data transfer object`, который хранит в себе данные в виде определённой структуры.
Внутри `middleware` будет находиться валидатор, который будет проверять `dto` на корректность переданных данных.
Так же мы введём такое понятие, как `entity` - это объект нашей бизнес-единицы, который сфокусирован на работе с самим объектом: создание объекта, преобразование и реализация внутренних методов (например, у пользователя есть метод хеширования его пароля).
Всё, что связано с бизнес-логикой, будет инкапсулировано в `services` и `entity` 

![](_png/Pasted%20image%2020221203200646.png)

## 079 Data transfer object

`dto` будет представлять из себя класс, который описывает, что мы получаем извне и передаём в контроллер

Сразу нужно сказать, что если наши классы очень похожи по принимаемым данным, то в данном случае мы могли бы сделать класс `UserCredentional` и от него экстендить эти два представленных класса. Однако объединять два `dto` - не нужно!

`users > dto > user-register.dto.ts`
```TS
export class UserRegisterDto {
	email: string;
	password: string;
	name: string;
}
```

`users > dto > user-login.dto.ts`
```TS
export class UserLoginDto {
	email: string;
	password: string;
}
```

Ну и далее нужно упомянуть, что тип `Request` из `express` принимает в себя дженерик из трёх параметров, где третий представляет из себя `body` принимаемых данных
И теперь в методе `login` мы видим, что в запросе `req.body` сам `body` будет иметь тип данных `UserLoginDto` - *то есть третий дженерик определяет тип `body` полученного запроса*

`users.controller.ts`
```TS
import { UserLoginDto } from './dto/user-login.dto';
import { UserRegisterDto } from './dto/user-register.dto';

// code ...

login(req: Request<{}, {}, UserLoginDto>, res: Response, next: NextFunction): void {
	console.log(req.body);
	next(new HTTPError(401, 'ошибка авторизации', 'login'));
}

register(req: Request<{}, {}, UserRegisterDto>, res: Response, next: NextFunction): void {
	console.log(req.body);
	this.ok(res, 'register');
}

// code ...
```

И далее, чтобы увидеть ответ от сервера, нужно установить модуль, который будет серилиазовать полученный `body` в `JSON` 

```bash
npm i body-parser
```



```TS
import { json } from 'body-parser';

@injectable()
export class App {
	// code ...

	// тут мы подключаем использование прослойки в виде сериализатора принимаемых ответов - теперь экспресс сможет нормально принимать данные
	useMiddleware(): void {
		this.app.use(json());
	}
	
	// code ...
	
	public async init(): Promise<void> {
		this.useMiddleware();
		this.useRoutes();
		this.useExeptionFilters();
		this.server = this.app.listen(this.port);
		this.logger.log(`Сервер запущен на http://localhost:${this.port}`);
	}
	
	// code ...
}
```

![](_png/Pasted%20image%2020221204174048.png)



## 080 User entity




## 081 Сервис users




## 082 Middleware для роутов




## 083 Валидация данных





