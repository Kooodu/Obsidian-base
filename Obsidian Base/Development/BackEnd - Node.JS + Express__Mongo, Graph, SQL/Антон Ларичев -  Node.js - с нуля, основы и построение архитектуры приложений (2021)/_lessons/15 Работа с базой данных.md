## 084 Сервис конфигурации

Добавляем в приложение возможность читать файлы `.env`

```bash
npm i dotenv
```



`корень проекта > .env`
```md
SALT=10
```





`config > config.service.interface.ts`
```TS
export interface IConfigService {
	get: <T extends string | number>(key: string) => T;
}
```


`config > config.service.ts`
```TS
import { IConfigService } from './config.service.interface';
import { config, DotenvConfigOutput, DotenvParseOutput } from 'dotenv';
import { inject, injectable } from 'inversify';
import { TYPES } from '../types';
import { ILogger } from '../logger/logger.interface';

@injectable()
export class ConfigService implements IConfigService {
	// это наш конфиг, который попадёт в класс
	private config: DotenvParseOutput;

	constructor(@inject(TYPES.ILogger) private logger: ILogger) {
		// тут мы запрашиваем отпаршенный конфиг .env
		const result: DotenvConfigOutput = config();

		// если ошибка, то выведем логгер
		if (result.error) {
			this.logger.error('[ConfigService] Не удалось прочитать файл конфигурации');
		} else {
			// если всё хорошо, то будем присваивать отпаршенный конфиг в наш конфиг
			// делаем жёсткий прокаст, так как присваивается result, а не отдельный от него parsed
			this.config = result.parsed as DotenvParseOutput;

			this.logger.log('[ConfigService] Конфигурация загружена');
		}
	}

	get<T extends number | string>(key: string): T {
		return this.config[key] as T;
	}
}
```


`types.ts`
```TS
export const TYPES = {
	Application: Symbol.for('Application'),
	ILogger: Symbol.for('ILogger'),
	UserController: Symbol.for('UserController'),
	UserService: Symbol.for('UserService'),
	ExeptionFilter: Symbol.for('ExeptionFilter'),
	ConfigService: Symbol.for('ConfigService'),
};
```


`app.ts`
```TS
constructor(
	@inject(TYPES.ILogger) private logger: ILogger,
	@inject(TYPES.UserController) private userController: UserController,
	@inject(TYPES.ExeptionFilter) private exeptionFilter: IExeptionFilter,
	// добавляем ConfigService
	@inject(TYPES.ConfigService) private configService: IConfigService,
) {
	this.app = express();
	this.port = 8000;
}
```

`users.service.ts`
```TS
constructor(
	// добавляем ConfigService
	@inject(TYPES.ConfigService) private configService: IConfigService,
) {}
```

`main.ts`
```TS
export const appBindings = new ContainerModule((bind: interfaces.Bind) => {
	bind<ILogger>(TYPES.ILogger).to(LoggerService);
	bind<IExeptionFilter>(TYPES.ExeptionFilter).to(ExeptionFilter);
	bind<IUserController>(TYPES.UserController).to(UserController);
	bind<IUserService>(TYPES.UserService).to(UserService);
	bind<App>(TYPES.Application).to(App);
	//
	bind<IConfigService>(TYPES.ConfigService).to(ConfigService);
});
```


И тут мы видим, что у нас вызывается два разных инстанса одного класса, что может быть довольно опасно 

![](_png/Pasted%20image%2020221206095417.png)

Чтобы исправить проблему, нужно перевести конкретно данный класс в синглтон, что позволит нам инстанциировать ровно один раз одну копию класса (то есть, она всегда буде одинакова). Чтобы сделать это, нужно при биндинге указать дополнительным методом `inSingletonScope()`, что нам нужно иметь именно один конкретный инстанс класса

```TS
export const appBindings = new ContainerModule((bind: interfaces.Bind) => {
	bind<ILogger>(TYPES.ILogger).to(LoggerService).inSingletonScope();
	bind<IExeptionFilter>(TYPES.ExeptionFilter).to(ExeptionFilter);
	bind<IUserController>(TYPES.UserController).to(UserController);
	bind<IUserService>(TYPES.UserService).to(UserService);
	bind<IConfigService>(TYPES.ConfigService).to(ConfigService).inSingletonScope();
	bind<App>(TYPES.Application).to(App);
});
```

![](_png/Pasted%20image%2020221206095710.png)








## 085 Работа с [prisma](https://www.prisma.io/)



```bash
npm i -D prisma
npm i @prisma/client
npx prisma init
```

6:31


## 086 Репозиторий users






## 087 Упражнение - Логин пользователя









