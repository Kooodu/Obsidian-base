## 084 Сервис конфигурации

Добавляем в приложение возможность читать файлы `.env`

```bash
npm i dotenv
```

Создаём файл конфигурации окружения `.env`

`корень проекта > .env`
```md
SALT=10
```

Далее нужно создать интерфейс для получения значения из конфигурации окружения

`config > config.service.interface.ts`
```TS
export interface IConfigService {  
	get: (key: string) => string;  
}
```

И тут реализуем сам сервис по получению данных из файла конфига окружения

`config > config.service.ts`
```TS
import { IConfigService } from './config.service.interface';
import { config, DotenvConfigOutput, DotenvParseOutput } from 'dotenv';
import { inject, injectable } from 'inversify';
import { TYPES } from '../types';
import { ILogger } from '../logger/logger.interface';

@injectable()
export class ConfigService implements IConfigService {
	// это наш конфиг, который попадёт в класс
	private config: DotenvParseOutput;

	constructor(@inject(TYPES.ILogger) private logger: ILogger) {
		// тут мы запрашиваем отпаршенный конфиг .env
		const result: DotenvConfigOutput = config();

		// если ошибка, то выведем логгер
		if (result.error) {
			this.logger.error('[ConfigService] Не удалось прочитать файл конфигурации');
		} else {
			// если всё хорошо, то будем присваивать отпаршенный конфиг в наш конфиг
			// делаем жёсткий прокаст, так как присваивается result, а не отдельный от него parsed
			this.config = result.parsed as DotenvParseOutput;

			this.logger.log('[ConfigService] Конфигурация загружена');
		}
	}

	get(key: string): string {  
	   return this.config[key];  
	}
}
```

Добавляем новый символ тайп по нашему сервису

`types.ts`
```TS
export const TYPES = {
	Application: Symbol.for('Application'),
	ILogger: Symbol.for('ILogger'),
	UserController: Symbol.for('UserController'),
	UserService: Symbol.for('UserService'),
	ExeptionFilter: Symbol.for('ExeptionFilter'),
	ConfigService: Symbol.for('ConfigService'),
};
```

Инжектим сервис в приложение

`app.ts`
```TS
constructor(
	@inject(TYPES.ILogger) private logger: ILogger,
	@inject(TYPES.UserController) private userController: UserController,
	@inject(TYPES.ExeptionFilter) private exeptionFilter: IExeptionFilter,
	// добавляем ConfigService
	@inject(TYPES.ConfigService) private configService: IConfigService,
) {
	this.app = express();
	this.port = 8000;
}
```

И инжектим в сервис пользователя, так как в нём мы генерируем новый пароль (нам нужен тут параметр `SALT`)

`users.service.ts`
```TS
constructor(
	// добавляем ConfigService
	@inject(TYPES.ConfigService) private configService: IConfigService,
) {}
```

И тут же биндим наш новый сервис в контейнер модулей приложения

`main.ts`
```TS
export const appBindings = new ContainerModule((bind: interfaces.Bind) => {
	bind<ILogger>(TYPES.ILogger).to(LoggerService);
	bind<IExeptionFilter>(TYPES.ExeptionFilter).to(ExeptionFilter);
	bind<IUserController>(TYPES.UserController).to(UserController);
	bind<IUserService>(TYPES.UserService).to(UserService);
	bind<App>(TYPES.Application).to(App);
	//
	bind<IConfigService>(TYPES.ConfigService).to(ConfigService);
});
```


И тут мы видим, что у нас вызывается два разных инстанса одного класса, что может быть довольно опасно 

![](_png/Pasted%20image%2020221206095417.png)

Чтобы исправить проблему, нужно перевести конкретно данный класс в синглтон, что позволит нам инстанциировать ровно один раз одну копию класса (то есть, она всегда буде одинакова). Чтобы сделать это, нужно при биндинге указать дополнительным методом `inSingletonScope()`, что нам нужно иметь именно один конкретный инстанс класса

```TS
export const appBindings = new ContainerModule((bind: interfaces.Bind) => {
	bind<ILogger>(TYPES.ILogger).to(LoggerService).inSingletonScope();
	bind<IExeptionFilter>(TYPES.ExeptionFilter).to(ExeptionFilter);
	bind<IUserController>(TYPES.UserController).to(UserController);
	bind<IUserService>(TYPES.UserService).to(UserService);
	bind<IConfigService>(TYPES.ConfigService).to(ConfigService).inSingletonScope();
	bind<App>(TYPES.Application).to(App);
});
```

![](_png/Pasted%20image%2020221206095710.png)

Тут меняем метод генерации пароля на получение соли (`salt`) извне 

`user.entity.ts`
```TS
public async setPassword(pass: string, salt: number): Promise<void> {  
   this._password = await hash(pass, salt);  
}
```

А тут получаем из `ConfigService` через метод `get` определённое значение нашего `.env` файла, а конкретно параметра `SALT`. Далее новому пользователю устанавливаем пароль 

`users.service.ts`
```TS
constructor(
	// добавляем ConfigService
	@inject(TYPES.ConfigService) private configService: IConfigService,
) {}

async createUser({ email, name, password }: UserRegisterDto): Promise<User | null> {
	const newUser = new User(email, name);

	// получаем соль для генерации пароля
	const salt = this.configService.get('SALT');
	await newUser.setPassword(password, Number(salt));
	console.log(salt);

	// проверка что он есть?
	// если есть - возвращаем null
	// если нет - создаём
	return null;
}
```

И теперь после отправки запроса на сервер, можно увидеть полученные данные из `.env`

![](_png/Pasted%20image%2020221206101628.png)

## 085 Работа с [prisma](https://www.prisma.io/)

Для написания запросов и построения моделей баз данных будет использоваться Prism ORM. Она позволяет прямо из кода приложения описать нашу базу данных и взаимодействовать с ней.
Конкретно в курсе будет использоваться `SQLite` +` Prism ORM`

![](_png/Pasted%20image%2020221206103016.png)

Первым делом, нужно установить призму

```bash
// устанавливаем призму
npm i -D prisma

// устанавливаем клиент призмы
npm i @prisma/client

// инициализируем призму
npx prisma init
```

Далее настроим плагин в VSCode для призмы

`.vscode > settings.json`
```JSON
{
	"[typescript]": {
		"editor.defaultFormatter": "dbaeumer.vscode-eslint"
	},
	"editor.codeActionsOnSave": {
		"source.fixAll.eslint": true
	},
	"[prisma]": {
		"editor.defaultFormatter": "Prisma.prisma"
	},
}
```

После последней команды терминала у нас появляется папка `prisma`, в которой находится файл схемы призмы. Тут мы формируем саму модель работы призмы. 
Первым делом делаем коннект в `db` к нужной базе данных и к файлу, в которой будет храниться база. 
Далее нужно создать модель пользователя в `UserModel`, где укажем нужные поля под его данные 

`schema.prisma`
```json
// клиент генератора запросов
generator client {
    provider = "prisma-client-js"
}

// исходники для данных
datasource db {
    // тут нужно указать, к какой БД подключаемся
    provider = "sqlite"
    // это ссылка до файла базы данных
    // создастся автоматически при начале работы с призмой
    url      = "file:./dev.db"
}

// тут уже будет находиться само статическое описание модели пользователя
model UserModel {
    id       Int    @id @default(autoincrement())
    email    String
    password String
    name     String
}
```

Дальше произведём первую миграцию, при которой у нас создастся файл БД

```bash
npx prisma migrate dev
```

Каждой миграции даётся своё имя

![](_png/Pasted%20image%2020221206114914.png)

И мы имеем примерно такую структуру после миграции:

![](_png/Pasted%20image%2020221206114917.png)

Уберём базы и окружение из отслеживания гита (так как там может храниться важная информация)

`.gitignore`
```md
/node_modules
/dist
/.clinic
/.env
/prisma/dev.db
/prisma/dev.db-journal
```

Так же отдельно вынесем команду, которая будет генерировать типы нашей сформированной базы данных

`package.json`
```JSON
"scripts": {
	"generate": "prisma generate"
},
```

После срабатывания данной команды генерации типов, описанные в схеме модели конвертируются в типы, которые мы можем использовать в проекте

![](_png/Pasted%20image%2020221209151752.png)

Сейчас нам нужно привязать сервис призмы к нашему приложению через `DI`

`types.ts`
```TS
export const TYPES = {
	Application: Symbol.for('Application'),
	ILogger: Symbol.for('ILogger'),
	UserController: Symbol.for('UserController'),
	UserService: Symbol.for('UserService'),
	ExeptionFilter: Symbol.for('ExeptionFilter'),
	ConfigService: Symbol.for('ConfigService'),
	//
	PrismaService: Symbol.for('PrismaService'),
};
```

`main.ts`
```TS
export const appBindings = new ContainerModule((bind: interfaces.Bind) => {
	bind<ILogger>(TYPES.ILogger).to(LoggerService).inSingletonScope();
	bind<IExeptionFilter>(TYPES.ExeptionFilter).to(ExeptionFilter);
	bind<IUserController>(TYPES.UserController).to(UserController);
	bind<IUserService>(TYPES.UserService).to(UserService);
	// биндим призму, используя синглтон
	bind<PrismaService>(TYPES.PrismaService).to(PrismaService).inSingletonScope();
	bind<IConfigService>(TYPES.ConfigService).to(ConfigService).inSingletonScope();
	bind<App>(TYPES.Application).to(App);
});
```

`app.ts`
```TS
constructor(
	@inject(TYPES.ILogger) private logger: ILogger,
	@inject(TYPES.UserController) private userController: UserController,
	@inject(TYPES.ExeptionFilter) private exeptionFilter: IExeptionFilter,
	@inject(TYPES.ConfigService) private configService: IConfigService,
	// инжектим инстанс призмы к приложению
	@inject(TYPES.PrismaService) private prismaService: PrismaService,
) {
	this.app = express();
	this.port = 8000;
}

public async init(): Promise<void> {
	this.useMiddleware();
	this.useRoutes();
	this.useExeptionFilters();

	// подключаемся асинхронно к сервису призмы
	await this.prismaService.connect();
	
	this.server = this.app.listen(this.port);
	this.logger.log(`Сервер запущен на http://localhost:${this.port}`);
}
```

И тут уже представлена сама реализация функции нашего сервиса по работе с призмой

`database > prisma.service.ts`
```TS
import { PrismaClient, UserModel } from '@prisma/client';
import { inject, injectable } from 'inversify';
import { TYPES } from '../types';
import { ILogger } from '../logger/logger.interface';

@injectable()
export class PrismaService {
	// клиент призмы
	client: PrismaClient;

	// инстанциируем сам клиент призмы
	constructor(@inject(TYPES.ILogger) private logger: ILogger) {
		this.client = new PrismaClient();
	}

	// метод подключения к базе данных
	async connect(): Promise<void> {
		try {
			await this.client.$connect();
			this.logger.log('[PrismaService] совершено успешное подключение к базе данных');
		} catch (e: unknown) {
			if (e instanceof Error) {
				this.logger.log(`[PrismaService] не удалось подключиться к базе данных ${e.message}`);
			}
		}
	}

	// метод отключения от базы данных
	async disconnect(): Promise<void> {
		await this.client.$disconnect();
		this.logger.log('[PrismaService] совершено отключение от базе данных');
	}
}
```

Лог о подключении к базе данных

![](_png/Pasted%20image%2020221209154246.png)

## 086 Репозиторий users



`users.repository.interface.ts`
```TS
import { UserModel } from '@prisma/client';  
import { User } from './user.entity';  
  
export interface IUsersRepository {  
   create: (user: User) => Promise<UserModel>;  
}
```




## 087 Упражнение - Логин пользователя









