## 084 Сервис конфигурации

Добавляем в приложение возможность читать файлы `.env`

```bash
npm i dotenv
```

Создаём файл конфигурации окружения `.env`

`корень проекта > .env`
```md
SALT=10
```

Далее нужно создать интерфейс для получения значения из конфигурации окружения

`config > config.service.interface.ts`
```TS
export interface IConfigService {  
	get: (key: string) => string;  
}
```

И тут реализуем сам сервис по получению данных из файла конфига окружения

`config > config.service.ts`
```TS
import { IConfigService } from './config.service.interface';
import { config, DotenvConfigOutput, DotenvParseOutput } from 'dotenv';
import { inject, injectable } from 'inversify';
import { TYPES } from '../types';
import { ILogger } from '../logger/logger.interface';

@injectable()
export class ConfigService implements IConfigService {
	// это наш конфиг, который попадёт в класс
	private config: DotenvParseOutput;

	constructor(@inject(TYPES.ILogger) private logger: ILogger) {
		// тут мы запрашиваем отпаршенный конфиг .env
		const result: DotenvConfigOutput = config();

		// если ошибка, то выведем логгер
		if (result.error) {
			this.logger.error('[ConfigService] Не удалось прочитать файл конфигурации');
		} else {
			// если всё хорошо, то будем присваивать отпаршенный конфиг в наш конфиг
			// делаем жёсткий прокаст, так как присваивается result, а не отдельный от него parsed
			this.config = result.parsed as DotenvParseOutput;

			this.logger.log('[ConfigService] Конфигурация загружена');
		}
	}

	get(key: string): string {  
	   return this.config[key];  
	}
}
```

Добавляем новый символ тайп по нашему сервису

`types.ts`
```TS
export const TYPES = {
	Application: Symbol.for('Application'),
	ILogger: Symbol.for('ILogger'),
	UserController: Symbol.for('UserController'),
	UserService: Symbol.for('UserService'),
	ExeptionFilter: Symbol.for('ExeptionFilter'),
	ConfigService: Symbol.for('ConfigService'),
};
```

Инжектим сервис в приложение

`app.ts`
```TS
constructor(
	@inject(TYPES.ILogger) private logger: ILogger,
	@inject(TYPES.UserController) private userController: UserController,
	@inject(TYPES.ExeptionFilter) private exeptionFilter: IExeptionFilter,
	// добавляем ConfigService
	@inject(TYPES.ConfigService) private configService: IConfigService,
) {
	this.app = express();
	this.port = 8000;
}
```

И инжектим в сервис пользователя, так как в нём мы генерируем новый пароль (нам нужен тут параметр `SALT`)

`users.service.ts`
```TS
constructor(
	// добавляем ConfigService
	@inject(TYPES.ConfigService) private configService: IConfigService,
) {}
```

И тут же биндим наш новый сервис в контейнер модулей приложения

`main.ts`
```TS
export const appBindings = new ContainerModule((bind: interfaces.Bind) => {
	bind<ILogger>(TYPES.ILogger).to(LoggerService);
	bind<IExeptionFilter>(TYPES.ExeptionFilter).to(ExeptionFilter);
	bind<IUserController>(TYPES.UserController).to(UserController);
	bind<IUserService>(TYPES.UserService).to(UserService);
	bind<App>(TYPES.Application).to(App);
	//
	bind<IConfigService>(TYPES.ConfigService).to(ConfigService);
});
```


И тут мы видим, что у нас вызывается два разных инстанса одного класса, что может быть довольно опасно 

![](_png/Pasted%20image%2020221206095417.png)

Чтобы исправить проблему, нужно перевести конкретно данный класс в синглтон, что позволит нам инстанциировать ровно один раз одну копию класса (то есть, она всегда буде одинакова). Чтобы сделать это, нужно при биндинге указать дополнительным методом `inSingletonScope()`, что нам нужно иметь именно один конкретный инстанс класса

```TS
export const appBindings = new ContainerModule((bind: interfaces.Bind) => {
	bind<ILogger>(TYPES.ILogger).to(LoggerService).inSingletonScope();
	bind<IExeptionFilter>(TYPES.ExeptionFilter).to(ExeptionFilter);
	bind<IUserController>(TYPES.UserController).to(UserController);
	bind<IUserService>(TYPES.UserService).to(UserService);
	bind<IConfigService>(TYPES.ConfigService).to(ConfigService).inSingletonScope();
	bind<App>(TYPES.Application).to(App);
});
```

![](_png/Pasted%20image%2020221206095710.png)

Тут меняем метод генерации пароля на получение соли (`salt`) извне 

`user.entity.ts`
```TS
public async setPassword(pass: string, salt: number): Promise<void> {  
   this._password = await hash(pass, salt);  
}
```

А тут получаем из `ConfigService` через метод `get` определённое значение нашего `.env` файла, а конкретно параметра `SALT`. Далее новому пользователю устанавливаем пароль 

`users.service.ts`
```TS
constructor(
	// добавляем ConfigService
	@inject(TYPES.ConfigService) private configService: IConfigService,
) {}

async createUser({ email, name, password }: UserRegisterDto): Promise<User | null> {
	const newUser = new User(email, name);

	// получаем соль для генерации пароля
	const salt = this.configService.get('SALT');
	await newUser.setPassword(password, Number(salt));
	console.log(salt);

	// проверка что он есть?
	// если есть - возвращаем null
	// если нет - создаём
	return null;
}
```

И теперь после отправки запроса на сервер, можно увидеть полученные данные из `.env`

![](_png/Pasted%20image%2020221206101628.png)

## 085 Работа с [prisma](https://www.prisma.io/)

Для написания запросов и построения моделей баз данных будет использоваться Prism ORM. Она позволяет прямо из кода приложения описать нашу базу данных и взаимодействовать с ней.
Конкретно в курсе будет использоваться `SQLite` +` Prism ORM`

![](_png/Pasted%20image%2020221206103016.png)



```bash
npm i -D prisma
npm i @prisma/client
npx prisma init
```












## 086 Репозиторий users






## 087 Упражнение - Логин пользователя









