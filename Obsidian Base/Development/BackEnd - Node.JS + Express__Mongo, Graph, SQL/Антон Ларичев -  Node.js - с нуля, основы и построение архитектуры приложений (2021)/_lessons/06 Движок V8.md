## 027 Устройство V8

Представление JS выглядит следующим образом:
- ==Javascript code== - это тот код, который мы пишем
- ==Abstract Syntaxis Tree== - это дерево, в которое уже интерпретируется весь наш код
- ==Byte code== - это следующий этап превращения кода, когда всё описывается 1-байтовыми величинами
- ==Машинный код== - код, который воспринимает машина

![](_png/Pasted%20image%2020221123143211.png)

Само дерево выглядит примерно таким образом:
Мы видим функцию, что в ней находится в качестве экспрешшенов, операторы, отдельно связывание переменной и значения.

![](_png/Pasted%20image%2020221123143633.png)

Дальше у нас идёт байткод. Это набор инструкций, который конкретно по регистрам говорит, что и куда класть, чтобы получить определённый результат.

![](_png/Pasted%20image%2020221123144147.png)

Ну и так же мы можем вывести непосредственно байткод нашего приложения, если на то будет потребность

```bash
node --print-bytecode byte.js
```

![](_png/Pasted%20image%2020221123145131.png)

Как выглядит компиляция кода в нашем движке `V8`:
1) Мы имеем наш исходный ==Javascript code==
2) Дальше он проходит через парсер и преобразуется в ==AST==
3) После он преобразуется в ==байт код== интерпретатором
4) После чего выбираются два основных пути: 
	1) Используем компилятор `Turbofan`, если наш написанный код можно оптимизировать (например, если у нас постоянно повторяется операция умножения в коде, то её можно заоптимизировать)
	2) Используем компилятор `Sparkplug`, если наш написанный код нельзя оптимизировать 

![](_png/Pasted%20image%2020221123145323.png)

Пример:
Если мы создаём инстанс какого-либо объекта, то нужно сохранять порядок его свойств и количество свойств, чтобы код обрабатывался через оптимизированный компилятор 

![](_png/Pasted%20image%2020221123151004.png)

Используя TS такую оптимизацию будет поддерживать куда проще 

![](_png/Pasted%20image%2020221123152401.png)


## 028 Работа с памятью



![](_png/Pasted%20image%2020221123182246.png)

Данные очищаются ровно тогда, когда ни них не остаётся ссылок

![](_png/Pasted%20image%2020221123182250.png)

Если в этом дереве у нас пропадёт ссылка на другой объект и он окажется отвязанным от общего дерева, то этот объект удалится

![](_png/Pasted%20image%2020221123182543.png)

Проблема может оказаться в том, что объекты на удаление могут ссылаться друг на друга и тогда они не удалятся

![](_png/Pasted%20image%2020221123182548.png)

Тогда была придумана технология, которая помечала бы все объекты и очищала те, до которых она не может добраться.
Однако такая технология в реально работающем приложении очень сильно его стопорит и на каждое действие придётся вести пересчёт, что ведёт к потере ресурсов.

![](_png/Pasted%20image%2020221123182633.png)

Тут уже представлен более продвинутый алгоритм, который используется в современных движках.
Основная идея трёхцветной маркировки заключается в том, что мы красим сначала самые ближние объекты к глобальному (прямая связь) в чёрный цвет, связанные с ними объекты - в серый. Дальше все связанные объекты, до которых мы можем достучаться, красим в чёрный. Все, до которых мы не достучались, являются у нас белыми, то есть никак от изначального не помеченными. Их мы удаляем.
Этот подход отличается тем, что мы запоминаем состояние связей

![](_png/Pasted%20image%2020221123182812.png)
![](_png/Pasted%20image%2020221123183545.png)
![](_png/Pasted%20image%2020221123183548.png)







