## 027 Устройство V8

Представление JS выглядит следующим образом:
- ==Javascript code== - это тот код, который мы пишем
- ==Abstract Syntaxis Tree== - это дерево, в которое уже интерпретируется весь наш код
- ==Byte code== - это следующий этап превращения кода, когда всё описывается 1-байтовыми величинами
- ==Машинный код== - код, который воспринимает машина

![](_png/Pasted%20image%2020221123143211.png)

Само дерево выглядит примерно таким образом:
Мы видим функцию, что в ней находится в качестве экспрешшенов, операторы, отдельно связывание переменной и значения.

![](_png/Pasted%20image%2020221123143633.png)

Дальше у нас идёт байткод. Это набор инструкций, который конкретно по регистрам говорит, что и куда класть, чтобы получить определённый результат.

![](_png/Pasted%20image%2020221123144147.png)

Ну и так же мы можем вывести непосредственно байткод нашего приложения, если на то будет потребность

```bash
node --print-bytecode byte.js
```

![](_png/Pasted%20image%2020221123145131.png)

Как выглядит компиляция кода в нашем движке `V8`:
1) Мы имеем наш исходный ==Javascript code==
2) Дальше он проходит через парсер и преобразуется в ==AST==
3) После он преобразуется в ==байт код== интерпретатором
4) После чего выбираются два основных пути: 
	1) Используем компилятор `Turbofan`, если наш написанный код можно оптимизировать (например, если у нас постоянно повторяется операция умножения в коде, то её можно заоптимизировать)
	2) Используем компилятор `Sparkplug`, если наш написанный код нельзя оптимизировать 

![](_png/Pasted%20image%2020221123145323.png)

Пример:
Если мы создаём инстанс какого-либо объекта, то нужно сохранять порядок его свойств и количество свойств, чтобы код обрабатывался через оптимизированный компилятор 

![](_png/Pasted%20image%2020221123151004.png)

Используя TS такую оптимизацию будет поддерживать куда проще 

![](_png/Pasted%20image%2020221123152401.png)


## 028 Работа с памятью






