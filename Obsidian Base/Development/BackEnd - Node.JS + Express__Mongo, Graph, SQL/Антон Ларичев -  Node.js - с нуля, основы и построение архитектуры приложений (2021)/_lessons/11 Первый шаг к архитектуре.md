## 062 Обзор архитектуры

Предобработчиком нашего запроса будет `middleware`, который уже будет передавать данные на обработку в контроллер. 

Контроллер непосредственно обрабатывает запросы от пользователей.

С точки зрения слоёной архитекторы, вся бизнес-логика должна содержаться в сервисах. Сам контроллер должен просто вызвать сервис. Сервис уже сам общается с репозиторием.

Репозиторий отвечает за непосредственное общение с базой данных.

![](_png/Pasted%20image%2020221126115033.png)

Эта архитектура позволяет легко заменять определённые технологии. Например, поменяем нашу базу данных - нам придётся поменять только логику репозитория.

Так же эту систему будет легко поддерживать, так как вся логика для отдельного модуля содержится в этом одном модуле. Если нужно будет поменять сервис, то нам нужно будет править только сервис.

## 063 Пишем класс приложения

Напишем скрипты для запуска нашего приложения

`package.json`
```JSON
"main": "index.js",
  "type": "commonjs",
  "scripts": {
    "start": "node ./dist/main.js",
    "build": "tsc",
    "test": ""
  },
```

Далее настраиваем ==TS==

`tsconfig.json`
```JSON
"compilerOptions": {
	"target": "es2022", 
	"experimentalDecorators": true,
	"emitDecoratorMetadata": true,
	"module": "CommonJS", 
	"moduleResolution": "node",
	"outDir": "./dist",
}
```

Тут мы инициализируем наше приложение и запускаем

`main.ts`
```TS
import { App } from "./app";

// фукнция запуска приложения
async function bootstrap() {
	const app = new App();
	await app.init();
}

bootstrap();
```

Тут мы будет располагаться класс нашего приложения, через который будет происходить запуск всех компонентов

`app.ts`
```TS
import express, { Express, Request, Response, NextFunction } from "express";
import { Server } from "http";
import { userRouter } from "./users/users";

// класс с нашим приложением
export class App {
	app: Express;
	server: Server;
	port: number;

	constructor() {
		this.app = express();
		this.port = 8000;
		this.server = new Server();
	}

	// тут мы будем вдальнейшем определять подключенные роуты
	useRoutes() {
		this.app.use("/users", userRouter);
	}

	// тут будет происходить инициализация нашего приложения
	public async init() {
		this.useRoutes();
		this.server = this.app.listen(this.port);
		console.log(`Сервер запущен на http://localhost:${this.port}`);
	}
}
```


## 064 Добавляем логгер

Добавлять логгер мы будем отдельным модулем, который будет внедряться путём ==Dependency Injection==. То есть мы не будем инстанциировать наш логгер внутри `App` или делать логгер статичным, чтобы его просто вызывать. Мы будем передавать инстанс логгера прямо при  вызове нашего приложения

Установим сам логгер

```bash
npm i tslog
```

Тут реализован сам модуль логгера

`logger.service.ts`
```TS
// @ts-ignore
import { Logger } from "tslog";

export class LoggerService {
	public logger: Logger<string>;

	constructor() {
		this.logger = new Logger({
			// тут по идее должны были быть настройки, но нужно искать актуальную документацию
			// displayInstanceName: false,
			// displayLoggerName: false,
			// displayFilePath: "hidden",
			// displayFunctionName: false,
		});
	}

	log(...args: unknown[]) {
		this.logger.info(...args);
	}

	error(...args: unknown[]) {
		// отправка в sentry // rollbar
		this.logger.error(...args);
	}

	warn(...args: unknown[]) {
		this.logger.warn(...args);
	}
}

```

Тут мы подцепили логику выполнения логгера

`app.ts`
```TS
import express, { Express } from "express";
import { Server } from "http";
import { LoggerService } from "./logger/logger.service";
import { userRouter } from "./users/users";

export class App {
	app: Express;
	// @ts-ignore 
	server: Server;
	port: number;
	logger: LoggerService;

	constructor(logger: LoggerService) {
		this.app = express();
		this.port = 8000;
		this.logger = logger;
	}

	useRoutes() {
		this.app.use("/users", userRouter);
	}

	public async init() {
		this.useRoutes();
		this.server = this.app.listen(this.port);
		this.logger.log(`Сервер запущен на http://localhost:${this.port}`);
	}
}
```

Конкретно мы внедряем через конструктор App зависимость от другого сервиса - это пример простого ==Dependency Injection==

```TS
import { App } from "./app";
import { LoggerService } from "./logger/logger.service";

async function bootstrap() {
	const app = new App(new LoggerService());
	await app.init();
}

bootstrap();
```


## 065 Базовый класс контроллера







## 066 Упражнение - Контроллер пользователей







## 067 Обработка ошибок







