## 034 Обзор приложения

Наше приложение будет работать в консоли и выводить погоду по запросу пользователя

![](_png/Pasted%20image%2020221124144541.png)

Приложение будет стилизованным, получать аргументы и работать со сторонним API

![](_png/Pasted%20image%2020221124144647.png)


###### Получать погоду будем [отсюда](https://openweathermap.org/)


## 035 Аргументы командной строки

Поменяем точку входа в приложение и добавим бинарник, чтобы при глобальной установке нашего модуля, можно было его запустить и воспользоваться им. Так же импорты будем использовать в виде модулей, а не коммона

```JSON
"main": "weather.js",
"bin": {
	"weather": "weather.js"
},
"type": "module",
```

Эту строчку укажем в файле входа в наше приложение, чтобы указать системе как запускать этот файл

```JS
#!/usr/bin/env node
```

Объект `process.argv` хранит аргументы, которые мы передали на данный момент в консоль

```JS
#!/usr/bin/env node

const initCLI = () => {
	console.log(process.argv);
};

initCLI();
```

И тут мы можем увидеть все аргументы, что напишем в консоль

![](_png/Pasted%20image%2020221124154324.png)

![](_png/Pasted%20image%2020221124154413.png)

Ну и далее опишем логику реализации получения 

`helpers > args.js`
```JS
// эта функция будет получать аргументы, которые мы передали в скрипт терминала
const getArgs = (args) => {
	// этот объект будет хранить результат с флагами
	const res = {};
	// тут мы раскладываем наш массив
	// первые два значения - это вызыватель и вызываемый файл
	// всё остальное (rest) - это переданные аргументы
	const [executer, file, ...rest] = args;

	// отдельное значение, индекс, исходный массив
	rest.forEach((value, i, array) => {
		// если первое значение это "-", то ...
		if (value.charAt(0) == "-") {
			// если мы дошли до последнего элемента (после дефиса ничего нет)
			if (i == array.length - 1) {
				// то по ключу этого значения просто поставим true
				res[value.substring(1)] = true;

				// ... однако если второе значение уже какая-то буква, а не "-" или пустота, то ...
			} else if (array[i + 1].charAt(0) != "-") {
				// ключ в res создаём без первого минуса в значении (откидываем "-") и добавляем следующий аргумент в качестве значения флага
				res[value.substring(1)] = array[i + 1];

				// ... однако, если у нас есть второй элемент, содержащий "-", то ...
			} else {
				res[value.substring(1)] = true;
			}
		}
	});

	return res;
};

export { getArgs };
```

И тут выведем в качестве объекта наши полученные значения ключей

`weather.js`
```JS
#!/usr/bin/env node
import { getArgs } from "./helpers/args.js";

const initCLI = () => {
	const args = getArgs(process.argv);
	console.log(args);

	if (args.h) {
		// вывод help
	}

	if (args.s) {
		// сохранить город
	}

	if (args.t) {
		// сохранить токен
	}

	// Вывести погоду
};

initCLI();
```

Можно увидеть, что нашим ключам присваивается значение, если мы его передали следующим аргументом

![](_png/Pasted%20image%2020221124160849.png)

## 036 Вывод в консоль

Дальше мы создадим сервис, который будет реализовывать различные выводы в консоль

Для того, чтобы покрасить текст в разные цвета, нужно будет воспользоваться модулем `chalk`, в котором есть красивые раскраски нашего текста в консоли

`services > log.service.js`
```JS
import chalk from "chalk";
import dedent from "dedent-js";

// выводим ошибку
const printError = (error) => {
	console.log(`${chalk.bgRed(" ERROR")} ${error}`);
};

// выводим оповещение об успешном запросе
const printSuccess = (success) => {
	console.log(`${chalk.bgGreen(" Success")} ${success}`);
};

// выводим помощь нашему пользователю
const printHelp = () => {
	console.log(
		dedent`
			${chalk.bgCyan(" HELP ")}
			Без параметров - вывод погоды
			-s [CITY] для установки города
			-t [API_KEY] для установки токена
			-h для показа помощи 
		`
	);
};

export { printError, printSuccess, printHelp };
```

Тут мы будем вызывать сами наши функции для вывода информации

`weather.js`
```JS
#!/usr/bin/env node
import { getArgs } from "./helpers/args.js";
import { printHelp, printError, printSuccess } from "./services/log.service.js";

const initCLI = () => {
	const args = getArgs(process.argv);

	if (args.h) {
		printHelp();
	}

	if (args.s) {
		// сохранить город
	}

	if (args.t) {
		// сохранить токен
	}

	// Вывести погоду
};

initCLI();
```

И тут можно встретиться с такой проблемой, что у нас текст перенимает те же отступы, что и в коде. Их можно исправить, убрав отступы в коде, но можно их убрать через отдельный модуль `dedent-js`

![](_png/Pasted%20image%2020221124180623.png)
![](_png/Pasted%20image%2020221124180738.png)

Отдельно хочется рассказать про краткую запись передачи строки внутрь функции. Конкретно тут мы не оборачивали строку в `()`. Тут достаточно просто написать функцию и сразу после в кавычках строку, чтобы передать значение внутрь неё: 

```JS
dedent`строка`
```

```JS
console.log(
		dedent`
			${chalk.bgCyan(" HELP ")}
			Без параметров - вывод погоды
			-s [CITY] для установки города
			-t [API_KEY] для установки токена
			-h для показа помощи 
		`
	);
```

![](_png/Pasted%20image%2020221124182841.png)


## 037 OS и path

Далее мы можем подготовиться к реализации функциональности записи данных в отдельное хранилище, которое будет находиться в домашней директории ПК

`weather.js`
```JS
#!/usr/bin/env node
import { getArgs } from "./helpers/args.js";
import { printHelp, printError, printSuccess } from "./services/log.service.js";
import { saveKeyValue } from "./services/storage.service.js";

const initCLI = () => {
	const args = getArgs(process.argv);

	if (args.h) {
		printHelp();
	}

	if (args.s) {
		// сохранить город
	}

	if (args.t) {
		saveKeyValue("token", args.t);
	}

	// Вывести погоду
};

initCLI();
```

Тут мы получаем доступ к домашней директории нашей операционной системы

`services > storage.service.js`
```JS
// os - это библиотека для работы с операционной системой
// homedir - выведет домашнюю директорию (учитывая ОС)
import { homedir } from "os";
// path - это библиотека для работы с путями
// join - позволяет из нескольких аргументов строить ПРАВИЛЬНЫЙ путь
import { join } from "path";

const filePath = join(homedir(), "weather-data.json");

const saveKeyValue = (key, value) => {
};

export { saveKeyValue };
```

Библиотека `path`:
- `join()` -  
- `basename()` - выведет вложение последней папки
- `dirname()` - покажет, где находится указанный в строке путь
- `extname()` - получаем расширение файла
- `relative()` - показывает путь относительно двух элементов (что нужно сделать, чтобы прийти от первого элемента ко второму)
- `isAbsolute()` - проверяет, абсолютный ли путь
- `resolve()` - покажет путь, который будет, если выполнить определённые шаги (отходит относительно текущей папки)
- `sep` - покажет, какой сепаратор используется в нашей операционной системе (`/` или `\`)

![](_png/Pasted%20image%2020221124190925.png)
![](_png/Pasted%20image%2020221124190836.png)

## 038 Работа с файловой системой

Дополним наш сервис по сохранению данных. Конкретно тут нужно было реализовать:
- создание файла, 
- проверку его существования, 
- сохранения его данных в память, если файл существует, чтобы в будущем переписать его значения

Нужно отметить, что тут мы не пользовались библиотекой `writeFile` или `writeFileSync`. Вместо них мы использовали `promises`, который предоставляет тот же стандартный функционал, но в виде промисов. 

`services > storage.service.js`
```JS
// os - это библиотека для работы с операционной системой
// homedir - выведет домашнюю директорию (учитывая ОС)
import { homedir } from "os";
// path - это библиотека для работы с путями
// join - позволяет из нескольких аргументов строить ПРАВИЛЬНЫЙ путь
import { join } from "path";
// fs - это модуль по работе с файловой системой нашего ПК
import { promises } from "fs";

// создаём путь до нашего файла, в который мы будем сохранять данные
const filePath = join(homedir(), "weather-data.json");

// это функция сохранения наших данных в отдельном файле
const saveKeyValue = async (key, value) => {
	// это наши данные из файла, поэтому они должны быть изменяемыми (let)
	let data = {};

	// если файл по данному пути существует, то мы можем сохранить его данные в ОЗУ
	if (await isExist(filePath)) {
		const file = await promises.readFile(filePath);
		data = JSON.parse(file);
	}

	// Далее занести новые данные в data
	data[key] = value;

	// и теперь мы можем перезаписать наш файл
	await promises.writeFile(filePath, JSON.stringify(data));
};

// далее мы получаем ключ нашего значения
const getKeyValue = async (key) => {
	if (await isExist(filePath)) {
		const file = await promises.readFile(filePath);
		const data = JSON.parse(file);
		// вернёт ключ данных, если они существуют
		return data[key];
	}
	// и ничего не вернёт, если проверка не прошла
	return undefined;
};

// Эта функция проверит, существует ли данный файл
const isExist = async (path) => {
	try {
		// stat возвращает статистику по файлу, но если файла нет, то он падает
		await promises.stat(path);
		// да, так как он смог вернуть статистику
		return true;
	} catch (e) {
		// и нет, так как статистику не вернул и функция упала
		return false;
	}
};

export { saveKeyValue, getKeyValue };
```

Тут же мы сделаем проверку на сохранение токена и так же оповестим пользователя о статусе операции

`weather.js`
```JS
#!/usr/bin/env node
import { getArgs } from "./helpers/args.js";
import { printHelp, printError, printSuccess } from "./services/log.service.js";
import { saveKeyValue } from "./services/storage.service.js";

const saveToken = async (token) => {
	try {
		await saveKeyValue("token", token);
		printSuccess("Токен сохранён");
	} catch (e) {
		printError("Токен не удалось сохранить :( " + e.message);
	}
};

const initCLI = () => {
	const args = getArgs(process.argv);

	if (args.h) {
		printHelp();
	}

	if (args.s) {
		// сохранить город
	}

	if (args.t) {
		return saveToken(args.t);
	}

	// Вывести погоду
};

initCLI();
```

Как итог, мы имеем сгенерированный нами файл с токеном

![](_png/Pasted%20image%2020221124194104.png)

## 039 Взаимодействие с API





## 040 Переменные окружения





## 041 Обработка ошибок





## 042 Упражнение - Завершение приложения





## 043 Публикация пакета в NPM





## 044 Npx и npm exec















