## 092 Виды тестирования

Тесты делятся на несколько типов:
- `unit` - изолированные тесты компонентов. Пишутся в самом большом количестве, чтобы протестировать отдельные части системы. Данные тесты крайне просто и легко запустить
- `integrtation` - тесты между компонентами системы. Такие тесты проводятся для проверки взаимодействия элементов системы - например, проверить парные сервисы, которые обмениваются между друг другом данными.
- `e2e` - тесты на собранной системе. Тестируется работа сразу всего кода в определённом кружении. Обычно тестируется на продакшн-версии приложения.

![](_png/Pasted%20image%2020221211201430.png)

Так же у нас имеются фреймворки для проведения тестирования:

![](_png/Pasted%20image%2020221211202434.png)

## 093 Unit тесты

Устанавливаем `jest`

```bash
npm i -D jest @types/jest ts-jest
```

Далее создаём скрипт под запуск тестов

`package.json`
```JSON
"scripts": {
	"test": "jest"
},
```

Далее создаём конфиг под модуль юнит-тестирования

`jest.config.ts`
```TS
// импортируем отдельно тип
import type { Config } from '@jest/types';

// конфигурация юнит-тестов
const config: Config.InitialOptions = {
	// чтобы видеть детальный output
	verbose: true,
	//
	preset: 'ts-jest',
};

export default config;
```

Дальше нам нужно написать сам сценарий тестирования.

`beforeAll()` - функция выполняется перед всеми тестами
`afterAll()` - запускает определённое действие сразу после всех тестов
`beforeEach()` - функция, которая будет выполняться перед каждым тестом
`describe()` - описывает, что мы тестируем
`it()` - это отдельный тест, который передаёт по нужному каналу определённое значение

Так же у нас в приложении имеется несколько сервисов, которые нужно отдельно поднимать, чтобы запустить тестировку (например, поднимать работу призмы, чтобы она создавала базу). Мы этого делать не хотим, поэтому нужно создать `Mock` под эти сервисы, чтобы использовать их функционал при тестировании без нужды в их включении.

Далее нужно будет в контейнере прибиндиться не к модулям, а к тем константам мокам, которые мы создали. Чтобы прибиндиться к константе нужно использовать не просто `to()`, а функцию `toConstantValue()`, которая работает с константами

И теперь, например, когда что-то в коде дёрнет внутри модуля `UsersRepository` метод `create()`, то у нас сработает определённый нами `jest.fn().mockImplementationOnce()`, который уже вернёт заранее определённое нами значение

Метод `expect()` получает определённое значение и позволяет нам указать то значение, которое мы от его ожидаем

Так же самым первым импортом обязательно нужно добавлять библиотеки зависимостей приложения. Конкретно в тестовый файл нужно импортнуть `'reflect-metadata'`. 

`src > users > users.service.spec.ts`
```TS
// обязательно нужно добавить сюда рефлект
import 'reflect-metadata';

import { Container } from 'inversify';
import { IConfigService } from '../config/config.service.interface';
import { IUsersRepository } from './users.repository.interface';
import { IUserService } from './users.service.interface';
import { TYPES } from '../types';
import { UserService } from './users.service';
import { User } from './user.entity';
import { UserModel } from '@prisma/client';

// поднимаем и вызываем срабатывание конифг сервиса
const ConfigServiceMock: IConfigService = {
	get: jest.fn(),
};

// поднимаем работу репозитория по работе с призмой
const UsersRepositoryMock: IUsersRepository = {
	create: jest.fn(),
	find: jest.fn(),
};

// контейнер с зависимостями
const container = new Container();
let configService: IConfigService;
let usersRepository: IUsersRepository;
let usersService: IUserService;

// выполнится перед всеми функциями
// тут мы биндим моки сервисов
beforeAll(() => {
	container.bind<IUserService>(TYPES.UserService).to(UserService);
	// и уже сюда биндимся не к модулям, а к мокам указанным выше
	container.bind<IConfigService>(TYPES.ConfigService).toConstantValue(ConfigServiceMock);
	container.bind<IUsersRepository>(TYPES.UsersRepository).toConstantValue(UsersRepositoryMock);

	// получаем инстансы этих привязок
	configService = container.get<IConfigService>(TYPES.ConfigService);
	usersRepository = container.get<IUsersRepository>(TYPES.UsersRepository);
	usersService = container.get<IUserService>(TYPES.UserService);
});

let createdUser: UserModel | null;

// содержит описание тестирования
describe('User Service', () => {
	// отдельный тест
	it('createUser', async () => {
		// тут мы говорим, что функция get конфиг сервиса будет возвращать '1'
		configService.get = jest.fn().mockReturnValueOnce('1');

		// и теперь, когда что-то дёрнет usersRepository.create(), у нас сработает данный мок
		usersRepository.create = jest.fn().mockImplementationOnce(
			// возврат готового объекта пользователя
			(user: User): UserModel => ({
				name: user.name,
				email: user.email,
				password: user.password,
				id: 1,
			}),
		);

		// создаём нового пользователя
		createdUser = await usersService.createUser({
			name: 'Olek',
			email: 'olek@yandex.ru',
			password: 'olekkk',
		});

		// далее проверяем полученные значения
		// id пользователя должен быть = 1
		expect(createdUser?.id).toEqual(1);
		// пароль должен храниться в зашифрованном виде и не должен быть равен 1
		expect(createdUser?.password).not.toEqual('1');
	});
});
```

И отдельно про `Mock`: для того, чтобы `UserService` заработал, нужно чтобы в него вложили любой модуль, который удовлетворяет интерфейсу

![](_png/Pasted%20image%2020221212190856.png)

И этим любым модулем у нас выступает `Mock` сервис

![](_png/Pasted%20image%2020221212190900.png)

И после запуска юнит-тестирования мы получаем примерно такой результат, если всё хорошо:

![](_png/Pasted%20image%2020221212202101.png)

Дальше попробуем допустить ошибку и скажем, что мы ждём от сервера получения пароля не в зашифрованном виде. И, конечно, тут мы получим ошибку.

```TS
expect(createdUser?.password).toEqual('1');
```

![](_png/Pasted%20image%2020221212202649.png)

## 094 Упражнение - Новые unit тесты



Оригинал:
`src > users > users.service.spec.ts`
```TS
import 'reflect-metadata';
import { UserModel } from '@prisma/client';
import { Container } from 'inversify';
import { IConfigService } from '../config/config.service.interface';
import { TYPES } from '../types';
import { User } from './user.entity';
import { IUsersRepository } from './users.repository.interface';
import { UserService } from './users.service';
import { IUserService } from './users.service.interface';

const ConfigServiceMock: IConfigService = {
	get: jest.fn(),
};

const UsersRepositoryMock: IUsersRepository = {
	find: jest.fn(),
	create: jest.fn(),
};

const container = new Container();
let configService: IConfigService;
let usersRepository: IUsersRepository;
let usersService: IUserService;

beforeAll(() => {
	container.bind<IUserService>(TYPES.UserService).to(UserService);
	container.bind<IConfigService>(TYPES.ConfigService).toConstantValue(ConfigServiceMock);
	container.bind<IUsersRepository>(TYPES.UsersRepository).toConstantValue(UsersRepositoryMock);

	configService = container.get<IConfigService>(TYPES.ConfigService);
	usersRepository = container.get<IUsersRepository>(TYPES.UsersRepository);
	usersService = container.get<IUserService>(TYPES.UserService);
});

let createdUser: UserModel | null;

describe('User Service', () => {
	it('createUser', async () => {
		configService.get = jest.fn().mockReturnValueOnce('1');
		usersRepository.create = jest.fn().mockImplementationOnce(
			(user: User): UserModel => ({
				name: user.name,
				email: user.email,
				password: user.password,
				id: 1,
			}),
		);
		createdUser = await usersService.createUser({
			email: 'a@a.ru',
			name: 'Антон',
			password: '1',
		});
		expect(createdUser?.id).toEqual(1);
		expect(createdUser?.password).not.toEqual('1');
	});

	it('validateUser - success', async () => {
		usersRepository.find = jest.fn().mockReturnValueOnce(createdUser);
		const res = await usersService.validateUser({
			email: 'a@a.ru',
			password: '1',
		});
		expect(res).toBeTruthy();
	});

	it('validateUser - wrong password', async () => {
		usersRepository.find = jest.fn().mockReturnValueOnce(createdUser);
		const res = await usersService.validateUser({
			email: 'a@a.ru',
			password: '2',
		});
		expect(res).toBeFalsy();
	});

	it('validateUser - wrong user', async () => {
		usersRepository.find = jest.fn().mockReturnValueOnce(null);
		const res = await usersService.validateUser({
			email: 'a2@a.ru',
			password: '2',
		});
		expect(res).toBeFalsy();
	});
});
```






## 095 E2e тесты




`tests > users.e2e-spec.ts`
```TS
import { App } from '../src/app';
import { boot } from '../src/main';
import request from 'supertest';

let application: App;

beforeAll(async () => {
	const { app } = await boot;
	application = app;
});

describe('Users e2e', () => {
	it('Register - error', async () => {
		const res = await request(application.app)
			.post('/users/register')
			.send({ email: 'a@a.ru', password: '1' });
		expect(res.statusCode).toBe(422);
	});
});

afterAll(() => {
	application.close();
});
```



## 096 Упражнение - Дописываем e2e тесты








