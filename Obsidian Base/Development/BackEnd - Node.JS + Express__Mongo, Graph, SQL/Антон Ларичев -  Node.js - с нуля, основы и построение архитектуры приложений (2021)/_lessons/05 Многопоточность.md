## 023 Использование worker threads

Тут мы для загрузки системы написали поиск факториала массива чисел

`factorial.ts`
```TS
export default function factorial(n: number): number {
	if (n == 1 || n == 0) return 1;
	return factorial(n - 1) * n;
}
```

`app.ts`
```TS
import factorial from "./factorial";

const compute = (array: number[]): number[] => {
	const arr: number[] = [];
	for (let i: number = 0; i < 10000000; i++) {
		arr.push(i * i);
	}
	return array.map((el): number => factorial(el));
};

const main = (): void => {
	performance.mark("start");

	const result = [
		compute([23, 23, 4, 34, 45, 32, 21, 45]),
		compute([23, 23, 4, 34, 45, 32, 21, 45]),
		compute([23, 23, 4, 34, 45, 32, 21, 45]),
		compute([23, 23, 4, 34, 45, 32, 21, 45]),
		compute([23, 23, 4, 34, 45, 32, 21, 45]),
	];

	console.log(result);

	performance.mark("end");
	performance.measure("main", "start", "end");
	console.log(performance.getEntriesByName("main").pop());
};

main();
```

Как итог: мы на 2 секунды заблокировали основной поток нашего приложения и не могли получать ни реквесты от пользователей, ни какие-либо операции выполнять (те же таймауты)

![](_png/Pasted%20image%2020221123100100.png)

**Далее воспользуемся созданием воркеров**

Это всё так же сама наша функция для выполнения вычислений

`factorial.js`
```JS
module.exports = function factorial(n) {
	if (n == 1 || n == 0) return 1;
	return factorial(n - 1) * n;
};
```

Этот модуль будет отвечать за задачу, выполняемую отдельным воркером

`worker.js`
```JS
const factorial = require("./factorial");
// Далее нужно импортировать два модуля, которые позволяют работать отдельно с воркером
// parentPort - порт родителя (виртуальный), где можно обмениваться данными с родителем
// workerData - сами исходные данные воркера
const { parentPort, workerData } = require("worker_threads");

const compute = ({ array }) => {
	const arr = [];
	for (let i = 0; i < 10000000; i++) {
		arr.push(i * i);
	}
	return array.map((el) => factorial(el));
};

// ! Тут мы передадим данные родителю по порту
parentPort.postMessage(compute(workerData));
```

А уже тут мы используем промисы для ожидания ответа от нашего воркера

`app-worker.js`
```JS
// импортируем инстанс воркера
const { Worker } = require("worker_threads");

// функцию подсчёта оставим
const compute = (array) => {
	// и отсюда будем возвращать результат промиса
	return new Promise((resolve, reject) => {
		// Тут мы инстанциируем на каждый запрос по воркеру (в реальном проекте это небезопасно)
		const worker = new Worker("./worker.js", {
			// передаём сюда тип получаемых данных
			workerData: {
				array,
			},
		});

		// подписываемся на событие выполнения операции
		worker.on("message", (message) => {
			// тут мы можем узнать какой id потока был присвоен треду
			console.log(worker.threadId);
			resolve(message);
		});

		// на ошибку
		worker.on("error", (error) => {
			reject(error.message);
		});

		// и на отключение воркера
		worker.on("exit", () => {
			console.log(worker.threadId); // -1
			console.log("Завершил работу");
		});
	});
};

const main = async () => {
	try {
		performance.mark("start");

		// тут же мы можем с помощью Promise.all() подождать всю группу операций
		const result = await Promise.all([
			compute([23, 23, 4, 34, 45, 32, 21, 45]),
			compute([23, 23, 4, 34, 45, 32, 21, 45]),
			compute([23, 23, 4, 34, 45, 32, 21, 45]),
			compute([23, 23, 4, 34, 45, 32, 21, 45]),
			compute([23, 23, 4, 34, 45, 32, 21, 45]),
		]);

		console.log(result);

		performance.mark("end");
		performance.measure("main", "start", "end");
		console.log(performance.getEntriesByName("main").pop());
	} catch (err) {
		console.log(err.message);
	}
};

main();

```

И уже конкретно тут можно увидеть, что задача выполнилась почти в 3 раза быстрее, чем без разделения на потоки. Так же тут у нас будут отрабатывать вызванные таймауты и приниматься реквесты от пользователей.

![](_png/Pasted%20image%2020221123095959.png)
![](_png/Pasted%20image%2020221123100107.png)

## 024 Spawn и exec

Модуль `exec` позволяет нам работать с нашим терминалом. Первым аргументом в него мы передаём саму команду, которую мы хотели бы выполнить, например, `ls` для вывода содержимого директории или ту же команду по запуску нод-скриптов `node app.js`. Дальше уже принимает в себя функция коллбэк-функцию с ошибкой приложения, выводом консоли и ошибкой консоли.
Мы так же можем реагировать на ивенты с созданным таким образом процессом.

```JS
// этот модуль позволяет нам работать с терминалом
const { exec } = require("child_process");

// это сам инстанс процесса
const childProcess = exec("dir", (err, stdout, stderr) => {
	if (err) {
		console.error(err.message);
	}

	console.log(`stdout: ${stdout}`);
	console.log(`stderr: ${stderr}`);
});

// будет срабатывать при выходе из приложения
childProcess.on("exit", (code) => {
	console.log(`Код выхода: ${code}`);
});
```

Сам же модуль `spawn` сразу вызывает функцию в консоли и уже после мы можем обработать полученный результат из консоли по отдельным его частям

```JS
// этот модуль позволяет нам работать с терминалом
const { spawn } = require("child_process");

// это сам инстанс процесса
const childProcess = spawn("ls");

// обработка выхода
childProcess.stdout.on("data", (data) => {
	console.log(`stdout: ${data}`);
});

// обработка ошибки консоли
childProcess.stderr.on("data", (data) => {
	console.log(`stderr: ${data}`);
});

// подписываемся на выход из консоли
childProcess.on("exit", (data) => {
	console.log(`Код выхода: ${data}`);
});
```

## 025 Fork

Модуль `fork` позволяет запустить указанный файл для выполнения в отдельном потоке (это альтернативный запуск воркер-процесса)










## 026 Упражнение - Производительность потоков





