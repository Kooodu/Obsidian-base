## 068 Разбор DI и IOC

==DI - dependency injection==
==IOC - inversion of control==

Само явление внедрения зависимостей избавляет нас от потребности инстанциирования объекта внутри самого класса. Таким образом, мы можем внедрять разный функционал по заранее определённому интерфейсу.
Такой подход так же позволяет отделить программный компонент, чтобы его отдельно протестировать

![](_png/Pasted%20image%2020221127183336.png)

Совершить самое простое внедрение зависимостей можно:
1) Через конструктор
2) Либо через метод

![](_png/Pasted%20image%2020221127202735.png)

==Composition root== - это одна точка, в которой собираются все зависимости с приложения

![](_png/Pasted%20image%2020221127203034.png)

Это схема простого DI, который мы можем повторить в любом языке

![](_png/Pasted%20image%2020221127203215.png)

А это схема с типизируемыми языками, в которой можно определить конкретный интерфейс той зависимости, которую мы будем внедрять
Интерфейс выступает в данном случае неким контрактом, который определяет то, что должно присутствовать в классе

![](_png/Pasted%20image%2020221127203246.png)

И вот тут можно увидеть пример, что наш интерфейс представляет из себя контракт того, что должно присутствовать в классе

`logger.interface.ts`
```TS
import { Logger } from "tslog";

export interface ILogger {
	logger: unknown;

	log: (...args: unknown[]) => void;
	error: (...args: unknown[]) => void;
	warn: (...args: unknown[]) => void;
}
```

А тут мы по контракту реализуем методы, которые должны будут присутствовать в классе обязательно

`logger.service.ts`
```TS
import { Logger } from "tslog";
import { ILogger } from "./logger.interface";

export class LoggerService implements ILogger {
	public logger: Logger<string>;

	constructor() {
		this.logger = new Logger();
	}

	log(...args: unknown[]) {
		this.logger.info(...args);
	}

	error(...args: unknown[]) {
		this.logger.error(...args);
	}

	warn(...args: unknown[]) {
		this.logger.warn(...args);
	}
}
```

И теперь в главном классе можно поменять входной инстанс не на сам класс логгера, а на интерфейс, которому должен удовлетворять передаваемый внутрь `app` логгер

`app.ts`
```TS
export class App {
	private app: Express;
	private server: Server;
	private port: number;
	// принимает в себя логгер по интерфейсу
	private logger: ILogger;
	private userController: UserController;
	private exceptionFilter: ExceptionFilter;

	constructor(
		// принимает в себя логгер по интерфейсу
		logger: ILogger,
		userController: UserController,
		exceptionFilter: ExceptionFilter
	) {
		this.app = express();
		this.port = 8000;
		this.logger = logger;
		this.userController = userController;
		this.exceptionFilter = exceptionFilter;
	}
	
	// код...
}
```

Первый принцип говорит о том, что все наши компоненты должны быть максимально изолированны друг от друга. Связываем все компоненты через абстракции и интерфейсы, которые предоставляют определённый контракт на функциональность, которая должна присутствовать в другом компоненте:
*Мы создали в классе приложения переменную, которая принимает в себя интерфейс логгера, в котором должны присутствовать методы: `log`, `error` и `warn` - сам логгер мы не принимаем, но в нём должны быть методы, которые мы описали в интерфейсе.*

Второй принцип говорит нам о том, что нам нельзя прокидывать в более мелкие модули (те же сервисы) модули более высокого уровня:
*Нам нельзя прокидывать инстанс `app` внутрь того же `exception`, `logger` или `router`.*

![](_png/Pasted%20image%2020221127205032.png)

Конкретно мы имеем:
- Принципы, которым мы должны следовать
- Паттерн, по которому эти принципы можно реализовать
- И сама реализация

![](_png/Pasted%20image%2020221127205734.png)

При регистрации приложения наш класс А регистрируется в контейнере: мы понимаем, что он заинтсанциирован и что он удовлетворяет какому-либо интерфейсу
То же самое происходит с классом Б
Контейнер - это центральная точка управления, которая за нас создаёт наши классы, при этом он понимает, какие зависимости ему нужны, создаёт эти зависимости и передаёт их внутрь. 
Таким образом мы избавляемся от самостоятельного создания ==Agregation Root== - теперь он создаётся автоматически и его реализация от нас скрыта, что упрощает наш DI, уменьшая строчки нужного кода

![](_png/Pasted%20image%2020221127205819.png)

Так же в контейнере обычно реализуется сервис локатор, в котором мы регистрируем все наши сервисы, а потом уже можем вытащить конкретный инстанс этого сервиса, чтобы его в дальнейшем использовать
*Такой паттерн не стоит использовать в реальной работе - это просто схожесть с контейнером, который будет использоваться в данной системе - в нашем случае это полезно для тестов и запуска самого приложения*

![](_png/Pasted%20image%2020221127210210.png)




## 069 Декораторы







## 070 Metadata Reflection







## 071 Внедряем InversifyJS







## 072 Упражнение - Улучшаем DI






