
## 001 Регистрация пользователя

Установим библиотеку для работы с шифрованием паролей (чтобы не хранить в базе пароли в открытом виде)

```bash
npm i bcryptjs
npm i -D @types/bcryptjs
```

Заменим имя модели на `UserModel` вместо `AuthModel`, чтобы точнее указать, что мы тут работаем с моделью пользователя

`src > auth > user.model.ts`
```TS
import { prop } from '@typegoose/typegoose';
import { Base, TimeStamps } from '@typegoose/typegoose/lib/defaultClasses';

export interface UserModel extends Base {}

export class UserModel extends TimeStamps {
	@prop({
		unique: true,
	})
	email: string;

	@prop()
	passwordHash: string;
}
```

Заменим `UserModel` на `AuthModel` в зависимостях модуля

`src > auth > auth.module.ts`
```TS
import { Module } from '@nestjs/common';
import { AuthController } from './auth.controller';
import { TypegooseModule } from 'nestjs-typegoose';
import { UserModel } from './user.model';
import { AuthService } from './auth.service';

@Module({
	controllers: [AuthController],
	imports: [
		TypegooseModule.forFeature([
			{
				typegooseClass: UserModel,
				schemaOptions: {
					collection: 'User',
				},
			},
		]),
	],
	providers: [AuthService],
})
export class AuthModule {}
```

Далее нужно провалидировать ДТОшку того объекта для регистрации и аутентификации, который приходит к нам с клиента

`src > auth > dto > auth.dto.ts`
```TS
import { IsString } from 'class-validator';

export class AuthDto {
	@IsString()
	login: string;

	@IsString()
	password: string;
}
```

Далее реализуем логику сервиса:
- Инжектим модель `UserModel` 
- добавляем методы `createUser` для создания нового пользователя (в `return` возвращается созданный пользователь + вызывается функция для сохранения его в базе через функцию `save()`) и `findUser` для поиска уже существующего пользователя в базе

`src > auth > auth.service.ts`
```TS
import { Injectable } from '@nestjs/common';
import { AuthDto } from './dto/auth.dto';
import { InjectModel } from 'nestjs-typegoose';
import { UserModel } from './user.model';
import { ModelType } from '@typegoose/typegoose/lib/types';
import { genSaltSync, hashSync } from 'bcryptjs';

@Injectable()
export class AuthService {
	constructor(@InjectModel(UserModel) private readonly userModel: ModelType<UserModel>) {}

	async createUser(dto: AuthDto) {
		// генерируем соль в 10 круток
		const salt = genSaltSync(10);

		// создаём нового пользователя
		const newUser = new this.userModel({
			email: dto.login,
			passwordHash: hashSync(dto.password, salt), // хеширование пароля
		});

		// возвращаем пользователя и сохраняем его в базу
		return newUser.save();
	}

	async findUser(email: string) {
		return this.userModel.findOne({ email }).exec();
	}
}
```

Далее уже опишем контроллер:
- Сюда мы вставляем зависимость от сервиса `AuthService`
- Далее реализуем метод `register`, который будет сначала искать старого пользователя, если он его найдёт, то вернёт ошибку неверного запроса, а если не найдёт, то отправит запрос в сервис на создание пользователя
- сам метод регистрации оборачиваем в декоратор `@UsePipes(new ValidationPipe())`, чтобы работала валидация по ДТОшке (в ней работает `class-validator`)

`src > auth > auth.controller.ts`
```TS
import {
	BadRequestException,
	Controller,
	HttpException,
	Post,
	UsePipes,
	ValidationPipe,
} from '@nestjs/common';
import { Body, HttpCode } from '@nestjs/common/decorators';
import { AuthDto } from './dto/auth.dto';
import { AuthService } from './auth.service';
import { ALREADY_REGISTERED_ERROR } from './auth.constants';

@Controller('auth')
export class AuthController {
	constructor(private readonly authService: AuthService) {}

	@UsePipes(new ValidationPipe())
	@Post('register')
	async register(@Body() dto: AuthDto) {
		const oldUser = await this.authService.findUser(dto.login);

		if (oldUser) {
			throw new BadRequestException(ALREADY_REGISTERED_ERROR);
		}

		return this.authService.createUser(dto);
	}

	@HttpCode(200)
	@Post('login')
	async login(@Body() dto: AuthDto) {}
}
```

Тут мы сохраним строковую константу с ошибкой

`src > auth > auth.constants.ts`
```TS
export const ALREADY_REGISTERED_ERROR = 'Данный пользователь уже существует';
```

При первом запросе на регистрацию мы получим полные данные по пользователю

![](_png/Pasted%20image%2020230403141750.png)

При повторной попытке на те же данные мы получим ошибку

![](_png/Pasted%20image%2020230403141800.png)

## 002 Как работает JWT

Основные причины появления JWT:
- Приход SPA, которые не использовали куки
- Потребность разделять авторизацию и сервер, который имеет приватные роуты

Схема работы с JWT:
- Клиент делает запрос к серверу авторизации и передаёт в него данные авторизации
- Далее сервис логина выпускает клиенту JWT-токен. Сервис подписывает JWT некоторым секретом, который знает только сервер
- Далее, когда пользователь обращается к приватным роутам, guard на бэке проверяет, что у клиента используется валидный JWT-токен

![](_png/Pasted%20image%2020230403153016.png)

Токен разбит на 3 части:
- `HEADER` - хранит в себе тип (`typ`) и алгоритм(`alg`) шифрования.
- `PAYLOAD` - сами передаваемые данные на сервер (почту, пароль, `iat` - время создания токена).
- `SIGNATURE` - подпись, по которой идёт проверка. Так же она хранит секрет, по которому будет происходить дешифровка данных на сервере.

![](_png/Pasted%20image%2020230403153831.png)

На сайте [JWT](https://jwt.io/) можно посмотреть пример работы JWT-токена

![](_png/Pasted%20image%2020221210200618.png)

Если мы злоумышленник и хотим что-то изменить в передаваемых данных, то у нас это не получится, так как изменение данных не работает без перекодировки от секрета

![](_png/Pasted%20image%2020230403154256.png)

## 003 Авторизация и генерация JWT











## 004 JWT стратегия и Guard











## 005 Декоратор для получения пользователя











## 006 Тесты с авторизацией











## 007 Упражнение 3 - Тесты логина











