
## 001 Обзор структуры проекта

Конфиг для тайпскрипта

`tsconfig.json`
```JSON
{
  "compilerOptions": {
    "strict": true,           /* активирует строгий режим */
    "strictNullChecks": true, /* если значение может быть null, то это нужно явно указать */
    "noImplicitAny": true,    /* обязательно нужно везде указывать типы */
    "strictPropertyInitialization": false,  /* разрешит использовать классы как интерфейсы*/
    "skipLibCheck": true,                   /* позволяет игнорировать проверку библиотек */
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "es2017",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false
  }
}
```

Тут используется TSLint вместо ESLint. Конфиг для тслинта:

`tslint.json`
```JSON
{
	"rules": {
		"no-var-requires": true,
		"no-any": true,
		"promise-function-async": true,
		"await-promise": true,
		"curly": true,
		"prefer-for-dcof": true,
		"forin": true,
		"no-console": [true, "log", "error"],
		"no-debugger": true,
		"no-duplicate-super": true,
		"no-duplicate-switch-case": true,
		"no-invalid-template-strings": true,
		"no-misused-new": true,
		"no-return-await": true,
		"no-shadowed-variable": true,
		"no-switch-case-fall-through": true,
		"no-tautology-expression": true,
		"no-unused-variable": true,
		"no-var-keyword": true,
		"static-this": true,
		"switch-default": true,
		"triple-equals": false,
		"no-require-imports": false,
		"prefer-const": true,
		"arrow-return-shorthand": true,
		"class-name": true,
		"file-name-casing": [true, "kebab-case"],
		"interface-name": [true, "always-prefix"],
		"prefer-switch": [true, { "min-cases": 3 }],
		"switch-final-break": true,
		"import-spacing": true,
		"max-line-length": [true, 120],
		"no-trailing-whitespace": false,
		"quotemark": [true, "single"],
		"semicolon": [true, "always"],
		"trailing-comma": false,
		"indent": [true, "tabs", 4],
		"linterOptions": {
			"exclude": ["./src/**/*.d.ts"]
		}
	}
}
```

Конфиг преттиера:

`.prettierc`
```JSON
{
  "singleQuote": true,
  "jsxSingleQuote": true,
  "trailingComma": "all",
  "useTabs": true,
  "semi": true,
  "bracketSpacing": true,
  "printWidth": 100,
  "endOfLine": "auto",
  "tabWidth": 4
}
```

Данная команда запустит сервер

```bash
npm run start:dev
```

![](_png/Pasted%20image%2020230128171242.png)

## 002 Введение в модули

Модули - это строительные блоки, из которых состоит приложение

![](_png/Pasted%20image%2020230128171352.png)

Модуль объединяет в себе различные зависимости одной области практического применения. 
Он принимает в себя данные значения:
- `imports: []` - что импортируется в данный модуль
- `controllers: []` - контроллеры данного модуля 
- `providers: []` - сервисы для отправки запросов в этот модуль
- `exports: []` - куда модуль экспортируется

![](_png/Pasted%20image%2020230128171605.png)

Если модуль используется в нескольких других модулях, то такая практика приемлима

![](_png/Pasted%20image%2020230128171731.png)

Модули можно повторно экспортировать из других модулей

![](_png/Pasted%20image%2020230128171831.png)

Если нам нужно использовать модуль глобально, то мы можем объявить его как `@Global()`. Например, если нам нужно использовать модуль по работе с базой данных в нескольких местах.

![](_png/Pasted%20image%2020230128171915.png)

Динамический модуль - это статический метод, который возвращает модули, провайдеры, экспорты и импорты.
Метод именуется `forRoot()`, если он используется глобально или `forFeauture()`, если он используется только в определённом скоупе

![](_png/Pasted%20image%2020230128172329.png)

## 003 Деление на модули

Так выглядит наша страница в итоге:
- Мы должны иметь возможность зайти на сайт, чтобы получить возможность писать отзывы и оставлять оценки
- Мы имеем топ продуктов (курсов), с оценками о них 
- Мы имеем определённое количество отзывов, которые относятся к определённым курсам
- Боковое меню должно получать данные для заполнения с сервера

![](_png/Pasted%20image%2020230128172902.png)

По итогу мы имеем:
- Модуль авторизации
- Модуль продукта
- Модуль отзыва
- Модуль страницы (пункты меню и так далее)
- Модуль приложения, который объединяет все представленные модули

![](_png/Pasted%20image%2020230128172928.png)

Для генерации модулей можно воспользоваться встроенным ==CLI== неста

```bash
nest g module auth && 
nest g module product && 
nest g module review &&
nest g module top-page
```

По итогу нест нам сам сгенерирует нужные модули, сделает для них папки и сам обновит импорты в `AppModule`

![](_png/Pasted%20image%2020230128174731.png)

## 004 Создание моделей

В качестве моделей будут использоваться классы

```bash
nest g class product/product.model --no-spec &&
nest g class auth/auth.model --no-spec &&
nest g class review/review.model --no-spec &&
nest g class top-page/top-page.model --no-spec
```

В моделях нам нужно описать все те базовые значения, которые в себе будут хранить определённые сущности. Здесь главное описать базовую модель, которую в будущем можно будет дополнять.

Первым делом опишем продукты, которые в себе будут содержать: изображение, заголовок, цену (которая может иметь скидку и для этого мы можем указать цену без скидки, а так же стоимость в кредит), рейтинг курса, описание курса, преймущества, недостатки, котегории (под которое попадает курс), теги и характеристики курса (сложность, длительность и так далее).  

`src / product / product.model.ts`
```TS
export class ProductModel {
  	_id: string;
	image: string;
	title: string;
	price: number;
	oldPrice: number;
	credit: number;
	calculatedRating: number;
	description: string;
	advantages: string;
	disAdvantages: string;
	categories: string[];
	tags: string;
	characteristics: {
		[key: string]: string;
	};
}
```

![](_png/Pasted%20image%2020230202083124.png)

Аутентификация пригодится только для администрации (отзывы может оставлять любой пользователь сайта). Для входа будет нужна только почта и пароль. 

`src / auth / auth.model.ts`
```TS
export class AuthModel {
	email: string;
	passwordHash: string;
}
```

Модель комментария. Как описывалось выше - комментарий может оставить любой пользователь.

`src / review / review.model.ts`
```TS
export class ReviewModel {
	_id: string;
	name: string;
	title: string;
	description: string;
	rating: number;
	createdAt: Date;
}
```

![](_png/Pasted%20image%2020230202083239.png)

И далее будет представлена модель страницы. Она будет:
- Подстраиваться под выбранную категорию товара
- Подстраиваться под выбранную подкатегорию
- Будет иметь свой заголовок
- Будет иметь выбранную категорию
- Иметь возможность получать доступ к данным `hh.ru` и возвращать от него нужные данные
- Иметь сео-текст
- Иметь теги

`src / top-page / top-page.model.ts`
```TS
export enum TopLevelCategory {
	Courses,
	Services,
	Books,
	Products
}

export class TopPageModel {
	_id: string;
	// категория, на которой мы сейчас располагаемся
	firstCategory: TopPageModel;
	secondCategory: string;
	title: string;
	category: string;
	// Этот блок будет появляться только для курсов
	hh?: {
		count: number; // количество вакансий
		juniorSalary: number;
		middleSalary: number;
		seniorSalary: number;
	};
	advantages: {title: string; description: string}[];
	seoText: string;
	tagsTitle: string;
	tags: string[];
}
```

![](_png/Pasted%20image%2020230202083154.png)

И примерно так выглядят логи:

![](_png/Pasted%20image%2020230202102201.png)

## 005 Введение в контроллеры

Контроллер - это входная точка в приложение, куда приходят запросы

![](_png/Pasted%20image%2020230202084400.png)

Через метод `setGlobalPrfix` мы можем установить, по какому порту мы сможем получить доступ к приложению на сервере. 
При использовании декоратора `@Controllet('название_роута')` мы сможем обращаться к методам, к которым имеет доступ контроллер.
Далее через декораторы `@Get()`, `@Post()` и так далее мы можем указать вызываемые методы, которые осуществляют запросы по определённым роутам. Конкретно `'add/:id'` позволяет нам определить тот роут в контроллере, по которому мы выполняем метод. `:id` - это некоторый строковый параметр, по которому мы будем определять, что нам нужно. Всё то, что вернёт данный метод - это то, что уйдёт нашему клиенту.

![](_png/Pasted%20image%2020230202084445.png)

Основные декораторы аргументов - это `@Req()` и `@Res()`. Всё, что находится ниже черты - это дополнительные декораторы, которые входят в первые два основных.
- `@Params()` - позволяет вытащить параметр из запроса (тот же `id`, что представлен выше)
- `@Body()` - если мы делаем пост-запрос или близкие к нему, то мы можем передать `body` в виде JSONи мы получим тело запроса (или один из ключей)
- `@Query()` - если у нас есть `query`-параметры в строке запроса
- `@Headers()` - выдаёт заголовки (всё, что связано с авторизацией, контент-тайпом и т.д.)
- `@Session()` - возвращает сессиюпользователя

![](_png/Pasted%20image%2020230202085214.png)

И тут показан пример того, что мы получим при переданной ссылке:
- `@Params` вернёт нам `1`
- `@Query` вернёт нам всё то, что идёт после `?`
- `@Body` - вернёт нам тело запроса на АПИ
- `@Headers` - вернёт нам тот же `Bearer` токена

![](_png/Pasted%20image%2020230202085444.png)

Так же дополнительные возможности контроллеров:
- Мы можем знаком `*` обозначить, что тут может быть любой символ `_, - и так далее`
- Так же мы можем прописать кастомный HTTP код, который вернётся пользователю
- Мы можем вставить кастомный хедер ответа
- Так же мы можем перенаправить запрос пользователя на другое место (если у нас не MVC приложение, то тот же реакт может выдать ошибку и отказаться перенаправить на другую страницу)
- Так же мы можем очень большое АПИ разграничить по поддоменам
- Вернуть промис или вернуть отслеживаемый объект (то есть нест сам разрезолвит данные методы или получит первое значение из observable и вернёт как ответ)

![](_png/Pasted%20image%2020230202090102.png)
![](_png/Pasted%20image%2020230202090616.png)

- Так же мы можем вернуть ответ объектом Response (однако нам обязательно нужно его импортировать из модуля `express`)

![](_png/Pasted%20image%2020230202090858.png)

## 006 Создание контроллеров

Все контроллеры, которые мы создадим создадут файл самого контроллера и файл `.module`, в котором будут описаны связи контроллеров и определённого модуля.
Нам нужно сгенерировать контроллеры под все созданные модули.

```bash
nest g controller auth &&
nest g controller product &&
nest g controller review &&
nest g controller top-page
```

![](_png/Pasted%20image%2020230202102335.png)

Такой код будет сгенерирован автоматически с помощью CLI неста (при использовании команд создания контроллеров) для всех модулей

`top-page.module.ts`
```TS
import { Module } from '@nestjs/common';
import { TopPageController } from './top-page.controller';

@Module({
  controllers: [TopPageController]
})
export class TopPageModule {}
```

Первым делом определим префикс, которая предоставит доступ к АПИ

`src / main.ts`
```TS
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
	const app = await NestFactory.create(AppModule);

	// Устанавливаем глобальный префикс для доступа к АПИ
	app.setGlobalPrefix('api');

	await app.listen(3000);
}
bootstrap();
```

Контроллер аутентификации должен уметь принимать данные на регистрацию и на логин пользователя в системе.

`src / auth / auth.controller.ts`
```TS
import { Body, Controller, HttpCode, Post } from '@nestjs/common';
import { AuthDto } from './dto/auth.dto';

@Controller('auth')
export class AuthController {
	@Post('register')
	async register(@Body() dto: AuthDto) {}

	@HttpCode(200)
	@Post('register')
	async login(@Body() dto: AuthDto) {}
}
```

Далее опишем модель данных, которую принимает в себя контроллер аутентификации. Описывать модель будем с помощью классов.
==DTO== (*Data Transfer Object*) - это модель, при которой класс описывает тело (`body`) запроса.

`src / auth / dto / auth.dto.ts`
```TS
export class AuthDto {
	login: string;

	// тут мы принимаем не хеш пароля, а сам пароль от пользователя
	password: string;
}
```

Далее мы реализуем контроллер для продукта, который сможет принимать посты, удалять их, искать, отдавать найденные и обновлять.

Данная утилита типа `Omit<ProductModel, '_id'>` позволит нам получить все данные по модели продукта исключая поле `_id`, которое нам не требуется на данный момент.

`src / product / product.controller.ts`
```TS
import { Body, Controller, Delete, Get, HttpCode, Param, Patch, Post } from '@nestjs/common';
import { ProductModel } from './product.model';
import { FindProductDto } from './dto/find-product.dto';

@Controller('product')
export class ProductController {
	// метод получения продукта на сервере и создания
	@Post('create')
	async create(@Body() dto: Omit<ProductModel, '_id'>) {}

	// метод отправки продукта клиенту
	@Get(':id')
	async get(@Param('id') id: string) {}

	// метод удаления продукта
	@Delete(':id')
	async delete(@Param('id') id: string) {}

	// метод обновления продукта
	@Patch(':id')
	async patch(@Param('id') id: string, @Body() dto: ProductModel) {}

	// метод поиска продуктов
	@HttpCode(200)
	@Post()
	async find(@Body() dto: FindProductDto) {}
}
```

Так же реализуем DTO, которая будет определять лимит выведенных продуктов для пользователя, который их ищет и категорию поиска.

`src / product / dto / fint-product.dto.ts`
```TS
export class FindProductDto {
	category: number;
	limit: number;
}
```

Контроллер обзора имеет в себе методы для отправки обзора на сервер, удаление поста и получение обзора.

`src / review / review.controller.ts`
```TS
import { Body, Controller, Delete, Get, Param, Post } from '@nestjs/common';
import { ReviewModel } from './review.model';

@Controller('review')
export class ReviewController {
	// метод получения обзора сервером
	@Post('create')
	async create(@Body() dto: Omit<ReviewModel, '_id'>) {}

	// метод удаления обзора
	@Delete(':id')
	async delete(@Param('id') id: string) {}

	// получение обзора по продукту
	@Get('byProduct:productId')
	async getByProduct(@Param('productId') productId: string) {}
}
```

Далее идёт контроллер главной страницы, которая позволяет делать почти всё то же самое, что и контроллер продукта.

`src / top-page / dto / top-page.controller.ts`
```TS
import { Body, Controller, Delete, Get, HttpCode, Param, Patch, Post } from '@nestjs/common';
import { TopPageModel } from './top-page.model';
import { FindTopPageDto } from './dto/find-top-page.dto';

@Controller('top-page')
export class TopPageController {
	@Post('create')
	async create(@Body() dto: Omit<TopPageModel, '_id'>) {}

	@Get(':id')
	async get(@Param('id') id: string) {}

	@Delete(':id')
	async delete(@Param('id') id: string) {}

	@Patch(':id')
	async patch(@Param('id') id: string, @Body() dto: TopPageModel) {}

	@HttpCode(200)
	@Post()
	async find(@Body() dto: FindTopPageDto) {}
}
```

Модель DTO позволяет нам определить какие данные нам нужны для вывода определённой страницы по нужной нам категории. 

`src / top-page / dto / find-top-page.ts`
```TS
import { TopLevelCategory } from '../top-page.model';

export class FindTopPageDto {
	firstCategory: TopLevelCategory;
}
```

Так выглядит структура проекта в итоге:

![](_png/Pasted%20image%2020230202103909.png)

## 007 Введение в провайдеры

Провайдер - это класс, значение, фабрика, которая позволяет использовать модель неста по внедрению зависимостей и встраиваться друг в друга (в контроллеры, сервисы) и выполнять те или иные функции (чтение из БД, запросы к другим сервисам и так далее) 

![](_png/Pasted%20image%2020230202105334.png)

`@Injectable()` позволяет указать, что данный класс используется в качестве провайдера и находится в дереве зависимостей.

![](_png/Pasted%20image%2020230202105813.png)

Чтобы использовать, указанный выше провайдер, нужно просто вставить его в зависимости модуля и вставить в контроллер в качестве зависимости. 
Чтобы использовать провайдер в другом модуле, нужно его экспортировать.

Сразу нужно сказать, что если мы используем `forwardRef` в зависимостях (обе зависимости ссылаются друг на друга - циклические зависимости), то архитектура приложения построена не оптимально и такой подход очень плох.

![](_png/Pasted%20image%2020230203152810.png)



![](_png/Pasted%20image%2020230203153157.png)









