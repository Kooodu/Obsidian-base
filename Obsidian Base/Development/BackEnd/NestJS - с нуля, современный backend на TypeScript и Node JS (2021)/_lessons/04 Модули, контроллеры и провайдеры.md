
## 001 Обзор структуры проекта

Конфиг для тайпскрипта

`tsconfig.json`
```JSON
{
  "compilerOptions": {
    "strict": true,           /* активирует строгий режим */
    "strictNullChecks": true, /* если значение может быть null, то это нужно явно указать */
    "noImplicitAny": true,    /* обязательно нужно везде указывать типы */
    "strictPropertyInitialization": false,  /* разрешит использовать классы как интерфейсы*/
    "skipLibCheck": true,                   /* позволяет игнорировать проверку библиотек */
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "es2017",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false
  }
}
```

Тут используется TSLint вместо ESLint. Конфиг для тслинта:

`tslint.json`
```JSON
{
	"rules": {
		"no-var-requires": true,
		"no-any": true,
		"promise-function-async": true,
		"await-promise": true,
		"curly": true,
		"prefer-for-dcof": true,
		"forin": true,
		"no-console": [true, "log", "error"],
		"no-debugger": true,
		"no-duplicate-super": true,
		"no-duplicate-switch-case": true,
		"no-invalid-template-strings": true,
		"no-misused-new": true,
		"no-return-await": true,
		"no-shadowed-variable": true,
		"no-switch-case-fall-through": true,
		"no-tautology-expression": true,
		"no-unused-variable": true,
		"no-var-keyword": true,
		"static-this": true,
		"switch-default": true,
		"triple-equals": false,
		"no-require-imports": false,
		"prefer-const": true,
		"arrow-return-shorthand": true,
		"class-name": true,
		"file-name-casing": [true, "kebab-case"],
		"interface-name": [true, "always-prefix"],
		"prefer-switch": [true, { "min-cases": 3 }],
		"switch-final-break": true,
		"import-spacing": true,
		"max-line-length": [true, 120],
		"no-trailing-whitespace": false,
		"quotemark": [true, "single"],
		"semicolon": [true, "always"],
		"trailing-comma": false,
		"indent": [true, "tabs", 4],
		"linterOptions": {
			"exclude": ["./src/**/*.d.ts"]
		}
	}
}
```

Конфиг преттиера:

`.prettierc`
```JSON
{
  "singleQuote": true,
  "jsxSingleQuote": true,
  "trailingComma": "all",
  "useTabs": true,
  "semi": true,
  "bracketSpacing": true,
  "printWidth": 100,
  "endOfLine": "auto",
  "tabWidth": 4
}
```

Данная команда запустит сервер

```bash
npm run start:dev
```

![](_png/Pasted%20image%2020230128171242.png)

## 002 Введение в модули

Модули - это строительные блоки, из которых состоит приложение

![](_png/Pasted%20image%2020230128171352.png)

Модуль объединяет в себе различные зависимости одной области практического применения. 
Он принимает в себя данные значения:
- `imports: []` - что импортируется в данный модуль
- `controllers: []` - контроллеры данного модуля 
- `providers: []` - сервисы для отправки запросов в этот модуль
- `exports: []` - куда модуль экспортируется

![](_png/Pasted%20image%2020230128171605.png)

Если модуль используется в нескольких других модулях, то такая практика приемлима

![](_png/Pasted%20image%2020230128171731.png)

Модули можно повторно экспортировать из других модулей

![](_png/Pasted%20image%2020230128171831.png)

Если нам нужно использовать модуль глобально, то мы можем объявить его как `@Global()`. Например, если нам нужно использовать модуль по работе с базой данных в нескольких местах.

![](_png/Pasted%20image%2020230128171915.png)

Динамический модуль - это статический метод, который возвращает модули, провайдеры, экспорты и импорты.
Метод именуется `forRoot()`, если он используется глобально или `forFeauture()`, если он используется только в определённом скоупе

![](_png/Pasted%20image%2020230128172329.png)

## 003 Деление на модули

Так выглядит наша страница в итоге:
- Мы должны иметь возможность зайти на сайт, чтобы получить возможность писать отзывы и оставлять оценки
- Мы имеем топ продуктов (курсов), с оценками о них 
- Мы имеем определённое количество отзывов, которые относятся к определённым курсам
- Боковое меню должно получать данные для заполнения с сервера

![](_png/Pasted%20image%2020230128172902.png)

По итогу мы имеем:
- Модуль авторизации
- Модуль продукта
- Модуль отзыва
- Модуль страницы (пункты меню и так далее)
- Модуль приложения, который объединяет все представленные модули

![](_png/Pasted%20image%2020230128172928.png)

Для генерации модулей можно воспользоваться встроенным ==CLI== неста

```bash
nest g module auth && 
nest g module product && 
nest g module review &&
nest g module top-page
```

По итогу нест нам сам сгенерирует нужные модули, сделает для них папки и сам обновит импорты в `AppModule`

![](_png/Pasted%20image%2020230128174731.png)

## 004 Создание моделей

В качестве моделей будут использоваться классы

```bash
nest g class product/product.model --no-spec &&
nest g class auth/auth.model --no-spec &&
nest g class review/review.model --no-spec &&
nest g class top-page/top-page.model --no-spec
```

В моделях нам нужно описать все те базовые значения, которые в себе будут хранить определённые сущности. Здесь главное описать базовую модель, которую в будущем можно будет дополнять.

Первым делом опишем продукты, которые в себе будут содержать: изображение, заголовок, цену (которая может иметь скидку и для этого мы можем указать цену без скидки, а так же стоимость в кредит), рейтинг курса, описание курса, преймущества, недостатки, котегории (под которое попадает курс), теги и характеристики курса (сложность, длительность и так далее).  

`src / product / product.model.ts`
```TS
export class ProductModel {
	image: string;
	title: string;
	price: number;
	oldPrice: number;
	credit: number;
	calculatedRating: number;
	description: string;
	advantages: string;
	disAdvantages: string;
	categories: string[];
	tags: string;
	characteristics: {
		// ключ - строка, значение - строка
		[key: string]: string;
	};
}
```

![](_png/Pasted%20image%2020230202083124.png)

Аутентификация пригодится только для администрации (отзывы может оставлять любой пользователь сайта). Для входа будет нужна только почта и пароль. 

`src / auth / auth.model.ts`
```TS
export class AuthModel {
	email: string;
	passwordHash: string;
}
```

Модель комментария. Как описывалось выше - комментарий может оставить любой пользователь.

`src / review / review.model.ts`
```TS
export class ReviewModel {
	name: string;
	title: string;
	description: string;
	rating: number;
	createdAt: Date;
}
```

![](_png/Pasted%20image%2020230202083239.png)

И далее будет представлена модель страницы. Она будет:
- Подстраиваться под выбранную категорию товара
- Подстраиваться под выбранную подкатегорию
- Будет иметь свой заголовок
- Будет иметь выбранную категорию
- Иметь возможность получать доступ к данным `hh.ru` и возвращать от него нужные данные
- Иметь сео-текст
- Иметь теги

`src / top-page / top-page.model.ts`
```TS
export enum TopLevelCategory {
	Courses,
	Services,
	Books,
	Products
}

export class TopPageModel {
	// категория, на которой мы сейчас располагаемся
	firstCategory: TopPageModel;
	secondCategory: string;
	title: string;
	category: string;
	// Этот блок будет появляться только для курсов
	hh?: {
		count: number; // количество вакансий
		juniorSalary: number;
		middleSalary: number;
		seniorSalary: number;
	};
	advantages: {title: string; description: string}[];
	seoText: string;
	tagsTitle: string;
	tags: string[];
}
```

![](_png/Pasted%20image%2020230202083154.png)

## 005 Введение в контроллеры

Контроллер - это входная точка в приложение, куда приходят запросы

![](_png/Pasted%20image%2020230202084400.png)

Через метод `setGlobalPrfix` мы можем установить, по какому порту мы сможем получить доступ к приложению на сервере. 
При использовании декоратора `@Controllet('название_роута')` мы сможем обращаться к методам, к которым имеет доступ контроллер.
Далее через декораторы `@Get()`, `@Post()` и так далее мы можем указать вызываемые методы, которые осуществляют запросы по определённым роутам. Конкретно `'add/:id'` позволяет нам определить тот роут в контроллере, по которому мы выполняем метод. `:id` - это некоторый строковый параметр, по которому мы будем определять, что нам нужно. Всё то, что вернёт данный метод - это то, что уйдёт нашему клиенту.

![](_png/Pasted%20image%2020230202084445.png)

Основные декораторы аргументов - это `@Req()` и `@Res()`. Всё, что находится ниже черты - это дополнительные декораторы, которые входят в первые два основных.
- `@Params()` - позволяет вытащить параметр из запроса (тот же `id`, что представлен выше)
- `@Body()` - если мы делаем пост-запрос или близкие к нему, то мы можем передать `body` в виде JSONи мы получим тело запроса (или один из ключей)
- `@Query()` - если у нас есть `query`-параметры в строке запроса
- `@Headers()` - выдаёт заголовки (всё, что связано с авторизацией, контент-тайпом и т.д.)
- `@Session()` - возвращает сессиюпользователя

![](_png/Pasted%20image%2020230202085214.png)

И тут показан пример того, что мы получим при переданной ссылке:
- `@Params` вернёт нам `1`
- `@Query` вернёт нам всё то, что идёт после `?`
- `@Body` - вернёт нам тело запроса на АПИ
- `@Headers` - вернёт нам тот же `Bearer` токена

![](_png/Pasted%20image%2020230202085444.png)

Так же дополнительные возможности контроллеров:
- Мы можем знаком `*` обозначить, что тут может быть любой символ `_, - и так далее`
- Так же мы можем прописать кастомный HTTP код, который вернётся пользователю
- Мы можем вставить кастомный хедер ответа
- Так же мы можем перенаправить запрос пользователя на другое место (если у нас не MVC приложение, то тот же реакт может выдать ошибку и отказаться перенаправить на другую страницу)
- Так же мы можем очень большое АПИ разграничить по поддоменам
- Вернуть промис или вернуть отслеживаемый объект (то есть нест сам разрезолвит данные методы или получит первое значение из observable и вернёт как ответ)

![](_png/Pasted%20image%2020230202090102.png)
![](_png/Pasted%20image%2020230202090616.png)

- Так же мы можем вернуть ответ объектом Response (однако нам обязательно нужно его импортировать из модуля `express`)

![](_png/Pasted%20image%2020230202090858.png)

## 006 Создание контроллеров








## 007 Введение в провайдеры








