
## 19 - Монорепозиторий или нет

Монорепозиторий - это репозиторий сразу для нескольких проектов.
Зачастую, такой подход используется, когда у нас не более 12 микросервисов

Плюсы:
- Переиспользование уже написанного кода, так как все сервисы находятся в одном месте
- Удобная работа с контрактами
- Удобно можно настроить все пайплайны и зависимости сборки проекта (больше плюс для DevOps-инжинера)

Минусы:
- Огромные объёмы проекта, что тормозит работу IDE
- Централизует все зависимости, что при переходе на новую версию того же NextJS или другого модуля создаст проблемы с обновлением
- Ограничение используемых языков

Чтобы получить все преимущества микросервисов, пользоваться монорепозиторием нельзя, но если нужно быстро билдить приложение и проще им управляться, то можно хранить все сервисы в одном репозитории.

Однако монорепозитории хорошо использовать, когда у нас мало сервисов, они написаны на одном языке и у нас много различных контрактов, чтобы использовать их между микросервисами. 

![](_png/Pasted%20image%2020230201193048.png)

Самые популярные утилиты для работы с монорепозиториями:
- NX
- Lerna
- npm (выбираем по умолчанию, если проект не имеет сложной архитектуры и имеет один фронт)
- turborepo
- rush

![](_png/Pasted%20image%2020230201195702.png)

`NX`:
- Очень легко с ним работать 
- Очень удобные инструменты, которые позволяют локально запустить сразу несколько сервисов
- Имеет свой взгляд на работу с сервисами (имеет свои определённые модули для сборки определённых фреймворков и свои правила) - ==Webpack==
- Работает сугубо на базе ==TS==

`Lerna`: 
- Позволяет работать с любым сборщиком, с которым мы хотим работать

`NX` не даст нам в монорепозитории использовать несколько разных версий того же `NextJS`. Если нам нужно поменяться на более новую версию, то тут уже нужно будет обновить весь проект. Другими словами, мы должны поддерживать единый скоуп зависимостей и поддерживать чистоту кода.

![](_png/Pasted%20image%2020230201200008.png)

## 20 - Обзор NestJS

Компоненты, которые мы имеем в несте:
- `Modules` - это строительные блоки в приложении, которые агрегируют в себе определённую логику
- `Controllers` - это обработчики внешних событий
- `Providers` - это компонент, который обеспечивает доступ приложения к внешним источникам данных (БД)
- `Middleware` - это посредник, который внедряется в процесс запроса и обогащает функциональность
- `Exception filters`
- `Pipes`
- `Guards`
- `Interceptors`

![](_png/Pasted%20image%2020230222165329.png)

Модули могут быть включены в другие модули

Модуль - это класс с декоратором модуля, который позволяет описать внутри этого декоратора все провайдеры, контроллеры, модули и другие зависимости, что он экспортирует

![](_png/Pasted%20image%2020230222165408.png)

Все точки входа в приложение - это контроллеры, которые триггерят выполнение определённых операций

Так как контроллер - это входная точка в модуль, то его переиспользование в других модулях - невозможно

Декоратор `@Controller()` помечает класс как контроллер, а так же выполняет DI-функцию 

![](_png/Pasted%20image%2020230222165747.png)

Правильный подход к работе с БД заключается в описании работы с репозиторием через класс и подключение этого класса через декоратор в категорию провайдеров

Так же благодаря тому, что мы работаем с модулями, мы можем использовать репозитории и в других модулях просто экспортируя их

Декоратор `@Injectable()` обеспечит добавление класса в категорию провайдеров

![](_png/Pasted%20image%2020230222170437.png)

Общая схема работы запроса выглядит подобным образом:
- `Middleware` - первый принимает в себя запрос и он может обрабатывать его, валидировать и так далее
- `Guards` - это ограничитель, который зачастую используется для авторизации всех запросов с клиента (проверка валидности JWT, делать проверку аутентификации и так далее). Так же в гуарде можно произвести проверку на наличие соответствующего доступа у пользователя. По сути они могут ограничивать те или иные роуты для пользователя
- `Interceptors` - внедряются до или после контроллеров, обрабатывая запросы
- `Pipes` - занимаются преобразованием запросов (например, может валидировать по декораторам то, что нам прислали)
- `Controller` - сама наша конечная точка, вокруг которой построена данная архитектура
- `Exception Filters` - обрабатывает все входящие ошибки из контроллера

![](_png/Pasted%20image%2020230222171232.png)

Так же для реализации общения приложения с БД будет использоваться паттерн репозитория. 

У неста имеется модуль `nestjs-mongoose`, который позволяет описать модели в виде классов с декораторами. Эту схему можно будет с помощью декоратора `@InjectModel` добавить в репозиторий и на выходе мы получим модель, с которой будет работать репозиторий

Паттерн же говорит нам, что для каждой такой модели должен быть свой репозиторий со своей входной точкой, с которой мы будем взаимодействовать. Мы не будем напрямую ходить в модель - мы будем ходить только в репозиторий этой модели

![](_png/Pasted%20image%2020230222172105.png)

Паттерн `Entity` говорит нам, чтобы мы использовали для общения между контроллером и репозиторием не какой-то конкретный объект по интерфейсу, а отдельную сущность в виде класса. Эта сущность будет повторять модель репозитория и будет содержать в себе определённую бизнес-логику

![](_png/Pasted%20image%2020230222172704.png)

И примерно так будет выглядеть наш микросервис по работе с аутентификацией:

![](_png/Pasted%20image%2020230222180650.png)

## 21 - Код Настраиваем nx monorepo

Первым делом нужно установить сам nx и cli неста

```bash
npm i -g nx @nestjs/cli
```

Далее нужно создать проект с микросервисами. Ему сразу можно задать пресет той технологии, что мы будем использовать.

```bash
npx create-nx-workspace microservices-proj --preset=nest
```

И далее мы получаем структуру, где у нас в корне проекта находятся:
- все глобальные файлы стилей / базовый тсконфиг (от него экстендятся все остальные конфиги) / все тесты
- папка `apps`, которая хранит все микросервисы приложения
- папка `libs`, которая хранит переиспользуемые данные для приложения 

![](_png/Pasted%20image%2020230227143443.png)

Так же имеется плагин NX console, который позволит сразу запускать все команды из `nx.json`

![](_png/Pasted%20image%2020230227143336.png)

И тут нужно сразу сказать, что при использовании nx'a мы не теряем возможность пользоваться CLI'ками других модулей (тем же нестовским cli) - всё это у нас остаётся

![](_png/Pasted%20image%2020230227143638.png)

Так выглядит запуск сёрвинга проекта:

![](_png/Pasted%20image%2020230227143820.png)

Всё, что мы можем переиспользовать должно находиться в библиотеках.

```bash
nx g @nrwl/nest:lib interfaces
```

`libs / interfaces / src / lib / user.interface.ts`
```TS
export interface IUser {  
 name: string;  
}
```

`libs / interfaces / src / index.ts`
```TS
export * from './lib/user.interface';
```

Так выглядит структура созданной библиотеки:

![](_png/Pasted%20image%2020230227145223.png)

И теперь мы можем спокойно импортировать из библиотеки любой модуль в любой микросервис нашего приложения

![](_png/Pasted%20image%2020230227145704.png)

Происходит это потому, что в нашем базовом тсконфиге добавляется автоматически строчка, которая создаёт алиасы для нашего пути

![](_png/Pasted%20image%2020230227150038.png)

И далее нам нужно создать модули, сервисы и контроллеры для отдельных частей приложения аккаунтов:

```bash
nx g module app/user --project=account
 nx g service app/user --project=account

nx g module app/auth --project=account
nx g controller app/auth --project=account
nx g service app/auth --project=account
```

![](_png/Pasted%20image%2020230227151702.png)

![](_png/Pasted%20image%2020230227151649.png)

И установим зависимости для подключения аутентификации в проект и валидации:

```bash
npm i bcryptjs jsonwebtoken passport passport-jwt @nestjs/passport @nestjs/config class-transformer class-validator
```

Все те зависимости, что мы указали выше - устанавливаются глобально для всего проекта 

![](_png/Pasted%20image%2020230227153035.png)

## 22 - Код Создаём модели







## 23 - Код Реализуем авторизацию







## 24 - Код Запускаем проект








