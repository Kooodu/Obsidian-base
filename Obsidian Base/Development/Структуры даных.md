

![](_png/Pasted%20image%2020230603092333.png)


## Что такое алгоритм? Оценка сложности

Алгоритм - это набор последовательных действий, которые решают какую-либо задачу.

Сложность алгоритма высчитывают через O(n), где n - количество действий для выполнения операции. Чем меньше действий, тем лучше.

На графе ниже представлено отображение, где от красного до фиолетового идёт последовательность от лучшего к худшему

![](_png/Pasted%20image%2020230603092800.png)

Мы ищем число 7 внутри отсортированного массива из десяти элементов. Если мы будем пользоваться линейным поиском и искать перебирая все элементы слева направо, то потратим 7 действий, а если будем искать через бинарный (двоичный) поиск, то нам потребуется всего 3 действия, так как мы два раза поделим массив пополам

Бинарный поиск имеет сложность O(log2n)

![](_png/Pasted%20image%2020230603093832.png)

Конкретно бинарный поиск в сравнении с линейным будет отрабатывать разные количество времени и искать крайне разное время

![](_png/Pasted%20image%2020230603094131.png)

Тут находится шпаргалка с описанием скоростей выполнения различных операций

![](_png/Pasted%20image%2020230603092812.png)

## Линейный поиск

Линейный поиск представляет собой перебор всех элементов массива, начиная с самого начала

Линейный алгоритм всегда имеет количество действий ==O(n)== - линейное количество

```JS
const array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
let count = 0;

function linearSearch(array, item) {
	for (let i = 0; i < array.length; i++) {
		count += 1;

		if (array[i] === item) {
			return i;
		}
	}

	return null;
}

console.log(linearSearch(array, 8));
console.log('Количество итераций = ', count); // = 8, т.е. O(n)

console.log(linearSearch(array, 10));
console.log(linearSearch(array, 324));
```

> Перебор идёт каждого элемента !
![](_png/Pasted%20image%2020230603100622.png)

## Бинарный поиск. Итеративный подход (цикл)

Бинарный поиск - это поиск внутри остортированного массива посредством выборки среднего значения из представленных 

Данный поиск представляет из себя деление всего массива на два и откидывание лишних значений. Если мы ищем 4 среди 10 элементов, то сначала выберится 5, потом, так как 5 больше 4, то откинется половина массива после 5, потом выберится 3, откинется всё до 3 и у нас останется 3 - 4- 5, где серединой останется искомое 4

Сложность у данного алгоритма ==O(log2n)== - логарифмическая сложность

```JS
const array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18];
let count = 0;

function binarySearch(array, item) {
	let start = 0; // начальная точка
	let end = array.length; // конечная точка - длина массива
	let middle; // середина списка
	let found = false; // найден ли элемент
	let position = -1; // позиция курсора для поиска

	while (found === false && start <= end) {
		count += 1;
		middle = Math.floor((start + end) / 2);

		if (array[middle] === item) {
			found = true;
			position = middle;
			return position;
		}

		if (item < array[middle]) {
			end = middle - 1;
		} else {
			start = middle + 1;
		}
	}

	return position;
}

console.log(binarySearch(array, 8));
console.log('Количество итераций = ', count); // = 4, т.е. O(log2n)
```

Способ решения через рекурсию:

```JS
function recursiveBinarySearch(array, item, start, end) {
    let middle = Math.floor((start + end) / 2);
    count += 1
    if (item === array[middle]) {
        return middle
    }
    if (item < array[middle]) {
        return recursiveBinarySearch(array, item, 0, middle - 1 )
    } else {
        return recursiveBinarySearch(array, item, middle + 1, end )
    }
}
```


## Сортировка выбором. SelectionSort

Сортировка выбором представляет из себя сортировку, при которой сначала находится самый меньший элемент и он подставляется в начало, заменяя начальный

![](_png/Pasted%20image%2020230603135949.png)

Сложность данного алгоритма равна ==O(n^2)==, так как мы имеем 1/2 от n^2 - 276 итераций на 24 элемента

```JS
const array = [5, 6, 1, 3, 2, 4, 9, 7, 8, 6, 5, 3, 10, 16, 17, 18, -2, -3, -1, -15, 24, 26, 34, 33];
let count = 0;

function selectionSort(array) {
	for (let i = 0; i < array.length; i++) {
		// индекс минимального числа
		let indexMin = i;

		// тут мы ищем индекс минимального числа
		for (let j = i + 1; j < array.length; j++) {
			if (array[j] < array[indexMin]) {
				indexMin = j;
			}
			count += 1;
		}

		// переставляем местами найденные переменные
		let tmp = array[i];
		array[i] = array[indexMin];
		array[indexMin] = tmp;
	}

	return array;
}

console.log(selectionSort(array));
console.log('Количество итераций = ', count); // = 276, т.е. O(n^2)
```

## Сортировка пузырьком. BubbleSort







## Рекурсия. Рекурсивные функции. Факториал. Числа Фибоначчи







## Быстрая сортировка. Сортировка Хоара







## Графы. Поиск в ширину







## Структура данных Очередь







## Матрица смежности







## Алгоритм Дейкстры для поиска кратчайшего пути







## Рекурсивный обход дерева n-размерности







## Итеративный обход дерева n-размерности







## Структура данных Стек







## Кеширование вычислений







## Массивы. Сложность основных операций







## Связный список. Простая реализация и теория







## Бинарное дерево поиска. Простая реализация и теория







## Set и Map












