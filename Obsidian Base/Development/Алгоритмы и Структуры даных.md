

![](_png/Pasted%20image%2020230603092333.png)


## Что такое алгоритм? Оценка сложности

Алгоритм - это набор последовательных действий, которые решают какую-либо задачу.

Сложность алгоритма высчитывают через O(n), где n - количество действий для выполнения операции. Чем меньше действий, тем лучше.

На графе ниже представлено отображение, где от красного до фиолетового идёт последовательность от лучшего к худшему

![](_png/Pasted%20image%2020230603092800.png)

Мы ищем число 7 внутри отсортированного массива из десяти элементов. Если мы будем пользоваться линейным поиском и искать перебирая все элементы слева направо, то потратим 7 действий, а если будем искать через бинарный (двоичный) поиск, то нам потребуется всего 3 действия, так как мы два раза поделим массив пополам

Бинарный поиск имеет сложность O(log2n)

![](_png/Pasted%20image%2020230603093832.png)

Конкретно бинарный поиск в сравнении с линейным будет отрабатывать разные количество времени и искать крайне разное время

![](_png/Pasted%20image%2020230603094131.png)

Тут находится шпаргалка с описанием скоростей выполнения различных операций

![](_png/Pasted%20image%2020230603092812.png)

## Линейный поиск

Линейный поиск представляет собой перебор всех элементов массива, начиная с самого начала

Линейный алгоритм всегда имеет количество действий ==O(n)== - линейное количество

```JS
const array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
let count = 0;

function linearSearch(array, item) {
	for (let i = 0; i < array.length; i++) {
		count += 1;

		if (array[i] === item) {
			return i;
		}
	}

	return null;
}

console.log(linearSearch(array, 8));
console.log('Количество итераций = ', count); // = 8, т.е. O(n)

console.log(linearSearch(array, 10));
console.log(linearSearch(array, 324));
```

> Перебор идёт каждого элемента !
![](_png/Pasted%20image%2020230603100622.png)

## Бинарный поиск. Итеративный подход (цикл)

Бинарный поиск - это поиск внутри остортированного массива посредством выборки среднего значения из представленных 

Данный поиск представляет из себя деление всего массива на два и откидывание лишних значений. Если мы ищем 4 среди 10 элементов, то сначала выберится 5, потом, так как 5 больше 4, то откинется половина массива после 5, потом выберится 3, откинется всё до 3 и у нас останется 3 - 4- 5, где серединой останется искомое 4

Сложность у данного алгоритма ==O(log2n)== - логарифмическая сложность

```JS
const array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18];
let count = 0;

function binarySearch(array, item) {
	let start = 0; // начальная точка
	let end = array.length; // конечная точка - длина массива
	let middle; // середина списка
	let found = false; // найден ли элемент
	let position = -1; // позиция курсора для поиска

	while (found === false && start <= end) {
		count += 1;
		middle = Math.floor((start + end) / 2);

		if (array[middle] === item) {
			found = true;
			position = middle;
			return position;
		}

		if (item < array[middle]) {
			end = middle - 1;
		} else {
			start = middle + 1;
		}
	}

	return position;
}

console.log(binarySearch(array, 8));
console.log('Количество итераций = ', count); // = 4, т.е. O(log2n)
```

Способ решения через рекурсию:

```JS
function recursiveBinarySort(array, item, start, end) {
	let middle = Math.floor((start + end) / 2);

	if (item === array[middle]) 
		return middle;
	if (item < array[middle]) 
		return recursiveBinarySort(array, item, start, middle - 1);
	if (item > array[middle]) 
		return recursiveBinarySort(array, item, middle + 1, end);
}

console.log(recursiveBinarySort(array, 12, 0, array.length));
```


## Сортировка выбором. SelectionSort

Сортировка выбором представляет из себя сортировку, при которой сначала находится самый меньший элемент и он подставляется в начало, заменяя начальный

![](_png/Pasted%20image%2020230603135949.png)

Сложность данного алгоритма равна ==O(n^2)==, так как мы имеем 1/2 от n^2 - 276 итераций на 24 элемента

```JS
const array = [5, 6, 1, 3, 2, 4, 9, 7, 8, 6, 5, 3, 10, 16, 17, 18, -2, -3, -1, -15, 24, 26, 34, 33];
let count = 0;

function selectionSort(array) {
	for (let i = 0; i < array.length; i++) {
		// индекс минимального числа
		let indexMin = i;

		// тут мы ищем индекс минимального числа
		for (let j = i + 1; j < array.length; j++) {
			if (array[j] < array[indexMin]) {
				indexMin = j;
			}
			count += 1;
		}

		// переставляем местами найденные переменные
		let tmp = array[i];
		array[i] = array[indexMin];
		array[indexMin] = tmp;
	}

	return array;
}

console.log(selectionSort(array));
console.log('Количество итераций = ', count); // = 276, т.е. O(n^2)
```

## Сортировка пузырьком. BubbleSort

Сортировка пузырьком - переставление элемента больше правее, на место элемента меньшего порядка

![](_png/Pasted%20image%2020230603150726.png)

Этот же алгоритм ==является самым неэффективным==, так как он имеет сложность ровно ==O(n^2)==. Тут на 24 элемента массива было совершено 576 итераций, что = 24^2 

```JS
const array = [5, 6, 1, 3, 2, 4, 9, 7, 8, 6, 5, 3, 10, 16, 17, 18, -2, -3, -1, -15, 24, 26, 34, 33];
let count = 0;

function bubbleSort(array) {
	for (let i = 0; i < array.length; i++) {
		for (let j = 0; j < array.length; j++) {
			if (array[j + 1] < array[i]) {
				let tmp = array[j];
				array[j] = array[j + 1];
				array[j + 1] = tmp;
			}
			count += 1;
		}
	}

	return array;
}

console.log('длина массива = ', array.length);
console.log(bubbleSort(array));
console.log('Количество итераций = ', count); // = 576, т.е. O(n^2)
```

## Рекурсия. Рекурсивные функции. Факториал. Числа Фибоначчи

Рекурсия - это алгоритм, при котором функция зацикливает своё выполнение ровно до тех пор, пока она не достигнет финального результата

Примером является вычисление факториала, который представляет из себя умножение самого на себя число меньшего на 1 до 1 или поиск числа Фибоначчи, которое представляет из себя сложение всех сумм цифр числа  

```JS
// вычисление факториала
const factorial = (n) => {
	if (n === 1) {
		return 1;
	}

	return n * factorial(n - 1);
};

console.log(factorial(5)); // = 120

// Вычисление числа Фибоначчи 
const fibonacci = (n) => {
	if (n === 1 || n === 2) {
		return 1;
	}

	return fibonacci(n - 1) + fibonacci(n - 2);
};

console.log(fibonacci(8)); // = 21
```

## Быстрая сортировка. Сортировка Хоара

Быстрая сортировка предполагает под собой рекурсивное разделение массива данных на две части для поиска опорных чисел и сортировки 

> Это самый быстрый способ сортировки

![](_png/Pasted%20image%2020230603163920.png)

Сложность алгоритма равна ==O(log2n * n)==. На 24 элемента количество итераций равно 104 - то есть наименьшее число действий.

```JS
const array = [5, 6, 1, 3, 2, 4, 9, 7, 8, 6, 5, 3, 10, 16, 17, 18, -2, -3, -1, -15, 24, 26, 34, 33];
let count = 0;

function quickSort(array) {
	if (array.length <= 1) {
		return array;
	}

	let indexPivot = Math.floor(array.length / 2); // тут находится индекс центрального элемента массива
	let pivot = array[indexPivot]; // сам опорный элемент
	let less = []; // элементы меньше опорного числа
	let greater = []; // элементы больше опорного числа

	for (let i = 0; i < array.length; i++) {
		count += 1;
		if (i === indexPivot) continue; // пропускаем сортировку опорной точки
		if (array[i] < pivot) less.push(array[i]); // помещаем в меньший массив
		if (array[i] > pivot) greater.push(array[i]); // помещаем в больший массив
	}

	return [...quickSort(less), pivot, ...quickSort(greater)];
}

console.log('длина массива = ', array.length);
console.log(quickSort(array));
console.log('Количество итераций = ', count);
```

## Графы. Поиск в ширину

Поиск в ширину представляет собой поиск пути по графу от начальной точки до целевой и возможность в принципе найти данный путь

![](_png/Pasted%20image%2020230603181217.png)

Основная суть задачи - узнать, существует ли путь из точки A в точку G

![](_png/Pasted%20image%2020230603181349.png)

## Структура данных Очередь

Для реализации алгоритма поиска по графу, будет использоваться структура данных - Очередь. Основной её особенностью является то, что мы добавляем элемент в конец и достаём из начала 

![](_png/Pasted%20image%2020230603182219.png)





## Матрица смежности







## Алгоритм Дейкстры для поиска кратчайшего пути







## Рекурсивный обход дерева n-размерности







## Итеративный обход дерева n-размерности







## Структура данных Стек







## Кеширование вычислений







## Массивы. Сложность основных операций







## Связный список. Простая реализация и теория







## Бинарное дерево поиска. Простая реализация и теория







## Set и Map












