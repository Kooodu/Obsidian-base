

![](_png/Pasted%20image%2020230603092333.png)


## Что такое алгоритм? Оценка сложности

Алгоритм - это набор последовательных действий, которые решают какую-либо задачу.

Сложность алгоритма высчитывают через O(n), где n - количество действий для выполнения операции. Чем меньше действий, тем лучше.

На графе ниже представлено отображение, где от красного до фиолетового идёт последовательность от лучшего к худшему

![](_png/Pasted%20image%2020230603092800.png)

Мы ищем число 7 внутри отсортированного массива из десяти элементов. Если мы будем пользоваться линейным поиском и искать перебирая все элементы слева направо, то потратим 7 действий, а если будем искать через бинарный (двоичный) поиск, то нам потребуется всего 3 действия, так как мы два раза поделим массив пополам

Бинарный поиск имеет сложность O(log2n)

![](_png/Pasted%20image%2020230603093832.png)

Конкретно бинарный поиск в сравнении с линейным будет отрабатывать разные количество времени и искать крайне разное время

![](_png/Pasted%20image%2020230603094131.png)

Тут находится шпаргалка с описанием скоростей выполнения различных операций

![](_png/Pasted%20image%2020230603092812.png)

## Линейный поиск

Линейный поиск представляет собой перебор всех элементов массива, начиная с самого начала

Линейный алгоритм всегда имеет количество действий ==O(n)== - линейное количество

```JS
const array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
let count = 0;

function linearSearch(array, item) {
	for (let i = 0; i < array.length; i++) {
		count += 1;

		if (array[i] === item) {
			return i;
		}
	}

	return null;
}

console.log(linearSearch(array, 8));
console.log('Количество итераций = ', count); // = 8, т.е. O(n)

console.log(linearSearch(array, 10));
console.log(linearSearch(array, 324));
```

> Перебор идёт каждого элемента !
![](_png/Pasted%20image%2020230603100622.png)

## Бинарный поиск. Итеративный подход (цикл)

Бинарный поиск - это поиск внутри остортированного массива посредством выборки среднего значения из представленных 

Данный поиск представляет из себя деление всего массива на два и откидывание лишних значений. Если мы ищем 4 среди 10 элементов, то сначала выберится 5, потом, так как 5 больше 4, то откинется половина массива после 5, потом выберится 3, откинется всё до 3 и у нас останется 3 - 4- 5, где серединой останется искомое 4

Сложность у данного алгоритма ==O(log2n)== - логарифмическая сложность

```JS
const array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18];
let count = 0;

function binarySearch(array, item) {
	let start = 0; // начальная точка
	let end = array.length; // конечная точка - длина массива
	let middle; // середина списка
	let found = false; // найден ли элемент
	let position = -1; // позиция курсора для поиска

	while (found === false && start <= end) {
		count += 1;
		middle = Math.floor((start + end) / 2);

		if (array[middle] === item) {
			found = true;
			position = middle;
			return position;
		}

		if (item < array[middle]) {
			end = middle - 1;
		} else {
			start = middle + 1;
		}
	}

	return position;
}

console.log(binarySearch(array, 8));
console.log('Количество итераций = ', count); // = 4, т.е. O(log2n)
```

Способ решения через рекурсию:

```JS
function recursiveBinarySort(array, item, start, end) {
	let middle = Math.floor((start + end) / 2);

	if (item === array[middle]) 
		return middle;
	if (item < array[middle]) 
		return recursiveBinarySort(array, item, start, middle - 1);
	if (item > array[middle]) 
		return recursiveBinarySort(array, item, middle + 1, end);
}

console.log(recursiveBinarySort(array, 12, 0, array.length));
```


## Сортировка выбором. SelectionSort

Сортировка выбором представляет из себя сортировку, при которой сначала находится самый меньший элемент и он подставляется в начало, заменяя начальный

![](_png/Pasted%20image%2020230603135949.png)

Сложность данного алгоритма равна ==O(n^2)==, так как мы имеем 1/2 от n^2 - 276 итераций на 24 элемента

```JS
const array = [5, 6, 1, 3, 2, 4, 9, 7, 8, 6, 5, 3, 10, 16, 17, 18, -2, -3, -1, -15, 24, 26, 34, 33];
let count = 0;

function selectionSort(array) {
	for (let i = 0; i < array.length; i++) {
		// индекс минимального числа
		let indexMin = i;

		// тут мы ищем индекс минимального числа
		for (let j = i + 1; j < array.length; j++) {
			if (array[j] < array[indexMin]) {
				indexMin = j;
			}
			count += 1;
		}

		// переставляем местами найденные переменные
		let tmp = array[i];
		array[i] = array[indexMin];
		array[indexMin] = tmp;
	}

	return array;
}

console.log(selectionSort(array));
console.log('Количество итераций = ', count); // = 276, т.е. O(n^2)
```

## Сортировка пузырьком. BubbleSort

Сортировка пузырьком - переставление элемента больше правее, на место элемента меньшего порядка

![](_png/Pasted%20image%2020230603150726.png)

Этот же алгоритм ==является самым неэффективным==, так как он имеет сложность ровно ==O(n^2)==. Тут на 24 элемента массива было совершено 576 итераций, что = 24^2 

```JS
const array = [5, 6, 1, 3, 2, 4, 9, 7, 8, 6, 5, 3, 10, 16, 17, 18, -2, -3, -1, -15, 24, 26, 34, 33];
let count = 0;

function bubbleSort(array) {
	for (let i = 0; i < array.length; i++) {
		for (let j = 0; j < array.length; j++) {
			if (array[j + 1] < array[i]) {
				let tmp = array[j];
				array[j] = array[j + 1];
				array[j + 1] = tmp;
			}
			count += 1;
		}
	}

	return array;
}

console.log('длина массива = ', array.length);
console.log(bubbleSort(array));
console.log('Количество итераций = ', count); // = 576, т.е. O(n^2)
```

## Рекурсия. Рекурсивные функции. Факториал. Числа Фибоначчи

Рекурсия - это алгоритм, при котором функция зацикливает своё выполнение ровно до тех пор, пока она не достигнет финального результата

Примером является вычисление факториала, который представляет из себя умножение самого на себя число меньшего на 1 до 1 или поиск числа Фибоначчи, которое представляет из себя сложение всех сумм цифр числа  

```JS
// вычисление факториала
const factorial = (n) => {
	if (n === 1) {
		return 1;
	}

	return n * factorial(n - 1);
};

console.log(factorial(5)); // = 120

// Вычисление числа Фибоначчи 
const fibonacci = (n) => {
	if (n === 1 || n === 2) {
		return 1;
	}

	return fibonacci(n - 1) + fibonacci(n - 2);
};

console.log(fibonacci(8)); // = 21
```

## Быстрая сортировка. Сортировка Хоара

Быстрая сортировка предполагает под собой рекурсивное разделение массива данных на две части для поиска опорных чисел и сортировки 

> Это самый быстрый способ сортировки

![](_png/Pasted%20image%2020230603163920.png)

Сложность алгоритма равна ==O(log2n * n)==. На 24 элемента количество итераций равно 104 - то есть наименьшее число действий.

```JS
const array = [5, 6, 1, 3, 2, 4, 9, 7, 8, 6, 5, 3, 10, 16, 17, 18, -2, -3, -1, -15, 24, 26, 34, 33];
let count = 0;

function quickSort(array) {
	if (array.length <= 1) {
		return array;
	}

	let indexPivot = Math.floor(array.length / 2); // тут находится индекс центрального элемента массива
	let pivot = array[indexPivot]; // сам опорный элемент
	let less = []; // элементы меньше опорного числа
	let greater = []; // элементы больше опорного числа

	for (let i = 0; i < array.length; i++) {
		count += 1;
		if (i === indexPivot) continue; // пропускаем сортировку опорной точки
		if (array[i] < pivot) less.push(array[i]); // помещаем в меньший массив
		if (array[i] > pivot) greater.push(array[i]); // помещаем в больший массив
	}

	return [...quickSort(less), pivot, ...quickSort(greater)];
}

console.log('длина массива = ', array.length);
console.log(quickSort(array));
console.log('Количество итераций = ', count);
```

## Графы. Поиск в ширину

Поиск в ширину представляет собой поиск пути по графу от начальной точки до целевой и возможность в принципе найти данный путь

![](_png/Pasted%20image%2020230603181217.png)

Основная суть задачи - узнать, существует ли путь из точки A в точку G

![](_png/Pasted%20image%2020230603181349.png)

## Структура данных Очередь

Для реализации алгоритма поиска по графу, будет использоваться структура данных - Очередь. Основной её особенностью является то, что мы добавляем элемент в конец и достаём из начала 

![](_png/Pasted%20image%2020230603182219.png)

Тут уже представлен простейший алгоритм очереди, где мы перебираем массив массивов точек графа

```JS
// сами значения графа
const graph = {};
graph.a = ['b', 'c'];
graph.b = ['f'];
graph.c = ['d', 'e'];
graph.d = ['f'];
graph.e = ['f'];
graph.f = ['g'];

function breadthSearch(graph, start, end) {
	let queue = []; // сама очередь
	queue.push(start); // добавляем сразу стартовую вершину

	// пока в очереди есть хотя бы один элемент
	while (queue.length > 0) {
		// достаём первый элемент из массива
		const current = queue.shift();

		// если после этого элемента ничего нет, то дальше в графе нет возможности проходиться - вершина конечная
		if (!graph[current]) {
			graph[current] = []; // выставляем после него пустоту
		}

		// если в графе по текущей вершине массив содержит конечную точку
		if (graph[current].includes(end)) {
			return true;
		} else {
			// если не содержит, то разворачиваем вершины графа к вершинам очереди
			queue = [...queue, ...graph[current]];
		}
	}
	return false;
}

console.log(breadthSearch(graph, 'a', 'g')); // true
console.log(breadthSearch(graph, 'a', 's')); // false
```

## Матрица смежности

Матрица смежности - это способ представления графа в виде квадратной матрицы, где строки и столбцы матрицы соответствуют вершинам графа, а ячейки содержат информацию о том, есть ли ребро между этими двумя вершинами или нет.

Для взвешенного графа, вместо 0 или 1 в ячейках используются числа, которые обозначают вес или стоимость ребра между соответствующими вершинами.

Матрица смежности может быть использована для быстрого определения, есть ли связь между двумя вершинами, и получения информации о структуре графа. Однако, если количество вершин графа очень большое, то матрица смежности занимает много памяти, и может быть неэффективной в использовании.

![](_png/Pasted%20image%2020230604092411.png)

```JS
const matrix = [
	[0, 1, 1, 0, 0, 0, 0],
	[0, 0, 0, 0, 1, 0, 0],
	[0, 0, 0, 1, 0, 1, 0],
	[0, 0, 0, 0, 1, 0, 0],
	[0, 0, 0, 0, 0, 0, 1],
	[0, 0, 0, 0, 1, 0, 0],
	[0, 0, 0, 0, 0, 0, 0],
];
```

## Алгоритм Дейкстры для поиска кратчайшего пути

Алгоритм Дейстры представляет из себя поиск кратчайшего пути в графе, когда в учёт между точками ещё берётся ещё и расстояние между ними 

![](_png/Pasted%20image%2020230604093607.png)

1. Создается объект `graph`, который представляет ваш взвешенный граф. Каждый ключ этого объекта соответствует вершине графа, а значение - объект, который содержит пары "соседняя вершина: расстояние до нее".
2. Определена функция `shortPath(graph, start, end)`, которая принимает три параметра: `graph` - ваш взвешенный граф, `start` - начальная вершина и `end` - конечная вершина. Функция возвращает объект `costs`, который содержит кратчайший путь от начальной вершины `start` до конечной вершины `end`.
3. Объявляются три переменные: `costs`, `processed` и `neighbors`. Начальное значение переменной `costs` - это пустой объект, который будет использоваться для хранения стоимости кратчайшего пути до каждой вершины графа от начальной вершины. Переменная `processed` - это массив, который будет содержать все узлы, которые были уже проверены. Это нужно, чтобы убедиться, что мы не рассмотрим узел дважды. Переменная `neighbors` - это объект, который будет содержать всех соседей узла, который мы в данный момент рассматриваем.
4. Цикл `forEach` используется для итерации по списку ключей графа. Для каждого узла графа, кроме начального узла, заполняется таблица `costs` записью: имя узла в качестве ключа, а значение - расстояние от начальной вершины до этого узла. Если расстояние не определено (нет соединения между текущим узлом и начальным узлом), то значение устанавливается на достаточно большое число (1000000).
5. Функция `findNodeLowestCost(costs, processed)` используется для поиска узла с наименьшей стоимостью пути из таблицы `costs`. Она ищет наименьшее число пути и возвращает соответствующий узел, который еще не был обработан.
6. В основном цикле `while`, мы используем функцию `findNodeLowestCost()` для нахождения узла с наименьшей стоимостью пути. Затем мы получаем все соседние вершины этого узла и итерируемся по ним, чтобы проверить, можем ли мы добраться до соседней вершины через текущий узел по более короткому пути. Если мы можем, то обновляем таблицу `costs` с новой стоимостью пути. Мы также добавляем проверенный узел в массив `processed`. Затем мы повторяем цикл до тех пор, пока не достигнем конечной точки или не будет больше узлов для обработки.
7. В конце функция `shortPath()` возвращает объект `costs`, который содержит кратчайший путь от начальной вершины `start` до конечной вершины `end`.

```JS
// Поиск кратчайшего пути в графе

const graph = {};
graph.a = { b: 2, c: 1 };
graph.b = { f: 7 };
graph.c = { d: 5, e: 2 };
graph.d = { f: 2 };
graph.e = { f: 1 };
graph.f = { g: 1 };
graph.g = {};

function shortPath(graph, start, end) {
	const costs = {}; // таблица с кратчайшими путями
	const processed = []; // сюда мы добавляем проверенные узлы
	let neighbors = {}; // тут находятся соседние вершины конкретного узла

	// далее итерируемся по списку ключей
	Object.keys(graph).forEach((node) => {
		if (node !== start) {
			let value = graph[start][node]; // тут мы получаем расстояние от стартовой точки графа
			costs[node] = value || 1000000; // если расстояние есть, то добавляем его в пути, а если нет, то оно бесконечно далеко
		}
	});

	// далее нам нужно найти вершину, в которую можно попасть из начальной с наименьшим расстоянием пути
	let node = findNodeLowestCost(costs, processed);

	while (node) {
		const cost = costs[node]; // записываем стоимость вершины
		neighbors = graph[node]; // добавляем соседние вершины к целевым нодам, чтобы по ним можно было проитерироваться

		// тут мы ищем новую стоимость, когда путь будет короче
		Object.keys(neighbors).forEach((neighbor) => {
			let newCost = cost + neighbors[neighbor];
			if (newCost < costs[neighbor]) {
				costs[neighbor] = newCost;
			}
		});

		processed.push(node);
		node = findNodeLowestCost(costs, processed);
	}
	return costs;
}

function findNodeLowestCost(costs, processed) {
	let lowestCost = 10000000; // тут будет находиться минимальное число пути
	let lowestNode; // нода, которую нужно найти

	Object.keys(costs).forEach((node) => {
		let cost = costs[node]; // записываем длину пути ноды

		// если путь меньше меньшей стоимости и ноды нет в обработанных нодах
		if (cost < lowestCost && !processed.includes(node)) {
			// то присваиваем меньшие значения данным нодам
			lowestCost = cost;
			lowestNode = node;
		}
	});

	return lowestNode;
}

console.log(shortPath(graph, 'a', 'g'));
```

## Рекурсивный обход дерева n-размерности

Деревья - это рекурсивная структура данных, где каждый узел является так же деревом

![](_png/Pasted%20image%2020230605115312.png)

Таким образом можно представить дерево

Оно же будет использоваться для следующих примеров

```JS
const tree = [
	{
		v: 5,
		c: [
			{
				v: 10,
				c: [
					{
						v: 11,
					},
				],
			},
			{
				v: 7,
				c: [
					{
						v: 5,
						c: [
							{
								v: 1,
							},
						],
					},
				],
			},
		],
	},
	{
		v: 5,
		c: [
			{
				v: 10,
			},
			{
				v: 15,
			},
		],
	},
];
```

Рекурсивный обход дерева выглядит следующим образом: 

```JS
const recursive = (tree) => {
	let sum = 0;

	tree.forEach((node) => {
		sum += node.v;

		if (!node.c) return node.v;

		sum += recursive(node.c);
	});

	return sum;
};
```

## Структура данных Стек

Стек подразумевает под собой сбор самого свежего вошедшего элемента. Если при FIFO уходит первый пришедший, то тут, LIFO - уходит последний пришедший 

![](_png/Pasted%20image%2020230605120642.png)

## Итеративный обход дерева n-размерности

Данная функция `iteration` представляет собой итеративный алгоритм обхода дерева, где каждый узел представлен объектом, содержащим его значение `v` и массив его дочерних узлов `c`.

Алгоритм начинается с проверки наличия элементов в дереве. Если дерево пустое, то функция возвращает 0.

Затем создается переменная `sum`, которая будет хранить сумму значений всех узлов дерева. Также создается массив `stack`, в который помещаются все узлы первого уровня дерева.

Далее запускается цикл `while`, который будет выполняться до тех пор, пока `stack` не станет пустым. На каждой итерации цикла извлекается последний узел из `stack` и добавляется его значение к `sum`. Затем проверяется наличие дочерних узлов у текущего узла. Если дочерние узлы есть, то они добавляются в конец `stack`.

После того как все узлы дерева будут обработаны, функция вернет сумму значений всех узлов.

Таким образом, данная функция реализует обход дерева в глубину (Depth-First Search) при помощи стека.

```JS
const iteration = (tree) => {
	if (!tree.length) return 0;

	let sum = 0;
	let stack = [];

	tree.forEach((node) => stack.push(node));

	while (stack.length) {
		const node = stack.pop();

		sum += node.v;

		if (node.c) {
			node.c.forEach((child) => stack.push(child));
		}
	}

	return sum;
};
```

## Кеширование вычислений







## Массивы. Сложность основных операций







## Связный список. Простая реализация и теория







## Бинарное дерево поиска. Простая реализация и теория







## Set и Map












