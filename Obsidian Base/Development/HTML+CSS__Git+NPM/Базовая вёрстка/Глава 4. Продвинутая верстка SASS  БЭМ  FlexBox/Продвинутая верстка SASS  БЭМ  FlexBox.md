## **5. Продвинутая верстка SASS  БЭМ  FlexBox**

### **5.2 Препроцессор SASS ч.1**
#SASS 

- Чтобы у нас была возможность компилировать sass-файлы, нам нужно установить сасс-компилятор. После его установки снизу нажимаем на кнопку Watching
![](_png/4a72a2feeb0e13df575edda6fc95bd39.png)![](_png/87b9a8ee94159dc77e014173ff1062d9.png)
- **Нужно взять за правило проверять настройки плагинов, если что-то не устраивает!** В настройках программы находим плагин нашего компилятора и указываем путь до изменяемых файлов
![](_png/e67ca2cf98754749e18541a97498e74e.png)![](_png/64baf5856109aac0ba2893d42cda4494.png)
- И дальше тут у нас должен появиться технический документ
![](_png/d9e250650b724eef685b27d802dd1161.png)
- И чтобы у нас появился нормальный сас-синтаксис в вскоде, нужно установить Sass
![](_png/f5329f7383fba18ab0b1f538a081b2ec.png)
### **5.3 Препроцессор SASS ч.2**

- У технологии САСС есть ряд преймуществ. Первое из них – ненадобность использовать скобки. Вместо них за отображение вложенности (инструкции или элемента в другом элементе) используется таб (именно таб, а не 4 пробела).

Так же слово block можно заменить одним знаком &, что тоже ускоряет написание кода и позволяет более эффективно использовать методологию БЭМ. Слово block берётся из верхнего названия родителя, т.е. если класс родителя будет называться box, то амперсанда будет обозначать box 
![](_png/6439fd47aed52a1f7c7149460c2fc940.png)![](_png/8c3a756b25444750a21887d0a2ad02a7.png)
т.е. амперсанд = класс, к которому он применён
![](_png/ecde862e710c2b80c8b09c4303d680ae.png)
- Так же есть очень крутая особенность в сасе: переменные и миксины.

Переменные позволяют в себе хранить заданные значения и использовать их во всё проекте (например, вставлять основные цвета и при изменении офис-дизайна у заказчика можно быстро поменять цвет из одного места)

Миксины – это переменные, которые хранят в себе целые инструкции. Это очень удобно для стилизации различающихся на малость блоков
![](_png/0c4fd76ec92e32698a6722f19f4e703b.png)
- Дальше идёт наша оптимизация кода. Теперь можно выкинуть нормалайз и ресет css, ведь теперь мы можем сохранить «.scss» их версию (не сасовскую, так как в этих файлах есть кавычки) и подключать эти файлы к нашему style.css через импорт, что будет куда удобнее (однако при каждом сохранении цсс версия файлов всё равно будет генерироваться)
![](_png/f9d2406bd89d15df6a7862b24e67bf2e.png)![](_png/fcfa8df1f9440fa086dde787d1a348e8.png)
- И вот таким вот образом создаются комментарии
![](_png/8c22316c4d8625b36c616ede5efd4d7e.png)
### **5.2-3 Препроцессор SASS -** **Full**

![](_png/83a64904d9a27c086fcb9199e44e031b.png)
![](_png/9f96e7854587c3f6814e2b49de09e329.png)
![](_png/909687e0e7022a84ff72bf407639db6d.png)
![](_png/a1e2470016d638b8fa2ae09648ba5569.png)
![](_png/dfb3ea8a1df27edc8f68c5964ddf36d3.png)
![](_png/882c8eb79a4d12ef53461fcf65e285b0.png)
![](_png/25a10d46af663f4d637d82583f1f89e4.png)
![](_png/18a1fc79681f572206fe69bea8450d05.png)
![](_png/7a6968ecb1ae7e1184ebd0c899c2cc7f.png)
![](_png/3a9702b71d1ff0cf88d7daad53a911b0.png)
![](_png/5d254dd9f127c28a21f18351f6d32c2a.png)
![](_png/d8ed08df2d802985c5f35234f32098fe.png)
![](_png/1d9f8225cbc4131730fb3138fbabf07b.png)
![](_png/2b85940ec89fbbeb2513c6764cfe3a60.png)
![](_png/7635d1466411e75f77041d3831471b12.png)
![](_png/16e9a1c68d3808ccfa4ae7a567f58cbb.png)
![](_png/bf56c9691942824c80d52a2a35f9da9f.png)
![](_png/e348df5885b6c110aace522eed3d4374.png)
![](_png/fed1ae38669d6f2ef1bbc6cc8341c5e4.png)
![](_png/41872e031c47db70498f49d1bd721687.png)
![](_png/45df87cc4d792695f06cd0fd5343d9b6.png)
![](_png/093b0e770b966d951167b68325d991a5.png)
![](_png/ef1dfb331129909ae61e171744de9dc1.png)
![](_png/2f443416f35f5f420854d934607782a2.png)
![](_png/aae2a0db2a1a4bb53d71f9c153ee1a19.png)
![](_png/c96479031256613a073c49a33587e8f9.png)
![](_png/d1738614c5a409896c93d1e1a522b288.png)


![](_png/642ee0638dd32838bebfa87e5b8b6c2e.png)

[https://tproger.ru/translations/complete-sass-guide/#sass-preprocessor](https://tproger.ru/translations/complete-sass-guide/#sass-preprocessor)

### **5.4 FlexBox. Новый способ позиционирования элементов**
#FlexBox 

- И сейчас наконец-то будет описана технология, которая позволяет нормально выравнивать объекты на странице. Дело в том, что прошлые попытки выровнять через марджин или текст-алайн имели достаточно костыльную реализацию расположения контента на странице. Однако придумали и добавили в CSS такую технологию как FlexBox.

Чтобы применить её, нужно воспользоваться «**display****:** **flex**;»

- Помочь с изучением данной технологии может сайт Flexbox Froggy

- Используя свойство **justify-content**, мы выравниваем элементы горизонтально, а также оно принимает следующие значения:

·         **flex-start**: Элементы выравниваются по левой стороне контейнера.

·         **flex-end**: Элементы выравниваются по правой стороне контейнера.

·         **center**: Элементы выравниваются по центру контейнера.

·         **space-between**: Элементы отображаются с одинаковыми отступами между ними.

·         **space-around**: Элементы отображаются с одинаковыми отступами вокруг них.
![](_png/7f113ef14ab68fe6a59672eb36b5059b.png)
- Теперь используем **align-items** - это CSS свойство выравнивает элементы вертикально и принимает следующие значения:

·         **flex-start**: Элементы выравниваются по верхнему краю контейнера.

·         **flex-end**: Элементы выравниваются по нижнему краю контейнера.

·         **center**: Элементы выравниваются вертикально по центру контейнера.

·         **baseline**: Элементы отображаются на базовой линии контейнера.

·         **stretch**: Элементы растягиваются, чтоб заполнить контейнер.
![](_png/c1422fab0972309c1cacccd441690aa8.png)
- **Flex-direction** - это CSS свойство задает направление, в котором будут расположены элементы в контейнере, и принимает следующие значения:

·         **row**: элементы размещаются по направлению текста.

·         **row-reverse**: элементы отображаются в обратном порядке к направлению текста.

·         **column**: элементы располагаются сверху вниз.

·         **column-reverse**: элементы располагаются снизу вверх.
![](_png/ff3c6298f4976828018a0162c9302789.png)
-
![](_png/d49078f3ea00394c12eab7f62b9320e2.png)
![](_png/6e3b7bbfe89e0a9f747ba4accdbf91bd.png)
![](_png/99340cb846888de769a13162292ddbe6.png)
- Иногда изменения порядка отображения элементов в контейнере недостаточно. В таких случаях мы можем применить свойство **order** для конкретных элементов. По умолчанию, значение этого свойства у элементов равно **0**, но мы можем задать положительное или отрицательное целое число этому свойству.
![](_png/00535c2b7a99ba940a5dfe80d5df042c.png)
![](_png/0ae2c7e51814ad178ebcad54e48c56c4.png)
![](_png/21f8405ca16b185231eed7069b2aff99.png)
- Еще одно свойство, которое можно применить к определенному элементу это **align-self**. Это свойство принимает те же значения, что и **align-items**.
![](_png/faf2a2fc25bce9937444146867c287ae.png)
-
![](_png/5129f3c39681b78d25c937898c30fdfe.png)
![](_png/0e32f9caa1d41e76c53f12b49f852660.png)
- Если объектов слишком много и их сплющило на одном ряду лилий, то раздвинуть их можно помощью свойства **flex-wrap**, которое принимает следующие значения:

·         **nowrap**: Размеры элементов устанавливаются автоматически, чтоб они поместились в один ряд.

·         **wrap**: Элементы автоматически переносятся на новую строку.

·         **wrap-reverse**: Элементы автоматически переносятся на новую строку, но строки расположены в обратном порядке.
![](_png/34333789988582e7c13e22ba1da0821e.png)
![](_png/80cb98289dccf4f63949f3d2931ddef3.png)
- Два свойства **flex-direction** и **flex-wrap** используются так часто вместе, что было создано свойство **flex-flow** для их комбинирования. Это свойство принимает значения двух этих свойств, разделеные пробелом.

Например, можно использовать **flex-flow: row wrap**, чтоб элементы располагались в ряд и автоматически переносились на новую строку.
![](_png/8c6a78a225e756f8475c8267957de748.png)
![](_png/e4e82a6d52771eebbbaa1442b3b7b4a2.png)
- Лягушат раскидало по всему пруду, но лилии сгруппированы в верхней части. Ты можешь использовать **align-content**, чтобы указать, как несколько рядов должны отделяться друг от друга. Данное свойство принимает следующие значения:

·         **flex-start**: Ряды группируются в верхней части контейнера.

·         **flex-end**: Ряды группируются в нижней части контейнера.

·         **center**: Ряды группируются вертикально по центру контейнера.

·         **space-between**: Ряды отображаются с одинаковыми расстояниями между ними.

·         **space-around**: Ряды отображаются с одинаковыми расстояниями вокруг них.

·         **stretch**: Ряды растягиваются, чтоб заполнить контейнер равномерно.

Это может запутать, но **align-content** отвечает за расстояние между рядами, в то время как **align-items** отвечает за то, как элементы в целом будут выровнены в контейнере. Когда только один ряд, **align-content** ни на что не влияет.
![](_png/11debfc5e3243edd873bf0226916f879.png)
- В последнем примере стоит обратить внимание на wrap-reverse
![](_png/0579d4c4e345a5f38a370b4d1a852b50.png)![](_png/13ab3ef7a8080bcaffe769a97e7b7a09.png)
- Шпаргалка по FlexBox
![](_png/609222bdb962754d27a7d7d224dc3957.png)
### **5 Что такое** **Grid** **и как его использовать**
#CSSGrid 

- Кратка шпаргалка по всем свойствам гридов
![](_png/e5a975a011ee53f883262c81a05c57e5.png)
- Очень классная шняга. $ - подставит число в класс, {$} – впишет число внутрь тега (или любой другой текст)
![](_png/9286ff0cc5918f58b871c05d4dd618b4.png)![](_png/53a042a3dde85ff3b33488d03054627c.png)
- Для начала инициализируем несколько объектов нашей сетки
![](_png/ecba4ea2da62f2298169528806881e62.png)
- Первым делом, чтобы у нас всё заработало, нужно воспользоваться «display: grid», который включит сеточное отображение

Дальше, чтобы были видны изменения, нам нужно создать шаблон через grid-template-columns, в котором мы укажем размеры наших колонок. Сколько размеров мы укажем, столько размеров и будет. Единицы измерения поддерживаются любые
![](_png/cf11227cd18cec8ee5e3c3b7ffb46856.png)![](_png/db510ea7d134f0eeea8385c12f02ad63.png)
![](_png/76b0cc09f163537fce4a350c3da2203f.png)
- Но чтобы равномерно поделить колонки, используются фракции – «fr». Они определяют какую часть будет занимать колонка от всей части таблицы
![](_png/891c8bced2974dc87dd357b78585b73b.png)
- Так же можно описать куда больше колонок (число колонок, размер)
![](_png/49eb6c785046e495c7a7cdd5449e5aba.png)
Так же можно вписать несколько размеров и они будут чередоваться
![](_png/8b98ea9a53458c597ab40a05d3432ec9.png)
- Когда мы задаём теплейт на строки, то мы меняем их размер (сколько значений – столько и размер каждой отдельной строки)
![](_png/909029faa8ee4c59d4507a55be66818a.png)
- Так же мы можем добавить gapы по колонкам или строкам отдельно
![](_png/627d5f557d34a6fa15f4618c338d2f8e.png)
Либо мы можем просто добавить гэпы сразу для всех одинаковые
![](_png/b2145eb46bbaf95664a6933f91d97e70.png)
- grid-auto-rows указывает размер для тех строк, для которых он явно не задан
![](_png/4399e05a07c7b7fb59dbe7ed4098dc4b.png)
- Для задания размера строки так же рекомендуется использовать функцию minmax(), которая позволяет задать размер для них и расширять строки под размер контента
![](_png/32ebf3fd98e13a3524cfa61833426f95.png)
- Данные два параметра работают только если их родителю (тут - контейнеру) заданы фиксированные параметры размеров

justify-content – выравнивает элементы колонки по оси Y

align-content - выравнивает элементы колонки по оси X
![](_png/9406a8a57d20846cf28f034adad153ef.png)
- align-items позволяет сделать выравнивание относительно ячейки и она будет подстраиваться под контент, который в контейнере

Justify-items же выравнивает колонки по икс-координате
![](_png/b44688d6ddaeb87b0855508ad5c09c6e.png)
![](_png/bcb06e4dcacacd312e1a6d175385346f.png)
- И при комбинировании инструкций align-self и justify-self, которые влияют на сам объект отдельно, мы спокойно можем создавать макеты любой сложности
![](_png/69617f6e5f96908c745c9964f8834c58.png)
- Данные инструкции уже конкретно показывают, какое положение будет занимать определённый блок грида в таблице.

1) Указывает, с какой колонки начинается элемент

2) Указывает окончание колонки (последняя видимая колонка в таблице + 1)

3) Указываем номер строки, с которой начинается объект

4) И на которой заканчивается
![](_png/0b1cfe76450aa34768e5cc56c2ca7d14.png)
И вот пример. Мы можем менять положение объектов из одного места в другое
![](_png/49edd4c36fd40d7e9924379df8dbfb8d.png)
- А вот пример короткой записи прошлых значений, где через слэш мы пишем: откуда начинается/где заканчивается.
![](_png/d30c2c56496652a4c611b9011dc3d3ae.png)
- Так же девтулз спокойно отображает количество занимаемых строк и столбцов
![](_png/56844fa4914c50f38f4fc7930b7a2354.png)
- Так же есть ещё один крайне полезный инструмент – это grid-template-areas
![](_png/1ae7451b80390c10cfa0bacdb3fe2d80.png)
-

### **5.5 Методология БЭМ и как ее использовать**
#BEM 

- БЭМ (Блок, Элемент, Модификатор) — компонентный подход к веб-разработке. В его основе лежит принцип разделения интерфейса на независимые блоки. Он позволяет легко и быстро разрабатывать интерфейсы любой сложности и повторно использовать существующий код, избегая «Copy-Paste».

**БЭМ – это:**

·       **Блок**

·       **Элемент**

·       **Модификатор**

- Используется БЭМ, чтобы реализовать методологию, по которой мы будем переиспользовать элементы много раз и не разводить копи-пасту
![](_png/9024e865adbbdff936ed7164afb526d6.png)
- Блок – это заранее заготовленный элемент, который хранит в себе контент. Ему можно определить размер, расположение контента внутри него и всё остальное, что влияет только на контент внутри него.

Внутри блока находятся либо его дочерние элементы, либо другие блоки.

Блоки создаём, когда один и тот же элемент повторяется на странице несколько раз
![](_png/fea1b05d7e00dc0ce83e2786d833106b.png)![](_png/98b7ffc7ca40b552ebc64aa698e5b869.png)
- Элемент показывает нам, что перед нами находится. Данный класс позволяет стилизировать и работать с определённым элементом блока отдельно. Ему позволяется задавать отступы и размеры. Стилизовать же желательно через миксы (например, создать класс text, которым мы будем модифицировать только текст)

Элементами блока называем все вложенные элементы, которые принадлежат родителю. Например, блок навигационного меню «**nav**» и его дочерние элементы «**nav__item**», внутри дочерних элементов ссылки «**nav__link**» (вкладывать родительские элменты – нельзя **«nav__item__link»** - неправильно**)
![](_png/47d9c9c01b1e56b90cc432841d230031.png)
- Если описывать более конкретно, то слева у нас Блок – Блок – Элемент – это **неправильно**. У нас идёт Блок – Элемент – Элемент и пример справа нам показывает это. Справа мы видим привязку элемента к блоку, а не элемента к элементу (как слева, где элемент выражается как блок)  
![](_png/84c5b73c2b8a3455149724485ca2bd75.png)
- Модификатор уточняет сам объект. Если у нас несколько блоков текста внутри блока, то мы прописываем первым классом – блок__элемент, а вторым классом – блок__элемент_модификатор

Модификатор отдельно выделяет один конкретный объект среди многих, чтобы задать этому отдельному элементу уникальные стили
![](_png/3fcd1c96c755581fd815a4cda84f002c.png)![](_png/b49dc9567f40a1a641f3a9ef43adb6df.png)
- Миксы позволяют совмещать поведение и стили

В данном примере «header-button__text» является как элементом блока «header-button», так и отдельным независимым элементом за счёт класса «text»

Такой подход позволяет задать внешнюю геометрию или позиционирование в «header-button__text», а сами стили прописать в «text», что позволяет использовать класс «text» для стилизирования отдельных таких же элементов на странице
![](_png/2b06ab8cf8c541b3b4b9cfb235c6251a.png)
### **5.6 Используем FlexBox и БЭМ в новом проекте**

- Нормализаторы кода закидываем в таком порядке
![](_png/fbca8b8beb86309f50651315626e912c.png)
- Ну и включаем все отступы (паддинги и марджины) в счёт размеров наших блоков
![](_png/66e0d7c6b191931842e32866ae454d73.png)
- И сразу нужно объяснить, какую роль тут играет методология БЭМ.

Во-первых, мы сделали main-section, который будет отвечать за содержимое только нашей основной секции, в которой будет располагаться контент первого отдела.

Во-вторых, мы сделали внутри отдельный контейнер, который уже будет отвечать за центрирование и ограничение в ширину всего контента, который будет в нём находиться. Так же мы дописали ещё один класс (описательный - БЭМ), чтобы работать конкретно с ним (потому как класс контейнер мы будем переиспользовать по всему сайту)

Ну и дальше в хедере мы будем хранить то, что будет располагаться в хедере
![](_png/0b91b7a8696d34f3e8f57f13075db3c1.png)![](_png/46352456e4b10ff39aefa86dfaec6582.png)
- Ну и тут мы уже описываем наше навигационное меню.

Во-первых, мы добавили после хэдера секцию нав, которая будет иметь БЭМовский класс (в котором у нас указано где находится и кому принадлежит навигационная строка) и отдельный класс для стилизации (он поможет сделать шаблон стиля навигационного меню, который в дальнейшем получится переиспользовать)

Во-вторых, мы сделали сам список. Для ul мы прописываем флекс-бокс свойство для расположения списка в строку. Каждому элементу списка приписываем отступ справа (по правилу право-низ) и описываем размер шрифта. Далее так же удобно прописываем псевдокласс через амперсанду и для последнего элемента убираем отступ.

В-третьих. В классе мэин-секшн делаем отступ сверху 16 пикселей (чтобы отодвинуть навигационное меню). Дальше обращаемся к контейнеру, который будет у нас регулировать расположение header и nav. Располагаем хедер и футер в строку (row) и через джастифай располагаем их в разных концах страницы (space-between – располагает элементы на равном удалении, равномерно заполняя строку, в которой элементы находятся). Далее выставляем высоту данного меню и центрируем лого и список
![](_png/e8f6154bfbd954293b4f772b48923bfa.png)![](_png/f87b8f8b5bf1f1c9fecbf1cf6e83230a.png)
Конкретно этими двумя строчками мы задаём высоту контейнера с навигационным меню и располагаем элементы относительно друг друга по центру (текст становится вровень с логотипом)
![](_png/301c11db716332cbcdd626d2150278da.png)![](_png/fda7d47ecac90918cc0bdb28231d9767.png) ![](_png/5b9d2ee5a4caba73cf3d2f649771495b.png)
### **5.7 Как превратить растровый логотип в векторный с помощью Illustrat**

- Если нам отправили некачественное изображение, да ещё и в png (несжатый формат с альфаканалом), то оно во-первых весит много и во-вторых имеет свойство пикселизироваться. Поэтому стоит заиметь его .svg версию. Сделать её мы можем сами в иллюстраторе
![](_png/dab48343173249995e7b80d2b467afac.png)![](_png/6f17a6993b0b73daf4423efa79ef909a.png)
- Ну и для того, чтобы отобразить логотип на сайте, нам нужно задать ему хотя бы минимальный размер (взять ширину из нашего макета). Вписать размер нужно, так как данный формат может бесконечно скейлиться
![](_png/52ff721d4b62d2bef6f52e37d4eded57.png)
### **5.8 Закругление, поворот и тени для элементов**
- Закругление

**border-radius: 100px**

- Тени:
**box-shadow: 0px 4px 4px 4px rgba(0, 0, 0, 0.25)**

Отступ по горизонтали, по вертикали, ширина тени, растяжение тени и последнее значение – цвет тени

- Поворот:

Тут уже стоит отдельно зайти на справочник и взглянуть на множество вариантов использования **transform**: https://html5book.ru/css3-transform/
![](_png/95c3fad9cdce02dcbafadfa53f19210f.png)
- Реализация самого контента первого блока уже будет поделена на две части: левую и правую.

Во-первых, мы создадим второй контейнер и дадим ему второй класс по БЭМу. В этом контейнере зададим два дива, где поделим блок пополам (гитарист с блоками – слева, текст - справа). В левый блок закинем картинку с нашим гитаристом. Под картинку закинем три дива, которые будут представлять у нас блоки позади гитариста (их мы будем стилизовать так же, как в фигме)

Во-вторых, приступаем к вёрстке стилей. Первым делом нашему родителю назначим позиционирование релэйтив (для того, чтобы абсолютно спозиционированные объекты отталкивались от него, а таких объектов у нас будет 3 – и это блоки). Дальше нам нужно накинуть релэйтив на нашу картинку. Позиционировать абсолютно мы её не будем, но нам нужно задать ей индекс, чтобы позиционированные блоки оказались под гитаристом.

В-третьих, стилизуем блоки. Большинство стилей, а именно цвет, поворот, размер и тени – берём из фигмы (задать им обязательно размер, чтобы они в принципе отображались на странице). Обязательно позиционируем их абсолютно на странице (топ и лефт определяем экспериментальным способом). И так же не забываем указать им правильный z-index
![](_png/b1b3156641596f3083eba1e006d57c06.png)![](_png/ba81ab25b6632e7c80debe0f2e4f9286.png)
### **5.9 Что такое иконочные шрифты**

- И далее воспользуемся сервисом, который предоставляет иконки в виде шрифтов. Первым делом добавим js код к нам после стилей
![](_png/964096cf97f965300ffb176fe622e361.png)![](_png/35eaca88d2ddc52ad417308743eb7ebf.png)
- Далее находим нужную иконку и копируем её код в наш блок
![](_png/3f9acd8a7ad242e44b8c14b351c637c7.png)![](_png/bdb41f65d40c757324176049084dbb54.png)
- Основной особенностью этих иконок является то, что они представляют собой текст и редактируются как текст, но так как мы поместили их в блочные элементы, то и работать мы будем с текстом в блоках
![](_png/eecfbf5bd04987dde0a5a6d0c7e02add.png)
- Далее опишем бордеры для наших иконок (высота, ширина **блока**, бордер и закругление)
![](_png/72cbc24c9d772f1c9e3c22bbe88355e9.png)![](_png/d79bee6b7d2d6d1f4e7cebd171edc166.png)
- Далее к нашему контейнеру применим расположение объектов в ряд (левый и правый враппер будут находиться в одной строке)
![](_png/dbabcef708a560defff4afb662efa2de.png)![](_png/6f1f03244955322f81360f04a8ed3db6.png)
- Две эти записи идентичны и дают одинаковый результат. Однако стоит пользоваться первым способом для выравнивания только мелких объектов. Выравнивать целые блоки (например, наш правый и левый враппер) не стоит, так как могут возникнуть конфликты с тем же марджином (у нашего контейнера может обнулиться марджин, выравнивающий его по центру страницы)
![](_png/1b325ffad48a653044b139b04b6c650f.png)![](_png/63d7fa94b7cb1d67bce5937427f9a88a.png) ![](_png/51308c9bd7400380d1724e550ff76809.png)
- Данный код позволит выровнять иконки (текст) внутри блоков по центру
![](_png/d62dfbcc301dfd206351fd23c0dc5142.png)![](_png/407e5585c175ef9d958d7ec0358f5e46.png)
- Через фонт-сайз меняем размер иконки (так как она - текст). Ну и делаем отступы между иконками
![](_png/74075ac55699a89a1e92ecb42a1783db.png)![](_png/4c3b9901f0044310c58c65ad3f3f1c2f.png)
### **5.10 Создаем первую кнопку**

- В первую очередь под нашими социальными сетями прописываем новый заголовок и прямо внутри заголовка можно прописать тег hr. Далее основная наша проблема: позиционирование элементов, а именно – текстовый блок над фотографией. Делается это через накидывание релэйтива на нашего родителя и через абсолют на наш райт-враппер (так же допишем ширину блока и положение от абсолюта)
![](_png/eeb0b358412374d419f2c89b649f39f2.png)![](_png/88fab6b6a2499aec1fdf456df1508af3.png)![](_png/bd2b18e10cf2dc01c4e44bb2cc0eb38d.png) 
- Чтобы оттолкнуть иконки от блока райт-враппер, можно сделать внутренний паддинг. Так же нам нужно оттолкнуть текст от иконок, но уже через марджин-боттом
![](_png/cf37dff76892079a8122455a180c3225.png)![](_png/ef3f449cda581b458f6de47627b74050.png)
- Сам тайтл уже преобретает больший шрифт и релэйтив позиционирование, так как нужно указать положение hr относительно нашего текста. Hr указываем позиционирование, ширину, положение снизу, уберём марджины, сбросим внешний вид линии и с одной стороны настраиваем линию (потому что если будем менять через просто бордер, то у нас задастся по всем 4ём сторонам он)
![](_png/5ad11f376ce25e8a2903ccbd7d17f6a0.png)![](_png/41608fb14346785059aff70e324138ca.png)
- Текст под тайтлом добавляем с небольшим отступом от нашего основного тайтла. В качестве отталкивающего элемента мы выбираем бэм-блок (стилизуем все элементы через модификаторы)
![](_png/83e4f78c462fb01de3492acefa75bd2a.png)![](_png/4f355ba83c12dde1dde6039c0a86f57b.png)
- И таким образом мы выравниваем кнопки и элементы внутри них в линию
![](_png/b9ced27c650f8df0f6156703bcaf6df6.png)![](_png/71646927cec73eff2f1957a3fb29e509.png)
- Далее мы стилизуем нашу кнопку
![](_png/1fa61914ff8455c77eccddf5e09c61ca.png)![](_png/5015f1cb82811226bcf98ee5517b681f.png)
- Выравниваем, отодвигаем
![](_png/eb00ff2720d8ff242a1d3e1f8ac821e4.png)![](_png/ba729d2e65023c25324aaa47b32dd291.png)
### **5.11 Используем модификатор БЭМ. Новое свойство overflow**

- Тут мы уже вспомним про использование модификаторов БЭМ. Стилизация и БЭМизацция элементов.

В основных стилях мы описали размеры, градиент и закругление блока. Выравнивание сделали для внутреннего круга (который имеет цвет фона), который будет у нас отвечать за вырез в круге.

Первым делом мы создали первый блок кругов внутри контент-контейнера (располагаются под текстом).

Второй уже блок кругов мы расположили в мэйн-секшн, который отвечает впринципе за все элементы в основном блоке. 
![](_png/c4cd313b56fbeac2ef633bc14fbee926.png)
- Данный фрагмент кода отвечает за позиционирование круговых элементов на сайте. Спозиционировали круги мы относительно нашей основной секции на странице
![](_png/cb2a44fa2443fd5ca9e2a0d7809edd27.png)
- Так же дополнительно стоит обратить внимание, что при изменении ширины страницы, у нас появляется данное выползание круга из-за границы. Это нужно исправлять
![](_png/516ee8781bea768c3cf89a020368a4d2.png)
- **Важно!** Существует такая инструкция как overflow, которая регулирует отображение элементов за краями блока. С помощью данной инструкции мы можем скрыть всё, что находится вне блока
![](_png/9cff3481c90c45e641aac9f621f8e3bf.png)![](_png/fb7152012483acc29ebd45e9be141680.png)
### **5.12 MinMax – HeightWidth**

- Тут представлен код с max-width. Данный пераметр указывает, что максимально размер элемента может растянуться до 1000 пикселей, но при уменьшении страницы, он будет уменьшаться
![](_png/62d74e10716d9e8e48077dfcfe7953fd.png)![](_png/943f1c4c78dae8f5f74144ed2b9f502a.png)
- Это уже работа min-width. Минимально – 1000 пикселей, но растягивается до максимального значения
![](_png/1a9826d2f16cfcc9c6d65de468cf0add.png)
- Но как мы можем увидеть, если наш элемент помещается в максимум 1000 пикселей, то он может и не вместиться в родительский элемент
![](_png/7b223956fc28f5b0be2fa97afb1ffd8c.png)![](_png/9f960dd5fbdb819720e0ef423a4dc775.png)
- Но так же минимальную высоту можно установить и для родительского элемента и тогда он будет размером с занимаемое пространство с два этих бокса
![](_png/96e643cdb723ea006c4d6ca2853b6ffd.png)![](_png/bf4fcd1ea51707ea7c1db7991ba09582.png)
- Такой подход с размерами для элементов страницы нужен, например, чтобы не угадывать с размерами блоков сайта. Потому что заказчик может вместо текста рыбы вставить свой текст
![](_png/3b758b8f9fa99218899e41f61bacbe30.png)
### **5.13 Практика. Создаем вторую секцию сайта**

- **Лайфхак!** Так же в браузере есть интересный лайфхак, который позволяет в реальном времени двигать объекты на странице, что позволяет их нормально спозиционировать без подгадываний и высчитываний
![](_png/116c70e340c31b98e9abb5cc7cbc9c19.png)
- А чтобы быстро найти класс, не забываем пользоваться поиском
![](_png/b586d37e6922f4f8f16223aa8c1f2ede.png)
- Секции лучше именовать секциями
![](_png/61f8e7589bc3fcc721594648d7d36771.png)
- Перед использованием изображений, лучше их кропнуть и потом выгрузить в таком формате
![](_png/641b3a1b72d97f9895912ccdc95d149c.png)
- Пример структуры:
![](_png/ed82ec2d0d7a2dcb0ab1e45180225720.png)![](_png/1dc472f8f317c931c9ee173e51f32270.png)
- **Лайфхак!** Так же в консоли разработчика имеется подсказка флекс-расположений. Если на неё нажать, то можно выбрать предустановки отступов и посмотреть на них, что крайне удобно
![](_png/1bacefab1e50cf230ffddf66a8a9a2f2.png)![](_png/b5225e233a5ad544b69d86bdfd9cab23.png)
- Так же если нам нужно сделать равномерное расстояние между объектами (без привязки к margin-right), то можно воспользоваться данным свойством
![](_png/612a55cfd71a0ba541507b3bd570a6b2.png)![](_png/e3b33f93deebf9104dbe703d2142a5ea.png)
### **5.14 Практика. Создаем третью секцию сайта**

- Небольшое пояснение. Если мы хотим расположить абсолютно-спозиционированный элемент под обычным, то нам достаточно просто указать «z-index: -1». Однако если у нас прописан бэкграунд, то родительскому элементу нужно указать не просто релативную позицию, но и указать «z-index: 0»
![](_png/5e751934903ffa729d4ca4977381cec8.png)
### **5.15 Практика. Создаем footer сайта**

- Сейчас нужно пояснить за структуру и почему стоит пихать высоту блока в контейнер, если мы выравниваем положение через флексы всего одного элемента. Дело в том, что фотографию тут мы абсолютно спозиционировали и теперь нам нужно отодвинуть один текстовый блок в бок и если мы не зададим высоту внутри блока, то он будет иметь размеры сугубо равные нашему текстовому блоку
![](_png/1547ced23115c817fb2d30e74cdb7690.png)![](_png/d09446f40b38f9ac0f5eb3a47ba1fe4f.png)
- Ну и так же можно подключить шрифты таким способом
![](_png/329274b3244c39f9d56188de455d4554.png)
### **5.16 Добавляем якорные ссылки на навигационное меню**

- Якорные ссылки добавляются через id элемента и позволяют создать связь между ссылкой и элементом на странице
![](_png/4495b5c968ed23b85db0c7dbd8ede7c1.png)![](_png/9ff8cb3b48eb989b0e49b7a296559334.png)
### **5.17 Что такое fav-icons, и как их установить в свой проект**

- Фавиконки генерируются из изображений 512 на 512 пикселей.
![](_png/396d57ecee5eb7cb3b260cee3cf2db47.png)![](_png/dfeb6797329b51ec9c7cfffac561c824.png)
-  И подключаются через линки
![](_png/bd5fc2d152ff31c9f4e79678c681201f.png)