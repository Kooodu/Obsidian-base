
## 29 Модальное окно. Portal

Далее нужно реализовать модальное окно в приложении. 

Первым делом нужно создать для него портал, который будет рисовать модальное окно из другой части приложения (конкретно нужно, чтобы портал рисовался вне контента - в `body`)

Пропсы:

`src / shared / ui / Portal / ui / Portal.props.ts`
```TS
import { ReactNode } from 'react';  
  
export interface IPortalProps {  
    /** компонент, который будет отрисовываться */  
    children: ReactNode;  
    /** конечная точка, в которой он должен отрисоваться */  
    element?: Element | DocumentFragment;  
}
```

Сам портал, который работает за счёт функции `createPortal`

`src / shared / ui / Portal / ui / Portal.tsx`
```TSX
import { createPortal } from 'react-dom';  
import { IPortalProps } from './Portal.props';  
  
/** портал для рендера компонентов в отдельных частях приложения */  
export const Portal = ({ children, element = document.body }: IPortalProps) =>  
    createPortal(children, element);
```

Далее уже реализуем хук для работы модалки. Хук используется для того, чтобы сделать логику раскрытия переиспользуемой.

`src / shared / lib / hooks / useModal.tsx`
```TSX
import React, {  
    MouseEventHandler,  
    MutableRefObject,  
    useCallback,  
    useEffect,  
    useRef,  
    useState,  
} from 'react';  
  
interface IModalProps {  
    /** начальное состояние модального окна */  
    isOpened?: boolean;  
}  
  
interface IModalResult {  
    /** реф на модальное окно */  
    modalRef: MutableRefObject<HTMLDivElement | null>;  
    /** функция открытия модального окна */  
    handleOpenModal: () => void;  
    /** состояние модального окна */  
    modalExpanded: boolean;  
    /** функция, которая останавливает всплытие события */  
    stopPropagation: MouseEventHandler<HTMLDivElement>;  
}  
  
/** хук логики модального окна */  
export const useModal = ({ isOpened = false }: IModalProps = {}): IModalResult => {  
    /** состояние отображения модального окна */  
    const [modalExpanded, setModalExpanded] = useState<boolean>(isOpened);  
  
    /** реф, от которого и будет работать закрытие модального окна */  
    const modalRef: MutableRefObject<HTMLDivElement | null> = useRef<HTMLDivElement | null>(null);  
  
    /** функция для изменения состояния окна */  
    const handleOpenModal = useCallback(() => setModalExpanded((prevState) => !prevState), []);  
    /** останавливает всплытие события */  
    const stopPropagation: MouseEventHandler<HTMLDivElement> = useCallback(  
       (e: React.MouseEvent<HTMLDivElement>) => e.stopPropagation(),  
       [],  
    );  
    /** функция закрытия модалки на Esc */  
    const onKeyDown = useCallback((e: KeyboardEvent) => {  
       if (e.key === 'Escape') {  
          setModalExpanded(false);  
       }  
    }, []);  
    /** отлавливает событие закрытия окна и закрывает модалку */  
    const handleModalClick = useCallback((event: MouseEvent) => {  
       if (modalRef.current && !modalRef.current?.contains(event.target as Node)) {  
          setModalExpanded(false);  
       }  
    }, []);  
  
    useEffect(() => {  
       document.addEventListener('click', handleModalClick);  
  
       if (modalExpanded) {  
          document.addEventListener('keydown', onKeyDown);  
       }  
  
       return () => {  
          document.removeEventListener('click', handleModalClick);  
          document.removeEventListener('keydown', onKeyDown);  
       };  
    }, [handleModalClick, modalExpanded, onKeyDown]);  
  
    return {  
       modalRef,  
       handleOpenModal,  
       modalExpanded,  
       stopPropagation,  
    };  
};
```

Пропсы модалки:

`src / shared / ui / Modal / ui / Modal.props.ts`
```TSX
import { ReactNode } from 'react';  
  
export interface IModalProps {  
    /** триггер открытия модалки */  
    label: ReactNode;  
    /** контент модалки */  
    content: ReactNode;  
    /** начальное состояние модалки */  
    isOpened?: boolean;  
}
```

Само модальное окно уже работает за счёт хука модалки. Тут остаётся только проанимировать открытие и закрытие модалки через сторонние библиотеки для анимации компонентов

`src / shared / ui / Modal / ui / Modal.tsx`
```TSX
import React from 'react';  
import { useModal } from '@/shared/lib';  
import { Card } from '../../Card';  
import { Portal } from '../../Portal';  
import styles from './Modal.module.scss';  
import { IModalProps } from './Modal.props';  
  
export const Modal = ({ content, label, isOpened = false }: IModalProps) => {  
    const { modalRef, modalExpanded, handleOpenModal, stopPropagation } = useModal({ isOpened });  
  
    return (  
       <div ref={modalRef} className={styles.modal}>  
          <div onClick={handleOpenModal}>  
             <span className={styles.modal__label}>{label}</span>  
             {modalExpanded && (  
                <Portal>  
                   <div onClick={handleOpenModal} className={styles.modal__overlay}>  
                      <Card onClick={stopPropagation} className={styles.modal__content}>  
                         {content}  
                      </Card>  
                   </div>  
                </Portal>  
             )}  
          </div>  
       </div>  
    );  
};
```

## 30 Redux-toolkit. Entity. Тесты на всех уровнях МЕТКА







## 31 Исправляем глобальные стили для Modal







## 31.1 Json server. Имитация бэкенда







## 32 Кастомный Input. Окно авторизации. Lazy modal МЕТКА







## 33 Husky. Pre commit хуки







## 34 Авторизация. Reducers, slices, async thunk. Custom text МЕТКА















