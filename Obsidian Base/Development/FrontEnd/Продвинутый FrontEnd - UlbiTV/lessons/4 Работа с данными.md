
## 29 Модальное окно. Portal

Далее нужно реализовать модальное окно в приложении. 

Первым делом нужно создать для него портал, который будет рисовать модальное окно из другой части приложения (конкретно нужно, чтобы портал рисовался вне контента - в `body`)

Пропсы:

`src / shared / ui / Portal / ui / Portal.props.ts`
```TS
import { ReactNode } from 'react';  
  
export interface IPortalProps {  
    /** компонент, который будет отрисовываться */  
    children: ReactNode;  
    /** конечная точка, в которой он должен отрисоваться */  
    element?: Element | DocumentFragment;  
}
```

Сам портал, который работает за счёт функции `createPortal`

`src / shared / ui / Portal / ui / Portal.tsx`
```TSX
import { createPortal } from 'react-dom';  
import { IPortalProps } from './Portal.props';  
  
/** портал для рендера компонентов в отдельных частях приложения */  
export const Portal = ({ children, element = document.body }: IPortalProps) =>  
    createPortal(children, element);
```

Далее уже реализуем хук для работы модалки. Хук используется для того, чтобы сделать логику раскрытия переиспользуемой.

`src / shared / lib / hooks / useModal.tsx`
```TSX
import React, {  
    MouseEventHandler,  
    MutableRefObject,  
    useCallback,  
    useEffect,  
    useRef,  
    useState,  
} from 'react';  
  
interface IModalProps {  
    /** начальное состояние модального окна */  
    isOpened?: boolean;  
}  
  
interface IModalResult {  
    /** реф на модальное окно */  
    modalRef: MutableRefObject<HTMLDivElement | null>;  
    /** функция открытия модального окна */  
    handleOpenModal: () => void;  
    /** состояние модального окна */  
    modalExpanded: boolean;  
    /** функция, которая останавливает всплытие события */  
    stopPropagation: MouseEventHandler<HTMLDivElement>;  
}  
  
/** хук логики модального окна */  
export const useModal = ({ isOpened = false }: IModalProps = {}): IModalResult => {  
    /** состояние отображения модального окна */  
    const [modalExpanded, setModalExpanded] = useState<boolean>(isOpened);  
  
    /** реф, от которого и будет работать закрытие модального окна */  
    const modalRef: MutableRefObject<HTMLDivElement | null> = useRef<HTMLDivElement | null>(null);  
  
    /** функция для изменения состояния окна */  
    const handleOpenModal = useCallback(() => setModalExpanded((prevState) => !prevState), []);  
    /** останавливает всплытие события */  
    const stopPropagation: MouseEventHandler<HTMLDivElement> = useCallback(  
       (e: React.MouseEvent<HTMLDivElement>) => e.stopPropagation(),  
       [],  
    );  
    /** функция закрытия модалки на Esc */  
    const onKeyDown = useCallback((e: KeyboardEvent) => {  
       if (e.key === 'Escape') {  
          setModalExpanded(false);  
       }  
    }, []);  
    /** отлавливает событие закрытия окна и закрывает модалку */  
    const handleModalClick = useCallback((event: MouseEvent) => {  
       if (modalRef.current && !modalRef.current?.contains(event.target as Node)) {  
          setModalExpanded(false);  
       }  
    }, []);  
  
    useEffect(() => {  
       document.addEventListener('click', handleModalClick);  
  
       if (modalExpanded) {  
          document.addEventListener('keydown', onKeyDown);  
       }  
  
       return () => {  
          document.removeEventListener('click', handleModalClick);  
          document.removeEventListener('keydown', onKeyDown);  
       };  
    }, [handleModalClick, modalExpanded, onKeyDown]);  
  
    return {  
       modalRef,  
       handleOpenModal,  
       modalExpanded,  
       stopPropagation,  
    };  
};
```

Пропсы модалки:

`src / shared / ui / Modal / ui / Modal.props.ts`
```TSX
import { ReactNode } from 'react';  
  
export interface IModalProps {  
    /** триггер открытия модалки */  
    label: ReactNode;  
    /** контент модалки */  
    content: ReactNode;  
    /** начальное состояние модалки */  
    isOpened?: boolean;  
}
```

Само модальное окно уже работает за счёт хука модалки. Тут остаётся только проанимировать открытие и закрытие модалки через сторонние библиотеки для анимации компонентов

`src / shared / ui / Modal / ui / Modal.tsx`
```TSX
import React from 'react';  
import { useModal } from '@/shared/lib';  
import { Card } from '../../Card';  
import { Portal } from '../../Portal';  
import styles from './Modal.module.scss';  
import { IModalProps } from './Modal.props';  
  
export const Modal = ({ content, label, isOpened = false }: IModalProps) => {  
    const { modalRef, modalExpanded, handleOpenModal, stopPropagation } = useModal({ isOpened });  
  
    return (  
       <div ref={modalRef} className={styles.modal}>  
          <div onClick={handleOpenModal}>  
             <span className={styles.modal__label}>{label}</span>  
             {modalExpanded && (  
                <Portal>  
                   <div onClick={handleOpenModal} className={styles.modal__overlay}>  
                      <Card onClick={stopPropagation} className={styles.modal__content}>  
                         {content}  
                      </Card>  
                   </div>  
                </Portal>  
             )}  
          </div>  
       </div>  
    );  
};
```

## 30 Redux-toolkit. Entity. Тесты на всех уровнях МЕТКА





## 31.1 Json server. Имитация бэкенда

Устанавливаем зависимости для поднятия искуственного бэк-сервера

```bash
npm install --save-dev json-server nodemon ts-node @types/json-server @types/nodemon
```

Добавим немного моковых данных в наш сервер

`server / db.json`
```JSON
"users": [  
    {  
       "id": "1",  
       "username": "admin",  
       "password": "123",  
       "roles": [  
          "ADMIN"  
       ],  
       "features": {  
          "isArticleRatingEnabled": true,  
          "isCounterEnabled": true,  
          "isAppRedesigned": true  
       },  
       "avatar": "https://mobimg.b-cdn.net/v3/fetch/22/2207633df03a819cd72889249c8361a8.jpeg?w=1470&r=0.5625",  
       "jsonSettings": {  
          "isArticlesPageWasOpened": true,  
          "theme": "app_dark_theme"  
       }  
    },
...
```

Далее нам нужно будет сгенерировать пару сертификатов, чтобы у нас была возможность поднять https-бэк

![|500](_png/Pasted%20image%2020231202204003.png)

Настройка `json-server`, которая позволит нам имитировать настоящий сервер

`server / index.ts`
```TS
import fs from 'fs';  
import http from 'http';  
import https from 'https';  
import path from 'path';  
import jsonServer from 'json-server';  
import { IUser } from './types/user.interface';  
  
/**  
 * Сертификаты для https-сервера * 
 * */
const options = {  
    key: fs.readFileSync(path.resolve(__dirname, 'key.pem')),  
    cert: fs.readFileSync(path.resolve(__dirname, 'cert.pem')),  
};  
  
/**  
 * инстанциируем json-сервер * 
 * */
const server = jsonServer.create();  
  
/**  
 * инстанциируем роутер по файлу с данными
 * */
const router = jsonServer.router(path.resolve(__dirname, 'db.json'));  
  
server.use(jsonServer.defaults({}));  
server.use(jsonServer.bodyParser);  
  
/**  
 * Для имитации "реального" апи добавлена небольшая задержка для возврата данных 
 * */
server.use(async (req, res, next) => {  
    await new Promise((res) => {  
       setTimeout(res, 800);  
    });  
    next();  
});  
  
/**  
 * эндпоинт авторизации пользователя * 
 * */
server.post('/login', (req, res) => {  
    try {  
       const { username, password } = req.body;  
       const db = JSON.parse(  
          fs.readFileSync(path.resolve(__dirname, 'db.json'), { encoding: 'utf-8' }),  
       );  
       const { users = [] } = db;  
  
       const userFromBd = users.find(  
          (user: IUser) => user.username === username && user.password === password,  
       );  
  
       if (userFromBd) {  
          return res.json(userFromBd);  
       }  
  
       return res.status(403).json({ message: 'User not found' });  
    } catch (e) {  
       if (e instanceof Error) {  
          console.log(e);  
          return res.status(500).json({ message: e.message });  
       }  
    }  
});  
  
/**  
 * гуард авторизации пользователя * просто проверяет заголовки авторизации пользователя в запросе
 * */
server.use((req, res, next) => {  
    if (!req.headers.authorization) {  
       return res.status(403).json({ message: 'AUTH ERROR' });  
    }  
  
    next();  
});  
  
server.use(router);  
  
/**  
 * старт сервера
 */
const HTTPS_PORT = 8443;  
const HTTP_PORT = 8000;  
  
const httpsServer = https.createServer(options, server);  
const httpServer = http.createServer(server);  
  
httpsServer.listen(HTTPS_PORT, () => {  
    console.log(`https server is running on ${HTTPS_PORT} port`);  
});  
  
httpServer.listen(HTTP_PORT, () => {  
    console.log(`http server is running on ${HTTP_PORT} port`);  
});
```

Минимальный список интерфейсов, которые нужно описать для пользователя

`server / types / user.interface.ts`
```TS
/** список пользователей */  
export interface IUserList {  
    users: IUser[];  
}  
  
/** интерфейс пользователя */  
export interface IUser {  
    id: string;  
    username: string;  
    password: string;  
    roles: string[];  
    features: IFeatures;  
    avatar: string;  
    jsonSettings?: IJsonSettings;  
}  
  
/** список фич, которые активировал пользователь */  
export interface IFeatures {  
    isArticleRatingEnabled: boolean;  
    isCounterEnabled: boolean;  
    isAppRedesigned?: boolean;  
}  
  
/** настройки пользователя */  
export interface IJsonSettings {  
    isArticlesPageWasOpened: boolean;  
    theme?: string;  
}
```

Команда поднятия сервера

`package.json`
```JSON
"start:dev:server": "nodemon ./server/index.ts",
```


## 32 Кастомный Input. Окно авторизации. Lazy modal МЕТКА







## 33 Husky. Pre commit хуки

Плагин husky будет за нас выполнять какие-либо простые операции до того, как мы зальём изменения в ветку.

Для начала нужно будет проинициализировать хаски:

```bash
npx husky-init
```

Далее нужно будет добавить наши npm-скрипты

`.husky / pre-commit`
```bash
#!/usr/bin/env sh  
. "$(dirname -- "$0")/_/husky.sh"  
  
npm run lint:fix:all  
npm run test:unit  
npm run storybook:build  
npm run test:ui:ci
```

## 34 Авторизация. Reducers, slices, async thunk. Custom text МЕТКА















