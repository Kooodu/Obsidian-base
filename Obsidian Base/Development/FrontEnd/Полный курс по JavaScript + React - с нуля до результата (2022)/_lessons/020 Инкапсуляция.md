
Вот пример функции-конструктора, который создаёт нам персонажа. Тут мы легко можем поменять переменные внутри пользователя

![](_png/058b50130f6da2fb07a1a0e1ad643625.png)

Однако если мы создадим переменную, то она станет недоступна для просмотра извне, но останется вполне себе изменяемой

![](_png/830714e34b98f8de204df25d88a443e5.png)

Дальше у нас идут собственные геттеры и сеттеры. Это методы, которые реализуют наш вывод данной переменной во внешнюю среду

![](_png/1553177f6e26656088f026eee2688aed.png)

Так же мы можем переписать наш код на классы. Однако тут встаёт проблема, которая запрещает нам использовать простые переменные в конструкторе (`let`) и теперь опять наши переменные можно просто увидеть и изменить извне без геттеров и сеттеров

![](_png/701bd14201e316b8023f0550d55d7808.png)

По соглашению о наименовании переменных, если переменная начинается с нижнего подчёркивания (например, `_age`), то эту переменную **нельзя** изменять

![](_png/638b9026cd32c56ec36716e80786dd9f.png)

И вот через сеттер age мы можем добавить нужное нам значение возраста

![](_png/ad7b47f8c0c0e813e97db4870ae42161.png)

Однако у нас до сих пор есть возможность менять переменную, которую мы можем получить через геттеры и сеттеры. Есть возможность инкапсулировать значения полностью, но это уже экспериментальная технология

Так же можно инкапсулировать нормально значения в TypeScript

![](_png/94f119bd61095ffcc94082c97c67616a.png)

Через решётку создаётся приватное поле класса. Оно создаётся вне конструктора, чтобы можно было обратиться к нему везде.

Так же он выполняет нужную нам функцию – не выходит за пределы класса. Его можно только просмотреть через метод (при обычном вызове будет `undefined`). Поменять извне – не получится

![](_png/36db91dedd00d3015b2495c1aaf4b182.png)

И вот реализация геттера и сеттера для приватного поля класса

![](_png/a9f0571f65cd919de6a7a08c6adc037c.png)