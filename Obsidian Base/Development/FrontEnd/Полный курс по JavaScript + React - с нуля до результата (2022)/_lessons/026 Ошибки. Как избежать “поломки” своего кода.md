
Для обработки ошибок у нас существует стандартная конструкция `try-catch`. Внутрь него вкладываем код, который подозреваем на ошибку и в блоке `catch` пишем обработку нашей ошибки. Так же этот блок принимает в себя параметр ошибки. Из самой ошибки мы можем получить имя, сообщение и стек ошибки. 
Ну и блок `finally`, который необязателен, но позволяет выполнить логику, которая должна обязательно произойти

```JS
try { // проверяемый блок кода
    console.log('work');
    throw new Error('Some error');
} catch(e) { // Если ошибка
    console.log(e.name + ' - error name');
    console.log(e.message + ' - error message');
    console.log(e.stack + ' - error stack');
} finally { // блок кода, который выполняется в любом случае
    // Завершаем какую-то операцию
}

console.log('that\'s works!');
```
![](_png/14301cdf6422498eb4588ef9933ede54.png)

Для чего, например, может использоваться такой подход в повседневной работе?
У нас есть функция, которая подключена сразу к двум документам. Эта функция из одного из них берёт информацию и обрабатывает её. Если на первой странице всё будет нормально, то на второй выйдет ошибка и код дальше работать не будет. 

![](_png/ed9c57d452d163361c04cae75c4b0823.png)

Уже с таким кодом ничего не будет падать и мы спокойно сможем работать одним скрипт-файлом на нескольких страницах

![](_png/d04cd9c96b243b657f8f3e0015ba39b7.png)