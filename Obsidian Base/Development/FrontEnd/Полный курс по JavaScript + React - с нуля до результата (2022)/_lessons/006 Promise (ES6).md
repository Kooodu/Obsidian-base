
`Promise` (обещание) – это блок кода, который будет выполняться асинхронно относительно другого кода. Промис позволяет избежать **collback-hell** ситуации, когда у нас огромное количество таймаутов и вложенных функций

Это код через `setTimeout`, который не гарантирует нам 100% на выполнение кода и может выдать ошибку

![](_png/e644e24ce96e0d35e3713a702d5ddb3b.png)

И коротко о том, что такое промисы. Они позволяют реализовать код, который обещают выполнить асинхронно относительно остального кода – они не останавливают выполнение основного потока кода и выполняются параллельно

Промисы создаются через конструктор. Внутрь промиса вкладывается функция, которая принимает в себя два аргумента – `resolve` и `reject`, которые тоже являются функциями. Обе вложенные функции отвечают за возврат значения в разных ситуациях.

`resolve` – возвращает значение, когда функция выполнилась успешно  
`reject` – возвращает значение, когда функция выполнилась с ошибкой

Дальше идёт уже чейновая природа обработки промиса. Мы пишем имя промиса и `then().(много then).catch().(много catch).finally()`. Каждый чейн выполняет свою работу, которую мы для него пропишем. **then** срабатывает, когда `Promise` завершается резолвом и так же резолв передаёт своё значение в этот `then`. `catch` срабатывает, когда промис завершается реджектом и реджект так же передаёт вписанное в него значения в этот `catch`

![](_png/d785225dbef595bbce0608aecffb07ff.png)

И опять же про природу чейнов. Мы могли бы полностью прописывать промисы внутри thenов и создавать всё новые и новые промисы. Однако из thenов мы можем возвращать промисы (будет возвращаться значение внутри резолва или реджекта) и данные будут передаваться дальше по цепочке (выполнилось – передалось дальше и так бесконечно)

![](_png/78de95accb68aa5038382c667061a80b.png)
![](_png/9c75f207efc687f334c1dc670144dd24.png)

И основной преймущество, из-за которого мы используем промисы – это их чейновое выполнение. Конкретно тут выполняется сначала первый промис, потом резолв возвращает в then объект. Внутри первого чейна создаём новый промис, который у нас возвращается через ретёрн (возвращается то, что передаёт резолв при выполнении промиса). Дальше у нас идут ещё два чейна, которые выполняют действия последовательно друг за другом

![](_png/e6c78f252f4ac85d7e929962fd303ce5.png)

И если у нас выполняется в конце промиса `reject`, то блок кода чейнится в `catch` (вместо `then`)

![](_png/0d3758ce38ad6bc4e868e12fdfb17350.png)

Чейн `finally` срабатывает при любом исходе промиса (`reject`/`resolve`) и всегда добавляется в конец

![](_png/fe6e27dd49875f86f467a855aeada971.png)

Тут пример небольшого промиса для следующих двух методов

![](_png/b49cd1874c391ac5070bac0ee2d0ede7.png)

И далее идёт так же важная команда, которая позволяет реализовать выполнение кода при выполнении сразу нескольких промисов - `Promise.all`. Например, мы отправили запрос на несколько разных серверов и нам обязательно нужно, чтобы выполнились сразу все нужные запросы

![](_png/4f7830ecf259f20a771984fa3ef908be.png)

И так же есть метод, который выполняется сразу при выполнении первого промиса – `Promise.race()`

![](_png/191458a426d45fbe9200628acfdd3e05.png)