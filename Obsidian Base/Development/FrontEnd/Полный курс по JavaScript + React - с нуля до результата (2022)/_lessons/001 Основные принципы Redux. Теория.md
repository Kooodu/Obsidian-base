
Работа с динамическими данными и со стейтом - это одна из основных задач разработчика. Если логика изменения данных написана правильно, то и их отображение будет несложной задачей.

Первое приложение у нас выглядит следующим образом:
- Все данные хранились в одном компоненте
- Все данные передавались по иерархии вниз, а изменения состояния передавались вверх через коллбэки
- Так же все состояния централизованы (они все находились в одном месте - в компоненте `App`)

Такой подход называется ==Property Drill==, когда мы просверливаем пути для передачи состояний по уровням через несколько компонентов. Такой подход не является достаточно логичным, так как некоторые компоненты могут хранить в себе ненужные для них состояния, которые мы просто перебрасываем дальше.

Второе приложение выглядит уже следующим образом:
- Каждый компонент хранит своё состояние у себя (один компонент содержит список персонажей, а другой список комиксов, третий содержит информацию об одном конкретном персонаже и так далее)

Такой подход сложно масштабировать, особенно, если появятся зависимости между компонентами

![](_png/7c3274e3c09c1f2ef3d1087d21826e83.png)

Чтобы решить вышеописанные проблемы, были придуманы определённые паттерны для работы с состояниями продуктов, такие как ==MVC==, ==MVP==, ==MVVM==

![](_png/bdfd2647518b0b1998c80d6d043e1a13.png)

И чтобы решить проблему со сложными зависимостями, можно создать один большой источник стейтов для всех компонентов. Однако тут мы сталкиваемся с проблемой, что каждый компонент может поменять наш глобальный стейт

![](_png/87f733b02e665518085856aa2af1fb9e.png)

И чтобы решить уже вышеописанную проблему, был придуман следующий подход:
- Мы имеем наши компоненты **View**, которые при выполнении какого-либо действия создают **Actions** (который уже знает, что нужно обновить в стейте)
- Определённые события **Actions** (которые хранят информацию о требуемых изменениях) вызывают срабатывание определённых действий в компоненте **Reducer** (который уже знает, как именно обновить этот стейт). Операция передачи объекта **Actions** в **Reducer** называется ==dispatch==
- Компонент **Reducer** - это компонент, который находится в общем хранилище стейтов и он знает, что делать при любом запросе от компонентов сайта. То есть он регулирует обновление стейтов внутри **S**, чтобы компоненты могли перерисоваться на базе обновлённых данных
- Компонент **S** так же находится внутри хранилища и сам по себе просто хранит все состояния приложения. 

Так же в ==Redux== имеются ==селекторы== - это функции, которые получают часть данных из хранилища для дальнейшего использования (из **S** во **View**)

![](_png/4fb838616d62005505eca2d7c9c6fd3e.png)

И вот так выглядит работа стейт-менеджера на реальном примере. Из `State` прошлые данные приходят в `Reducer`, чтобы сравнить с новыми значениями.

Примерно такой же подход использовался в хуке `useReducer`.

![Гифка работы Redux с официального сайта](https://d33wubrfki0l68.cloudfront.net/01cc198232551a7e180f4e9e327b5ab22d9d14e7/b33f4/assets/images/reduxdataflowdiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif)

И тут важно уточнить, что запутаться в трёх разных документациях легко, поэтому нужно знать. что ищем:

![](_png/9d8ead89c25d29fb062bcef35c46411d.png)

![](_png/5f913d27458a4c0b8176dadfa56d6194.png)

![](_png/adc833e3abda852d1f6f9fe5e8d0cb93.png)

Так же очень важное расширение для работы с редаксом в браузере, которое позволяет просмотреть состояния системы:

![](_png/d25df2e601565b20620b5bb5c6cfd73b.png)