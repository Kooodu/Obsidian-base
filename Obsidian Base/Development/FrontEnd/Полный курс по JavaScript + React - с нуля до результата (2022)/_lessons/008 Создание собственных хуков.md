


```JS
const Form = () => {
	const [text, setText] = useState('');

	return (
		<Container>
			<form className='w-50 border mt-5 p-3 m-auto'>
				<div className='mb-3'>
					<input 
						value={text} 
						type='text' 
						className='form-control' 
						readOnly 
					/>
					<label 
						htmlFor='exampleFormControlInput1' 
						className='form-label mt-3'
					>
						Email address
					</label>
					<input
						onChange={(e) => setText(e.target.value)}
						type='email'
						className='form-control'
						id='exampleFormControlInput1'
						placeholder='name@example.com'
					/>
				</div>
				<div className='mb-3'>
					<label 
						htmlFor='exampleFormControlTextarea1' 
						className='form-label'
					>
						Example textarea
					</label>
					<textarea
						className='form-control'
						id='exampleFormControlTextarea1'
						rows='3'
					></textarea>
				</div>
			</form>
		</Container>
	);
};
```

![](_png/Pasted%20image%2020230312092529.png)



![](_png/Pasted%20image%2020230312093804.png)

![](_png/Pasted%20image%2020230312093813.png)
![](_png/Pasted%20image%2020230312093817.png)



```JS
// первая версия
const validateInput = (text) => {
	if (text.search(/\d/) >= 0) {
		return true;
	}

	return false;
};

// вторая версия
const validateInput = (text) => {
	return text.search(/\d/) >= 0 ? true : false;
};

// третья версия
const validateInput = (text) => {
	return text.search(/\d/) >= 0;
};
```

И сейчас мы добавили в работу ещё одно поле для ввода текста - код был повторён. 
Тут мы сталкиваемся с такой ситуацией, что мы постоянно повторяем код, который написали единожды

```JS
const Form = () => {
	const [text, setText] = useState('');
	const [textArea, setTextArea] = useState('');

	// функция, которая будет валидировать инпут (если символов 0, то вернёт фолс)
	const validateInput = (text) => {
		return text.search(/\d/) >= 0;
	};

	// тут уже будем хранить условие с выбором класса
	const colorInput = validateInput(text) ? 'text-danger' : 'text-success';

	return (
		<Container>
			<form className='w-50 border mt-5 p-3 m-auto'>
				<div className='mb-3'>
					<input
						/* вставляем текст с нескольких инпутов */
						value={`${text} / ${textArea}`}
						type='text'
						/* вставляем класс */
						className={`form-control ${colorInput}``}
						readOnly
					/>
					<label 
						htmlFor='exampleFormControlInput1' 
						className='form-label mt-3'>
						Email address
					</label>
					<input
						onChange={(e) => setText(e.target.value)}
						type='email'
						className='form-control'
						id='exampleFormControlInput1'
						placeholder='name@example.com'
					/>
				</div>
				<div className='mb-3'>
					<label 
						htmlFor='exampleFormControlTextarea1' 
						className='form-label'>
						Example textarea
					</label>
					<textarea
						/* установка нвого состояния */
						onChange={(e) => setTextArea(e.target.value)}
						className='form-control'
						id='exampleFormControlTextarea1'
						rows='3'
					></textarea>
				</div>
			</form>
		</Container>
	);
};
```

![](_png/Pasted%20image%2020230312094900.png)

Таким образом выглядит классический хук. Обычно он возвращает несколько объектов в массиве и сохраняет в себе определённую логику

![](_png/Pasted%20image%2020230312095917.png)

Либо мы можем собрать всю логику хука в отдельную переменную, если возвращать из него объект

![](_png/Pasted%20image%2020230312100110.png)





