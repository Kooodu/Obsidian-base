
Самое первое, что нужно реализовать - это получение данных по персонажу с сервера:
- Метод `_transformCharacter()` принимает в себя данные с сервера и возвращает данные отформатированные под тот формат, что нужно использовать в приложении. Такой подход заменит работу с интерфейсом.
- Методы `getAllCharacters()` и `getCharacter()` модифицируем таким образом, чтобы они как и раньше принимали и сохраняли в себе результат запроса и возвращали во внешние модули только отформатированный запрос через `_transformCharacter()`

`src > services > marvel.service.js`
```JS
class MarvelService {  
   _apiBase = 'https://gateway.marvel.com:443/v1/public/';  
   _apiKey = 'apikey=abfdaba95091affea928543eb9253ded';  
  
   getResource = async (url) => {  
      let res = await fetch(url);  
  
      if (!res.ok) {  
         throw new Error(`Couldn't fetch ${url}, status: ${res.status}`);  
      }  
  
      return await res.json();  
   };  
  
   getAllCharacters = async () => {  
      const res = await this.getResource(  
         `${this._apiBase}characters?limit=9&offset=36&${this._apiKey}`,  
      );  
  
      // тут мы возвращаем массив персонажей, где каждый отдельный элемент массива проходится через трансформацию  
      return res.data.results(this._transformCharacter);  
   };  
  
   // эта функция будет получать одного персонажа по id  
   getCharacter = async (id) => {  
      const res = await this.getResource(`${this._apiBase}characters/${id}?${this._apiKey}`);  
      return this._transformCharacter(res.data.results[0]);  
   };  
  
   // тут мы будем возвращать только ограниченное количество данных при запросе на сервер  
   _transformCharacter = (char) => {  
      return {  
         name: char.name,  
         description: char.description,  
         thumbnail: char.thumbnail.path + '.' + char.thumbnail.extension,  
         homepage: char.urls[0].url,  
         wiki: char.urls[1].url,  
      };  
   };  
}  
  
export default MarvelService;
```

Далее

`src > components > randomChar > RandomChar.js`
```JS
import './randomChar.scss';  
import mjolnir from '../../resources/img/mjolnir.png';  
import { Component } from 'react';  
import MarvelService from '../../services/marvel.service';  
  
class RandomChar extends Component {  
   constructor(props) {  
      super(props);  
      // вызываем функцию обновления при создании компонента  
      this.updateChar();  
   }  
  
   // состояние данных персонажа  
   state = {  
      char: {},  
   };  
  
   // создаём инстанс сервиса для общения с сервером  
   marvelService = new MarvelService();  
  
   // этот метод будет просто менять состояние персонажа  
   onCharLoaded = (char) => {  
      this.setState({ char });  
   };  
  
   // метод, который будет общаться с сервером, получать данные и записывать их в стейт  
   updateChar = () => {  
      // получаем рандомный id персонажа из определённого диапазона  
      // рандом * (маисмум - минимум) + минимум      const id = Math.floor(Math.random() * (1011400 - 1011000) + 1011000);  
  
      // вызываем получение персонажа по id с нашего сервиса и меняем состояние компонента  
      // здесь мы можем вставить просто res, так как мы трансформировали данные в сервисе через _transformCharacter      this.marvelService.getCharacter(id).then(this.onCharLoaded);  
   };  
  
   sliceDescription = (description) => {  
      if (description.length > 150) {  
         return description.slice(0, 150) + '...';  
      }  
      return description;  
   };  
  
   render() {  
      const {  
         char: { name, description, thumbnail, homepage, wiki },  
      } = this.state;  
  
      return (  
         <div className='randomchar'>  
            <div className='randomchar__block'>  
               <img src={thumbnail} alt='Random character' className='randomchar__img' />  
               <div className='randomchar__info'>  
                  <p className='randomchar__name'>{name}</p>  
                  <p className='randomchar__descr'>  
                     {description  
                        ? this.sliceDescription(description)  
                        : 'Данных про данного персонажа нет'}  
                  </p>  
                  <div className='randomchar__btns'>  
                     <a href={homepage} className='button button__main'>  
                        <div className='inner'>homepage</div>  
                     </a>  
                     <a href={wiki} className='button button__secondary'>  
                        <div className='inner'>Wiki</div>  
                     </a>  
                  </div>  
               </div>  
            </div>  
            <div className='randomchar__static'>  
               <p className='randomchar__title'>  
                  Random character for today!  
                  <br />  
                  Do you want to get to know him better?  
               </p>  
               <p className='randomchar__title'>Or choose another one</p>  
               <button className='button button__main'>  
                  <div className='inner'>try it</div>  
               </button>  
               <img src={mjolnir} alt='mjolnir' className='randomchar__decoration' />  
            </div>  
         </div>  
      );  
   }  
}  
  
export default RandomChar;
```

Так же хочется отметить про несколько видов записей функций: если мы просто вставим в функцию вызов другой функции, то вложенная функция вызовется с переданным дефолтным аргументом родительской функции (первой)

```JS
// длинная запись
this.marvelService.getCharacter(id).then((res) => {  
   this.onCharLoaded(res);  
});

// короткая запись
this.marvelService.getCharacter(id).then(this.onCharLoaded);
```



![](_png/Pasted%20image%2020230302183505.png)


И тут нужно сразу сказать, что такой подход, который был описан выше - неправильный. Работать со стейтом, подписываться на события и создавать сервисы при конструировании компонента *является плохой практикой*

![](_png/Pasted%20image%2020230302174723.png)

![](_png/Pasted%20image%2020230302174633.png)




>[!note] Оформление работы с сервером:
> - Если наше приложение взаимодействует с сервером, то сетевую логику нужно отделять от реализации фронтенда
> - В остальных компонентах нужно использовать только результаты работы данного сервиса 


