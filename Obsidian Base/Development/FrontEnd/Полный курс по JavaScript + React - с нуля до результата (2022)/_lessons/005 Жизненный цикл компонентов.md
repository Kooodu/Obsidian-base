
Сейчас воспроизведём одну проблему в работе компонентов:
- переведём компонент `App` в классовый и внутри него создадим возможность удалять компонент со страницы, показывая `null` вместо него

![](_png/08233f1fe0aff596f4d9c6523f168880.png)

- Далее в самом компоненте будем внутри конструктора по интервалу вызвать запрос на получение данных `updateChar`

![](_png/09687b18f0de49e214edbc9ec0adc279.png)

- И несколько раз скроем и покажем компонент

![](_png/cd8213cad9490755c2faa250889da3df.png)

В итоге мы получим ситуацию, когда запрос на получение данных со страницы уходит на просто за раз по два раза (что уже плохо), но так же и компоненты, которые мы насоздавали - не исчезают и продолжают отправлять запросы на сервер, что приводит к отправке более чем двух запросов в секунду. Такой подход создаёт сильную угрозу утечки данных

И тут нам нужно перейти к жизненному циклу компонента, чтобы понять, каким образом у нас происходят данные ошибки 

Жизненный цикл компонента делится на 3 этапа (если не включать состояние ошибки) и предполагает под собой 3 хука этих состояний:
- `componentDidMount` - компонент появляется на странице
- `componentDidUpdate` - компонент обновляется
- `componentWillUnmount` - компонент уходит со страницы

![](_png/f6d74d664646ceb84bffdd21efc2e327.png)

И данную структуру нужно знать:
- Первым этапом у нас идёт монтирование
	- вызывается конструктор
	- после конструктора идёт `render` компонента
	- потом обновляется DOM-дерево
	- и в конце вызывается `componentDidMount`
- Вторым этапом у нас идёт обновление компонента
	- обновление компонента вызвают:
		- изменение пропсов
		- установление нового состояния через `setState()`
		- насильное обновление через `forceUpdate()`
	- И мы опять попадаем в метод `render`, который монтирует наш компонент
	- Дальше обновляется дерево
	- И срабатывает хук `componentDidUpdate`
- Третьим этапом мы просто размонтируем компонент и стираем со страницы
	- тут вызывается хук `componentWillUnmount`

![](_png/51574071a6d629cf8895d3b31e84f280.png)

Расставим на всех контрольных точках приложения логи определённого этапа монтирования компонента

Сейчас закомментируем вызов функции обновления персонажа на странице, чтобы у нас нормально работал компонент. 

```JS
class RandomChar extends Component {  
   constructor(props) {  
      super(props);  
      // this.updateChar();  
      console.log('constructor');  
   }  
  
   componentDidMount() {  
      console.log('mount');  
   }  
  
   componentWillUnmount() {  
      console.log('unmount');  
   }  
  
   state = {  
      char: {},  
      loading: true,  
      error: false,  
   };  
  
   marvelService = new MarvelService();  
  
   onCharLoaded = (char) => {  
      console.log('update');  
      this.setState({ char, loading: false });  
   };  
  
   onError = () => {  
      this.setState({ loading: false, error: true });  
   };  
  
   updateChar = () => {  
      const id = Math.floor(Math.random() * (1011400 - 1011000) + 1011000);  
  
      this.marvelService.getCharacter(id).then(this.onCharLoaded).catch(this.onError);  
   };  
  
   render() {  
      console.log('render');  
  
      const { char, loading, error } = this.state;  
  
      const showError = error ? <ErrorMessage /> : null;  
      const showLoading = loading ? <Spinner /> : null;  
      const showContent = !(error || loading) ? <View char={char} /> : null;  
  
      return (  
         <div className='randomchar'>  
            {showContent}  
            {showLoading}  
            {showError}  
            <div className='randomchar__static'>  
               <p className='randomchar__title'>  
                  Random character for today!  
                  <br />  
                  Do you want to get to know him better?  
               </p>  
               <p className='randomchar__title'>Or choose another one</p>  
               <button className='button button__main'>  
                  <div className='inner'>try it</div>  
               </button>  
               <img src={mjolnir} alt='mjolnir' className='randomchar__decoration' />  
            </div>  
         </div>  
      );  
   }  
}
```

И тут можно увидеть, что компонент рендерится ровно один раз

![](_png/386590e4b1278f340d3b92d1b77b5db9.png)

Но если мы вернём в конструктор данную запись, то можно увидеть, что компонент обновился два раза, что и привело к двойному срабатыванию функции отправки запроса на сервер.

Это происходит потому, что мы обновляем состояние и запрашиваем рендер компонента до того, как он отрендерился в первый раз. Из-за такого наслоения вместо одного рендера происходит перерендер с новым состоянием.

Нам можно использовать обновления состояний компонента **только** на этапе =="commit"==

```JS
constructor(props) {  
   super(props);  
   this.updateChar();  
   console.log('constructor');  
}
```

![](_png/de865b7201b6bd1e6668b9e54c605021.png)

И чтобы поправить ошибку, просто вызовем функцию отправки запроса на сервер на этапе коммита компонента, а именно в методе `componentDidMount()`

```JS
constructor(props) {  
   super(props);  
   console.log('constructor');  
}  
  
componentDidMount() {  
   this.updateChar();  
   console.log('mount');  
}
```

![](_png/e366ddd6d00a6decc59dd2a1ee0d26b7.png)

Ну и чтобы при размонтировании компонента у нас остановился и таймер, нужно останавливать этот таймер на этапе размонтирования компонента

>[!warning] Так же нужно отметить:
>- Что данную отписку нужно выполнять всегда, так как она продолжит работать, даже если мы перейдём на другую страницу (все компоненты уничтожатся, а подписка останется)
>- Что если мы добавили подписку через стандартное DOM-api (например, `addEventListener`), то и удалять эту подписку нужно через DOM-api (тут - `removeEventListener`)

```JS
componentDidMount() {  
   this.updateChar();  
   this.timerId = setInterval(this.updateChar, 3000);  
   console.log('mount');  
}  
  
componentWillUnmount() {  
   clearInterval(this.timerId);  
   console.log('unmount');  
}
```
