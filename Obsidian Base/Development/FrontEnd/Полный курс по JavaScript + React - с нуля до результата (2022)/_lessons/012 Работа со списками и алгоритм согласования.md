
Современные веб-приложения представляют из себя динамически-меняющиеся документы, которые представляются в вебе. То есть мы можем динамически менять элементы на странице в зависимости от действий пользователя.

При изменении структуры документа в реакте, начинает работать алгоритм реконцеляции или [Reconciliation](https://reactjs.org/docs/reconciliation.html). Он представляет из себя полное перерендеривание элемента на странице, что сильно упрощает работу с изменением элементов и их обновлением. 
Этот алгоритм работает рекурсивно и обновляет как сам элемент, так и все вложенные внутри него.
Реакт сохраняет прошлую версию дерева и новую версию дерева (всё находится внутри ==Virtual DOM==). Производит сравнение внутри себя каждого элемента друг с другом и если находит отличия, то производит перерисовку элемента в реальном ДОМ-дереве. То есть перерисовка происходит ровно у тех элементов, которые изменились - остальные остаются нетронутыми. 

Первый вариант:
```JSX
return (  
    <ul className="app-list list-group">  
        {elements}  
    </ul>  
);
```
Пример изменения, при котором произойдёт перерендер:
```JSX
return (  
        <div className="app-list list-group">  
            {elements}  
        </div>  
    );  
}
```

Однако из такого подхода вытекает следующий минус: 
Если мы можем в конец этого же массива добавить новый элемент и реакт его просто дорисует, то если добавить новую строчку в начало массива, то реакт перерисует всё, так как порядок нумерации элементов в его дереве был сбит

Стоковый массив работников:
```JSX
const data = [  
   { name: "Johnathan", salary: 800, increase: false },  
   { name: "Cloose", salary: 1800, increase: true },  
   { name: "Angela", salary: 300, increase: false },  
];
```
Без полного перерендера:
```JSX
const data = [  
   { name: "Johnathan", salary: 800, increase: false },  
   { name: "Cloose", salary: 1800, increase: true },  
   { name: "Angela", salary: 300, increase: false },
   // новый тут  
   { name: "Valentine", salary: 500, increase: false }, 
];
```
С полным перерендером:
```JSX
const data = [ 
   // новый тут  
   { name: "Valentine", salary: 500, increase: false }, 
   { name: "Johnathan", salary: 800, increase: false },  
   { name: "Cloose", salary: 1800, increase: true },  
   { name: "Angela", salary: 300, increase: false },  
];
```

И чтобы реакт не перерендеривал одинаковые элементы постоянно, нужно добавить в качестве атрибута тегу уникальный `key` 

```JSX
// employers-list-item.js
//...
const EmployeesList = ({data}) => {  
	
	//--- Этот блок нужно модифицировать
    const elements = data.map((item) => {  
        return (  
            <EmployeesListItem {...item} />  
        );  
    });  
    //---
  
    return (  
        <ul className="app-list list-group">  
            {elements}  
        </ul>  
    );  
}
//...
```
Добавляем в объект деструктуризацию и передаём не весь `item`, а все его свойства по отдельности и `id` (который поместим в атрибут `key`):
```JSX
const elements = data.map((item) => {  
    const {id, ...itemProps} = item;  
    return (  
        <EmployeesListItem key={id} {...itemProps} />  
    );  
});
```
Либо подойдёт такой вариант:
```JSX
const elements = data.map((item, i) => {  
    const {...itemProps} = item;  
    return (  
        <EmployeesListItem key={i} {...itemProps} />  
    );  
});
```

И теперь в девтулзе мы можем увидеть атрибут `key`, который будет помечать для реакта повторяющийся компонент и не давать ему его перерендеривать, если тот не изменён

Важный момент: мы должны понимать, что порядок элементов у нас не поменяется, а не иначе смысла в этих атрибутах практического не будет

![](_png/d9b93fcd1964ff9a8682773f76516b38.png)


>[!info] Особенности быстрой работы реакта:
> - Реакт обновляет только те элементы интерфейса, которые действительно изменились
> - В этом ему помогает алгоритм согласования, который сравнивает старую и новую копию ДОМ-дерева
> - При работе со списком одинаковых сущностей лучше использовать атрибут `key`, чтобы реакт не перерендеривал страницу и работал ещё быстрее
