
Символы используются для создания уникального идентификатора – они уникальны и неизменяемы

В качестве ключа у нас всегда используется строка. Мы можем записать её как в кавычках, так и без. Кроме **строк** свойствами объектов могут быть ещё и **символы** – *и только эти два типа данных*

```JS
const person = {
	'name': 'Alexey'
};
```

Символы – это всегда уникальные идентификаторы (даже если есть идентификаторы с одинаковыми значениями). По точечной записи обратиться к ним нельзя. Создать через `new` – не получится

![](_png/9d1212a41238bb264fb596e6987054f1.png)

Символы позволяют создать скрытые при обычном доступе свойства, которые не показываются при переборе объекта

![](_png/df7732e4723ade6495883eff8901264e.png)

Получаем значение ключа:

![](_png/93ed1545cd14531c3089cb7cfa581c36.png)

Получаем сам ключ:

![](_png/82c81577ead204b5f400e08bd4812ab5.png)

Мы можем написать отдельный метод через `this[]`, чтобы получить символ из объекта

![](_png/4b09c50ad7a16dd00600c65901e667cc.png)

И так же есть отдельный метод, который позволяет получить массив символов из объекта

![](_png/91239001a590d15fb5c7b34c0c2aa664.png)

![](_png/62530548996fd1c3690daea8b04b3c9b.png)

Основная причина создания символов – это защита данных. Символы исключают возможность перезаписи нужных данных в объекте. Когда в проекте огромное количество строк кода и множество библиотек, то сложно будет уследить за тем, не будут ли перезаписаны нужные нам данные

![](_png/22329ed755538018a3d047b56f35c77e.png)

Тут мы записываем ключ `id` в объект, но не меняем при этом символ `id`

![](_png/bf65c7ad4bfa15a4f3e31517caf40474.png)

Когда мы формируем символ через синтаксис `Symbol.for(‘id’)`, то у нас формируется глобальный реестр символов и теперь это описание не будет уникальным

![](_png/6d5fc0f17eb1c6c94cd7cfc3611463eb.png)

Есть и обратный метод, который получает ИЗ глобального реестра значение

![](_png/4174e11a2b7991f17449f224a8d38803.png)