
Символы используются для создания уникального идентификатора – они уникальны и неизменяемы

В качестве ключа у нас всегда используется строка. Мы можем записать её как в кавычках, так и без. Кроме **строк** свойствами объектов могут быть ещё и **символы** – *и только эти два типа данных*

```JS
const person = {
	'name': 'Alexey'
};
```

Символы – это всегда уникальные идентификаторы (даже если есть идентификаторы с одинаковыми значениями). По точечной записи обратиться к ним нельзя. Создать через `new` – не получится

![](_png/Pasted%20image%2020220909162615.png)

Символы позволяют создать скрытые при обычном доступе свойства, которые не показываются при переборе объекта

![](_png/Pasted%20image%2020220909162620.png)

Получаем значение ключа:

![](_png/Pasted%20image%2020220909162628.png)

Получаем сам ключ:

![](_png/Pasted%20image%2020220909162633.png)

Мы можем написать отдельный метод через `this[]`, чтобы получить символ из объекта

![](_png/Pasted%20image%2020220909162652.png)

И так же есть отдельный метод, который позволяет получить массив символов из объекта

![](_png/Pasted%20image%2020220909162657.png)

![](_png/Pasted%20image%2020220909162703.png)

Основная причина создания символов – это защита данных. Символы исключают возможность перезаписи нужных данных в объекте. Когда в проекте огромное количество строк кода и множество библиотек, то сложно будет уследить за тем, не будут ли перезаписаны нужные нам данные

![](_png/Pasted%20image%2020220909162710.png)

Тут мы записываем ключ `id` в объект, но не меняем при этом символ `id`

![](_png/Pasted%20image%2020220909162715.png)

Когда мы формируем символ через синтаксис `Symbol.for(‘id’)`, то у нас формируется глобальный реестр символов и теперь это описание не будет уникальным

![](_png/Pasted%20image%2020220909162719.png)

Есть и обратный метод, который получает ИЗ глобального реестра значение

![](_png/Pasted%20image%2020220909162724.png)