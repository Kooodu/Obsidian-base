
Понимать контекст вызова с «`this`», стоит как присваивание переменной к определённому контексту (функции). То есть любая переменная, которую мы создаём – принадлежит всей области видимости. Если мы создаём переменную с «`this`», то она будет принадлежать только данной области

Так же тут стоит отметить, что при обычном вызове функции с `this` внутри, у нас будет выходить глобальная переменная `Window`. Если мы добавим `“use strict”`, то получим `undefined`

![](_png/Pasted%20image%2020220909175837.png)
![](_png/Pasted%20image%2020220909175842.png)

И тут представлен пример, когда мы используем «**this**» и избегаем его. Благодаря «**замыканию функции**» в обычной ситуации (первый скрин) у нас переменные ищутся сначала внутри самой функции, потом поиск заходит в функцию родителя.

На втором изображении уже используется вызов переменной через «`this`» и функция ищет переменную **только** внутри себя и дальше не выходит. Поэтому и возвращается `undefined`

![](_png/Pasted%20image%2020220909175848.png)
![](_png/Pasted%20image%2020220909175853.png)

> Контекст вызова у методов объекта – это сам объект

![](_png/Pasted%20image%2020220909175859.png)

Уже в данном примере контекст вызова (объект) теряется, так как внутри метода просто вызывается функция

![](_png/Pasted%20image%2020220909175907.png)

> This в конструкторах и классах – это новый экземпляр объекта

То есть при создании свойства в конструкторе через «`this`», это значение будет присваиваться только созданным экземплярам через данный конструктор

![](_png/Pasted%20image%2020220909175912.png)

Ручная привязка `this`: `call`, `apply`, `bind`

Так же мы можем вызывать функцию и подвязать ей контекст вызова через методы `call` и `apply` (оба метода выполняют одно и то же, но по-разному передают аргументы в функцию)

Так же можно сделать много вариаций одной и той же функции, используя контекст вызова и функцию `bind`. `bind` принимает в себя значение «`this`» и возвращает в переменную новую функцию, где `this` заменён на данный аргумент метода

![](_png/Pasted%20image%2020220909175922.png)
![](_png/Pasted%20image%2020220909175927.png)

И когда мы используем конструкцию с `function()` в ивенте мы так же можем пользоваться и «`this`», так как он будет вызывать конкретно наш нажатый объект

![](_png/Pasted%20image%2020220909175933.png)
![](_png/Pasted%20image%2020220909175937.png)

И работать с этим объектом мы так же можем

![](_png/Pasted%20image%2020220909175942.png)
![](_png/Pasted%20image%2020220909175949.png)

Как помним из примера выше – функция внутри функции имеет свой контекст вызова и поэтому в объекте такая вложенная функция вернёт `undefined`. Но отличительной особенностью **стрелочных функций** является то, что у них **нет своего контекста вызова**. Контекст вызова они наследуют от родителя и поэтому код, приведённый ниже, будет работать

![](_png/Pasted%20image%2020220909180012.png)

Ну и так как нет собственного контекста вызова у стрелочной функции, то берём пример чуть выше с `function()` и переделываем его на стрелочную функцию. Работать уже такой ивент не будет, так как контекст, опять же, берётся у родителя

![](_png/Pasted%20image%2020220909180018.png)
![](_png/Pasted%20image%2020220909180022.png)

И чтобы заменить «`this`» в таких функциях, используют таргет ивента

![](_png/Pasted%20image%2020220909180027.png)
![кнопка|400](_png/Pasted%20image%2020220909180044.png)