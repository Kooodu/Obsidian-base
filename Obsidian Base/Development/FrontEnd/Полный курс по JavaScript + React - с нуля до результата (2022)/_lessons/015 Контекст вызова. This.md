
Понимать контекст вызова с «`this`», стоит как присваивание переменной к определённому контексту (функции). То есть любая переменная, которую мы создаём – принадлежит всей области видимости. Если мы создаём переменную с «`this`», то она будет принадлежать только данной области

Так же тут стоит отметить, что при обычном вызове функции с `this` внутри, у нас будет выходить глобальная переменная `Window`. Если мы добавим `“use strict”`, то получим `undefined`

![](_png/ae9d827f0f2347d147d24fb12d90b773.png)
![](_png/938524befd029c90b95b2a12d019fc61.png)

И тут представлен пример, когда мы используем «**this**» и избегаем его. Благодаря «**замыканию функции**» в обычной ситуации (первый скрин) у нас переменные ищутся сначала внутри самой функции, потом поиск заходит в функцию родителя.

На втором изображении уже используется вызов переменной через «`this`» и функция ищет переменную **только** внутри себя и дальше не выходит. Поэтому и возвращается `undefined`

![](_png/7499b9c1090511a01b835bcb6f9cdfd9.png)
![](_png/8d42f9d06a1ce97491ce90a33bfa1f94.png)

> Контекст вызова у методов объекта – это сам объект

![](_png/4d9339a09ed0e386425c44a149c8320b.png)

Уже в данном примере контекст вызова (объект) теряется, так как внутри метода просто вызывается функция

![](_png/8e8edea7f19120616f1c73927f21f4ba.png)

> This в конструкторах и классах – это новый экземпляр объекта

То есть при создании свойства в конструкторе через «`this`», это значение будет присваиваться только созданным экземплярам через данный конструктор

![](_png/030fc814a5bb727308037ab61ed0f243.png)

Ручная привязка `this`: `call`, `apply`, `bind`

Так же мы можем вызывать функцию и подвязать ей контекст вызова через методы `call` и `apply` (оба метода выполняют одно и то же, но по-разному передают аргументы в функцию)

Так же можно сделать много вариаций одной и той же функции, используя контекст вызова и функцию `bind`. `bind` принимает в себя значение «`this`» и возвращает в переменную новую функцию, где `this` заменён на данный аргумент метода

![](_png/2e3132310e41c4898d13dafaeb9655bb.png)
![](_png/4b7a7fa37cb58a153655d89733ab0fca.png)

И когда мы используем конструкцию с `function()` в ивенте мы так же можем пользоваться и «`this`», так как он будет вызывать конкретно наш нажатый объект

![](_png/a17652c3dfb9dfa00837ba43c73f7957.png)
![](_png/e3f83e7ac1b8e80ed30b2196beb66c24.png)

И работать с этим объектом мы так же можем

![](_png/28cb25bfb25adea2052cbdd86324919c.png)
![](_png/a5531352b0c7be6869fd075bdbb288e3.png)

Как помним из примера выше – функция внутри функции имеет свой контекст вызова и поэтому в объекте такая вложенная функция вернёт `undefined`. Но отличительной особенностью **стрелочных функций** является то, что у них **нет своего контекста вызова**. Контекст вызова они наследуют от родителя и поэтому код, приведённый ниже, будет работать

![](_png/96f6de4b8e4aae84b12a4a18abf00903.png)

Ну и так как нет собственного контекста вызова у стрелочной функции, то берём пример чуть выше с `function()` и переделываем его на стрелочную функцию. Работать уже такой ивент не будет, так как контекст, опять же, берётся у родителя

![](_png/6e0f194108da1796b6e625bdb82fddba.png)
![](_png/6dfaf0a8c2ea2ea391763925a5e47911.png)

И чтобы заменить «`this`» в таких функциях, используют таргет ивента

![](_png/790bdc2c5ad0dc6169663b9c638d5314.png)
![кнопка|400](_png/e5bd9e4be27e942a4646530073c27c40.png)