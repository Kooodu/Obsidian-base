
В консоли мы видим коллекции, которые были созданы благодаря `querySelector` и `getElementByClassName`

```JS
const boxesQuery = document.querySelectorAll('.box');
const boxesGet = document.getElementByClassName('box');

console.log(boxesQuery);
console.log(boxesGet);
console.log(document.body.children);
```

![](_png/499276c03c891653b787b18b116f8675.png)

И сейчас перед нами встаёт разница между живыми коллекциями и статическими.

Современный способ обращения к объектам представляет из себя статическую коллекцию, которая статично хранит в себе состояние DOM-дерева. Старый способ обращения к объектам отображает текущее состояние DOM-дерева

```JS
const boxesQuery = document.querySelectorAll('.box');
const boxesGet = document.getElementByClassName('box');

boxesQuery[0].remove();
boxesGet[0].remove();

console.log(boxesQuery);
console.log(boxesGet);
console.log(document.body.children);
```

![](_png/880185a67ec6e0f492942291fdb8694f.png)

И встаёт иногда такая потребность, чтобы следить за состоянием DOM-дерева в течение его жизни. Мы можем сделать массив из данной коллекции, но тут уже встаёт проблема: массив – это уже статичный объект и следить за DOM-деревом не получится

```JS
// генерируем массив из псевдомассива элементов страницы
console.log(Array.from(boxesGet));
```

![](_png/56c0128e769ca11bc1ff078b7d9b2362.png)

Тут мы добавляем дополнительно пять боксов через цикл

![](_png/9f9f5091c6ac58f8eb17a7b7ee55b491.png)

И тут представлены два метода, которые можно применять на псевдомассивах.

1) `matches()` – принимает в себя селектор и при его нахождении в объекте возвращает `true`
2) `closest()` – принимает в себя класс и выводит ближайший родительский элемент с таким классом.

Мы имеем структуру: `wrapper > innerWrapper > box`. И при поиске враппера выведется вся эта структура

![](_png/69d1fbeddcc313c1271919fe4a38bc2a.png)