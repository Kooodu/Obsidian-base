
>[!note] #tips  
>Когда мы меняем состояние через методы, можно обращаться по полному пути к состоянию 
> ![](_png/Pasted%20image%2020230305094722.png)
> А можно деструктурировать нужное нам свойство
> 
> ![](_png/Pasted%20image%2020230305094725.png)

Далее в сервисе укажем отдельным полем число оффсета и вставим его в запрос. По умолчанию оффсет внутри метода будет принимать в себя значение поля

`src > service > marverl.service.js`
```JS
_baseOffsetForPerson = 210;  

getAllCharacters = async (offset = this._baseOffsetForPerson) => {  
   const res = await this.getResource(  
      `${this._apiBase}characters?limit=9&offset=${offset}&${this._apiKey}`,  
   );  
  
   return res.data.results.map(this._transformCharacter);  
};
```

Далее нужно добавить функционал пагинации в наше приложение. Пагинация - это дозагрузка контента страницы по запросу пользователя.



`src > components > charList > CharList.js`
```JS
class CharList extends Component {  
   state = {  
      charList: [],  
      loading: true,  
      error: false,  
      newItemLoading: false, // загрузка новых персонажей  
      offset: 210, // начальное положение от которого считается отступ  
      charEnded: false, // отвечает за то состояние, когда кончился список персонажей  
   };  
  
   marvelService = new MarvelService();  
  
   // при монтировании компонента вызваем запрос на сервер  
   componentDidMount() {  
      this.onRequest(this.state.offset);  
   }  
  
   // это метод, который теперь отвечает за запросы на сервер для получения данных  
   onRequest = (offset) => {  
      this.onCharListLoading(); // при запросе запускается спиннер загрузки  
      this.marvelService.getAllCharacters(offset).then(this.onCharListLoaded).catch(this.onError);  
   };  
  
   // запускаем спиннер при загрузке персонажей  
   onCharListLoading = () => {  
      this.setState({  
         newItemLoading: true,  
      });  
   };  
  
   onCharListLoaded = (newCharList) => {  
      // если сервер вернул меньше 9 персонажей, то список кончился  
      let ended = false;  
      if (newCharList.length < 9) ended = false;  
  
      // теперь мы устанавливаем в стейт новые и старые данные  
      this.setState(({ offset, charList }) => ({  
         // сюда разворачиваем новые и старые элементы  
         charList: [...charList, ...newCharList],  
         loading: false,  
         newItemLoading: false, // когда загрузился - отключаем  
         offset: offset + 9, // тут уже меняем состояние пагинации  
         charEnded: ended, // устанавливаем состояние окончания списка (кончился / не кончился)  
      }));  
   };  
  
   onError = () => {  
      this.setState({  
         error: true,  
         loading: false,  
      });  
   };  
  
   renderItems(arr) {  
      const items = arr.map((item) => {  
         let imgStyle = { objectFit: 'cover' };  
         if (  
            item.thumbnail ===  
            'http://i.annihil.us/u/prod/marvel/i/mg/b/40/image_not_available.jpg'  
         ) {  
            imgStyle = { objectFit: 'unset' };  
         }  
  
         return (  
            <li  
               className='char__item'  
               key={item.id}  
               onClick={() => this.props.onCharSelected(item.id)}  
            >               <img src={item.thumbnail} alt={item.name} style={imgStyle} />  
               <div className='char__name'>{item.name}</div>  
            </li>  
         );  
      });  
  
      return <ul className='char__grid'>{items}</ul>;  
   }  
  
   render() {  
      const { charList, loading, error, offset, newItemLoading, charEnded } = this.state;  
  
      const items = this.renderItems(charList);  
  
      const errorMessage = error ? <ErrorMessage /> : null;  
      const spinner = loading ? <Spinner /> : null;  
      const content = !(loading || error) ? items : null;  
  
      return (  
         <div className='char__list'>  
            {errorMessage}  
            {spinner}  
            {content}  
            <button  
               className='button button__main button__long'  
               // кнопка заблокирована, если загружает что-либо  
               disabled={newItemLoading}  
               // при нажатии на кнопку будут подгружаться данные  
               onClick={() => this.onRequest(offset)}  
               style={{ display: charEnded ? 'none' : 'block' }}  
            >  
               <div className='inner'>load more</div>  
            </button>  
         </div>  
      );  
   }  
}  
  
export default CharList;
```

Ну и так же накинем на кнопку фильтр, чтобы пользователь понимал, что она некликабельна через `:disabled`

`styles > button.scss`
```SCSS
@import './variables';  
  
.button {  
    &:disabled {  
        filter: grayscale(.5);  
    }  
}
```

Итог: у нас подгружаются новые персонажи и кнопка становится тёмной

![](_png/Pasted%20image%2020230305104940.png)