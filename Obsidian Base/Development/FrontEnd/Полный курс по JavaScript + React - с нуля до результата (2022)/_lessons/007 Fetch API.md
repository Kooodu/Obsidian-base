
`fetch` – это конструкция с GET-запросом, которая внутри представляет из себя промис (то есть чейны работают так же как и в промисах)

Стандартно фетч возвращает промис, который выполняется в любом случае (кроме отсутствия интернета)

![](_png/9b7c147f1eb8a6d92dd8bb1dce791fac.png)

Чтобы отправить данные на сервер, нужно уже будет немного модифицировать фетч-запрос

Вторым аргументов в фетч передаётся объект с настройками, который заменяет сразу три метода стандартного реквеста. Мы прописываем тип запроса, бади с отправляемыми данными на сервер (например, отправим данные из формы) и тип заголовков (если отправляем JSON)

![](_png/1390f25488936be3936c26713c39e4da.png)

И сейчас на сайте с едой можно будет заменить все наши `XMLHTTPRequests` на короткий и понятный `fetch`, который в себе содержит все нужные нам реквесты, да ещё и исполняется асинхронно

![](_png/ee9361227398484c6d95773f0e21d1e6.png)

И как итог мы заменили огромное количество кода с реквестами и данной проверкой

![](_png/7586c7f04a1a78a52bb5d63d95d2345b.png)

На данную короткую запись

![](_png/65583eaa872d8e532b05586b98f8d2bf.png)

Так же если мы допишем этот короткий участок кода, то мы сможем увидеть текст нашего запроса

![](_png/bd16207de3cd7c3510ab4af8c4958b09.png)

Теперь так же можно удалить парсинг объекта и перенести его прямо в фетч

![](_png/54f6bd43c577a83ff58c2240217daf10.png)
![](_png/19d5159c228576974a84c9ee99ac33b3.png)
Ну и примерно так выглядит ответ от серера
![](_png/736a765cfe71c445d636645db43cf5d8.png)

Ну и так же нужно работать с особенностями фетча. Дело в том, что он не вернёт реджект, даже если у нас проблемы при связи с сервером. Единственное что, так это статус фетча поменяется с ОК на false.

Реджект сработает только при сбое сети / отсутствии интернета

![](_png/9a417c30d0df5f0bf70170343497fbe7.png)
![](_png/658f5000de6c879fd45cc23e691b3327.png)