
В данном уроке нужно заменить отображение карточек на сайте с самостоятельного их создания через свои аргументы на создание по аргументам, полученным с сервера (а именно с нашей базы данных)

![](_png/9243ef3d0765c2d304b3dd7e7fb95cc5.png)
![](_png/20a91e0708a20aec85118edfbee06ac7.png)

Ну и далее нашу датабазу нужно поместить в корень проекта и отдельно запустить json-server, чтобы работать с этой датабазой

![](_png/2e425e8ec4d90e7573aae2641f5956e0.png)
![](_png/15e9d3b86277e0e6d087238532705743.png)

И дальше нам нужно заменить фетч-запрос в нашем `postData`, чтобы мы могли запрашивать разыне данные по определённым параметрам.

Для этого сначала переименуем нашу основную функцию и сам пост данных забьём в отдельную функцию, внутри которой и будем вызывать фетч. Результат фетча (это промис) будем сразу переводить в JSON

![](_png/351029ec43bd4e01255e042075cfbfb2.png)
![](_png/b1104a73669003b8923877f941750a5d.png)

И дальше мы встречаемся с проблемой. `Promise` – это асинхронный код, который выполняется вне основного потока функции. Поэтому на момент возвращения результата мы получим `error`, так как `res` будет равен `undefined`. Чтобы решить проблему, нужно превратить код в синхронный, чтобы `return` дождался выполнения промиса

![](_png/11de34033c8f5d5c22ad286b32571a48.png)

И далее нам приходит на помощь конструкция `async`/`await`. Она работает примерно по такому принципу:

`async` говорит, что в функции есть асинхронные функции (промисы), а уже сам `await` говорит этой функции, что это и есть асинхронная функция и что её результата выполнения нужно дождаться, прежде чем выполнять код дальше. То есть выполнение кода остановится до получения любого результата этой функции

Так же `await` можно накинуть и на метод, который переводит промис в json (так как неизвестно насколько большой ответ от сервера придёт)

![](_png/36661b5487c7bcc5a449108c619e4e1f.png)

Примерно так выглядит итоговый запрос. Ссылка взята из `json-server` и перевод данных в текст убран (самый первый чейн)

![](_png/e362b48bdb2f030b657d801421478ff4.png)

И такой ответ от сервера мы получаем

![](_png/064962485e20536da30be4e0f86cdfc6.png)

И самая прикольная вещь тут – это наш первый постинг данных на сервер с записью ответа в датабазу

![](_png/5266b4f907f5ce8a25abe8825ae43313.png)

Ну и далее мы можем немного заменить такой формат записи данных из формдаты в объект

![](_png/d89b8fae927499bd34c9aa08844cc626.png)

Мы можем это реализовать через метод `entries`, который переводит свойства объекта в массивы

![](_png/166b0563cac011f5b68633503e83057e.png)

И поэтому мы сейчас выполним такую комбинацию:
1) Сначала `formData` переведём в массив массивов (можно записать и `Object.entires(formData)`)
2) Потом переведём через `Object.fromEntires()` этот массив массивов в обычный объект
3) Потом через `stringify` переведём объект в json-формат данных
4) Передадим переменную с джсоном в `postData`

![](_png/f41440014aca7cbff768f2de57bc0a6d.png)

Дальше переходим ко второй части, где мы должны заменить генерацию наших карточек из собственных запросов и генераций.

Тут нам нужны простые гет-запросы, поэтому оставляем только ссылку.

Дальше нам нужно решить проблему с тем, что `fetch` может вернуть `error`. `catch` нам недоступен, так как он вызывается только при отсутствии интернета. Делается это просто. У `fetch` есть свойство «`ok`» и нам нужно проверить, что если он отрицательный, то нам нужно будет выдать ошибку. В ошибке можно указать ещё и свойство статуса фетча

![](_png/d0912c1c12baf8013a582854a638866d.png)

И дальше нам нужно выполнить наш запрос. При отправке запроса на сервер, мы получаем всю нашу дадабазу.

Затем в `then` обрабатываем наш запрос. Все данные (само меню) хранятся в массиве (массив объектов, где объект - менюшка), поэтому нужно будет перебрать полученную дату через `forEach`.

В переборе мы не передаём `item`, а сразу можем деструктуризировать полученный элемент на отдельные свойства, чтобы было проще (чтобы не обращаться постоянно `item.img`, `item.altimg` и так далее)

![](_png/174633a8e9835db72a1a71f2264cd1d5.png)
![](_png/96a809e21cd62193424551b4097fbe30.png)

Так же можно таким способом реализовать рендер элементов на странице – не через наш созданный класс, а через функцию, которая принимает в себя массив карточек

![](_png/3effda72aa631c5d63f2cddbb22d02df.png)