
С помощью приведённых ниже методов обычно создают изменения в классах для применения новых стилей на объекте и проявления элементов. Конкретно данный гамбургер был сделан через использование метода `toggle()`

![](_png/f5615459dbaf220d36ba590f66aa1271.png)

![](_png/d7260037de2f8068786e562ac3b872ad.png)

Изначальный код на странице:

![](_png/1adad9d29ea2307fa53f9731ea23fab7.png)

Сначала мы получим псевдомассив со всеми нашими кнопками со страницы. Через `classList.length` можно получить количество классов на объекте. Через `classList.item(индекс)` можно получить наименование класса объекта под определённым индексом

![](_png/0b6361b675e6ede92072ae6b7ea2037a.png)

![](_png/ee814357cd128942d2e34a6f60edbdf8.png)

Метод `classList.togle(`) крайне полезен и юзабелен. Данный метод добавит класс, если он отсутствует на объекте и удалит, если уже присуствует. Он может заменить целый блок с условной конструкцией, так как в его нутрянке и есть подобная проверка

![](_png/6cc221de54253867e9a9a510e5f04624.png)

Метод `contains()` проверяет наличие класса в выбранном объекте. С помощью него можно прописать условие, которое будет срабатывать при наличии определённого класса

![](_png/c713354ed9f64ee809ad75c1b4e4bb4a.png)

И вот пример добавления/удаления класса через условную конструкцию и через `toggle()`

![](_png/d19a1c23666d73b55897bfff2dd22a3d.png)

`className` – устаревший способ изменения классов. Он хранит в себе классы как строчку и использовать его неудобно

![](_png/d5ac0cbbeebe885376579e4fe064defa.png)

И сейчас нужно поговорить про добавление события для нескольких элементов на странице. Дело в том, что если нам нужно одинаковое событие на странице для нескольких элементов, то мы могли бы добавить `addEventListener` через `forEach` на все такие элементы. Однако такой подход немного устарел и имеет свои минусы в виде того, что если элемент отсутствовал на странице, то тот при появлении не будет иметь данный ивент.

Чтобы упростить задачу, нам нужно применить данный ивент на сам враппер, который в себе содержит эти элементы

![](_png/582b3aef3ffd1b343d251754cc7d207f.png)

Далее хорошо бы было узнать название элемента в самой HTML-структуре через дир - `event.target` (название элемента можно увидеть при нажатии на него на странице)

![](_png/0faa4670d485ec255fe0ffec2a6027b2.png)
![](_png/faccb87be07e09f794d471d7050ac794.png)

И теперь при нажатии любой кнопки внутри `wrapper` (даже если кнопка появилась позже в нём) у нас будет срабатывать `event`. При нажатии на сам враппер, ничего происходить не будет

Такой способ называется делегированием

![](_png/525e460fd9bfe30935c52a80234c5df2.png)
![](_png/1e3b121bab4dfeca7e249b19cd8ee8d9.png)

Так же можно присвоить ивенты только тем кнопкам, которые имеют определённый класс (тут – `blue`)

![](_png/aba8e8fd636b01589d3a501b7832fbea.png)
![](_png/6ef72963062d78d70a62fb8aa3960000.png)

И вот простой пример. Созданная кнопка после объявления ивента, уже имеет данный ивент, потому что он делегируется дочерним элементам

![](_png/f368b0dd79f1c9cb2752b3de9ad2ffa7.png)
![](_png/7c34de997a0a7fb3d58af22a46732dfd.png)

При таком коде новый ивент не будет добавлен на кнопку и она будет грустить одна такая☹

![](_png/89c3ba920b10f19c417ddb121c42ce4c.png)

И так же есть продвинутая техника обращения к элементу через метод `matches()`, внутрь которого мы положим наименование элемента и селектор класса

![](_png/4cef273fb4f4a864013e53e34ec70afd.png)
![](_png/c8f7040b64832acd10fdf17ecd571e22.png)