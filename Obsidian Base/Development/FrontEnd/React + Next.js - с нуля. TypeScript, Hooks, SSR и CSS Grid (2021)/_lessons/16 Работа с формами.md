
## 001 Компонент отзыва

Сейчас нужно реализовать компонент отзыва. 
Он будет в себя принимать те же пропсы, что описаны в `ReviewModel`

`components / Review / Review.props.ts`
```TS
import { DetailedHTMLProps, HTMLAttributes } from 'react';  
import { ReviewModel } from '../../interfaces/product.interface';  
  
export interface ReviewProps  
   extends DetailedHTMLProps<HTMLAttributes<HTMLDivElement>, HTMLDivElement> {  
   review: ReviewModel;  
}
```

Сам компонент обзора:

`components / Review / Review.tsx`
```TSX
import React from 'react';
import cn from 'classnames';
import { format } from 'date-fns';
import { ru } from 'date-fns/locale';
import styles from './Review.module.css';
import UserIcon from './user.svg';
import { ReviewProps } from './Review.props';
import { Rating } from '../Rating/Rating';

export const Review = ({ review, className, ...props }: ReviewProps): JSX.Element => {
	const { name, title, rating, description, createdAt } = review;

	return (
		<div className={cn(styles.review, className)} {...props}>
			<UserIcon className={styles.user} />
			<div className={styles.title}>
				<span className={styles.name}>{name}:</span>&nbsp;&nbsp;
				<span>{title}</span>
			</div>
			<div className={styles.date}>
				{/*
				 * создаём новую дату из createdAt,
				 * далее указываем дату (заглавные - пропись)
				 * и потом указываем язык
				 */}
				{format(new Date(createdAt), 'dd MMMM yyyy', { locale: ru })}
			</div>
			<div className={styles.rating}>
				<Rating rating={rating} />
			</div>
			<div className={styles.description}>{description}</div>
		</div>
	);
};
```

Стили компонента обзора:

`components / Review / Review.module.css`
```CSS
.review {  
   display: grid;  
   grid-template-columns: [start] auto 1fr auto auto [end];  
   align-items: center;  
   gap: 10px;  
  
   font-size: 14px;  
   line-height: 24px;  
}  
  
.description {  
   grid-column: start / end;  
}  
  
.date {  
   margin-right: 10px;  
}  
  
.name {  
   font-weight: bold;  
}  
  
@media (max-width: 640px) {  
   .review {  
      grid-template-columns: [start] 30px [titlestart] auto [dateend] 1fr [end];  
   }  
  
   .title {  
      grid-column: titlestart / end;  
   }  
  
   .date {  
      grid-column: start / dateend;  
   }  
}  
  
@media (max-width: 480px) {  
  
   .rating {  
      grid-column: start / end;  
   }  
  
   .date {  
      grid-column: start / end;  
   }  
}
```

Сокращаем путь до компонента

`components / index.ts`
```TS
export * from './Review/Review';
```

Компонент отзыва будет выводить в отдельной карточке, которая будет изначально закрыта. Для открытия и закрытия будем использовать `useState`, который будет изменяться при нажатии на кнопку в первой карточке

`components / Product / Product.tsx`
```TSX
export const Product = ({ product }: ProductProps): JSX.Element => {  
   const [isReviewOpened, setIsReviewOpened] = useState<boolean>(false);  
  
   return (  
      <>  
         {/* обернём продукт в карточку */}  
         <Card className={styles.product}>  
            /// CODE ....
            
            {/* тут будут находиться кнопки */}
				<div className={styles.actions}>
					<Button appearance={'primary'}>Узнать подробнее</Button>
					<Button
						appearance={'ghost'}
						arrow={isReviewOpened ? 'down' : 'right'}
						className={styles.review}
						{/* меняем состояние отзывов */}
						onClick={() => setIsReviewOpened(!isReviewOpened)}
					>
						Читать отзывы
					</Button>
				</div>
         </Card>  
         <Card
				color={'blue'}
				className={cn(styles.reviews, {
					[styles.opened]: isReviewOpened,
					[styles.closed]: !isReviewOpened,
				})}
			>
				{product.reviews.map(r => (
					<>
						<Review key={r._id} review={r} />
						<Divider />
					</>
				))}
			</Card>
      </>  
   );  
};
```

Стили для открытого и закрытого меню с отзывами

`components / Product / Product.module.css`
```CSS
/*
	* Вторая карточка
*/

.opened {
	max-height: auto;
	padding: 30px;
}

/* чтобы нормально заанимировать изменение высоты, нам нельзя использовать display: none */
.closed {
	max-height: 0;
	padding: 0;
	overflow: hidden;
}
```

Итог:

![](_png/Pasted%20image%2020230208102456.png)

## 002 Форма отзыва

Компонент формы будет на вход принимать в себя `id` продукта, к которому он относится

`components / ReviewForm / ReviewForm.props.ts`
```TS
import { DetailedHTMLProps, HTMLAttributes } from 'react';

export interface ReviewFormProps
	extends DetailedHTMLProps<HTMLAttributes<HTMLDivElement>, HTMLDivElement> {
	productId: string;
}
```

Сама форма добавления нового отзыва состоит из уже подготовленных компонентов ввода `Input` с `Textarea` и выглядит следующим образом:

`components / ReviewForm / ReviewForm.tsx`
```TSX
import React from 'react';
import cn from 'classnames';
import styles from './ReviewForm.module.css';
import { ReviewFormProps } from './ReviewForm.props';
import { Input } from '../Input/Input';
import { Rating } from '../Rating/Rating';
import { Textarea } from '../Textarea/Textarea';
import { Button } from '../Button/Button';
import CloseIcon from './close.svg';

export const ReviewForm = ({ productId, className, ...props }: ReviewFormProps): JSX.Element => {
	return (
		<>
			<div className={cn(styles.reviewForm, className)} {...props}>
				<Input placeholder={'Имя'} />
				<Input placeholder={'Заголовок'} className={styles.title} />
				<div className={styles.rating}>
					<span>Оценка:</span>
					<Rating isEditable={true} rating={0} />
				</div>
				<Textarea placeholder={'Текст отзыва'} className={styles.description} />
				<div className={styles.submit}>
					<Button className={styles.button} appearance={'primary'}>
						Отправить
					</Button>
					<span className={styles.info}>
						* Перед публикацией отзыв пройдет предварительную модерацию и проверку
					</span>
				</div>
			</div>

			{/* это оповещение, которое отправится после сабмита нового отзыва */}
			<div className={styles.success}>
				<div className={styles.successTitle}>Ваш отзыв отправлен!</div>
				<div className={styles.successDescription}>
					Спасибо, ваш отзыв будет опубликован после проверки.
				</div>
				<CloseIcon className={styles.close} />
			</div>
		</>
	);
};
```

Сокращаем путь до компонента

`components / index.ts`
```TS
export * from './ReviewForm/ReviewForm';
```

Стили компонента с адаптивом:

`components / ReviewForm / ReviewForm.module.css`
```CSS
.reviewForm {
	display: grid;
	grid-template-columns: [start] auto 1fr auto [end];
	align-items: center;
	gap: 20px 30px;

	margin-bottom: 20px; /* отбиваем снизу уведомление об отправке */

	font-size: 14px;
	line-height: 24px;
}

.description, .submit {
	grid-column: start / end;
}

.title {
	/* инпут с заголовком прибился к левому краю */
	justify-self: left;
}

.button {
	margin-right: 20px;
}

.rating {
	display: grid;
	grid-template-columns: auto 1fr;
	gap: 20px;
}

.success {
	position: relative;

	padding: 20px;

	border-radius: 5px;

	background: var(--green-light);
}

.successTitle {
	font-weight: bold;
}

.close {
	position: absolute;
	top: 20px;
	right: 20px;
	cursor: pointer;
}

@media (max-width: 1100px) {
	.reviewForm {
		grid-template-columns: [start] 1fr 1fr [end];
	}

	.title {
		/* чтобы инпут с заголовком не прибивался к левому краю */
		justify-self: normal;
	}

	.rating {
		grid-column: start / end;
	}
}

@media (max-width: 640px) {
	.reviewForm {
		grid-template-columns: [start] 1fr [end];
	}
}
```

И тут мы выводим форму  добавления обзора `ReviewForm`

`components / Product / Product.tsx`
```TSX
<Card
	color={'blue'}
	className={cn(styles.reviews, {
		[styles.opened]: isReviewOpened,
		[styles.closed]: !isReviewOpened,
	})}
>
	{product.reviews.map(r => (
		<>
			<Review key={r._id} review={r} />
			<Divider />
		</>
	))}
	
	{/* форма написания обзора */}
	<ReviewForm productId={product._id} />
</Card>
```

Итог:

![](_png/Pasted%20image%2020230208195220.png)


## 003 useForm

Первым делом нужно сказать, что события реакта и события в DOM - это отдельные вещи. Между обоими деревьями есть прослойка, которая проксирует их взаимодействия (ветка реакта / ветка html и между ними сравнение)  

![](_png/Pasted%20image%2020230208200314.png)

При работе с формами внутри реакта, мы можем работать собственными силами или использовать готовые библиотеки, которые воспроизводят нужный нам функционал. Минусом второго подхода является то, что библиотека несёт за собой дополнительную зависимость и дополнительный вес на страницу, а так же эту зависимость нужно поддерживать и своевременно обновлять.

Если:
- Формы присутствуют только на регистрации или они простые, то самым оптимальным решением будет самому реализовать формы
- Формы используются в большом количестве (работа с паспортными данными или CRM-система), то тут уже можно использовать библиотеку 

![](_png/Pasted%20image%2020230208200534.png)

Управляемый компонент - это компонент, значения которого управляются в стейте этого же компонента.

Если мы возьмём обычный `<input>`, то его значение хранится в DOM-дереве. Если мы берём тот же компонент `<Rating />`, то его состояние (значение рейтинга) хранится в самом компоненте рейтинга.

![](_png/Pasted%20image%2020230208201400.png)

В проекте будет использоваться ==React Hook Form==

![](_png/Pasted%20image%2020230208201633.png)

Параметры, которые возвращает хук формы `useForm`: 

![](_png/Pasted%20image%2020230208202144.png)

Оформление неуправляемых компонентов:

![](_png/Pasted%20image%2020230208202410.png)

Пример оформления управляемого компонента: контроллер указывает на то, чем он будет управлять

![](_png/Pasted%20image%2020230208202559.png)

## 004 Работа с формами

Прежде всего нужно поправить старые ошибки. Если мы используем списки и выводим повторяющиеся элементы, то нам нужно атрибут `key` переносить на самый внешний элемент

![](_png/Pasted%20image%2020230212153855.png)

Далее нужно установить модуль работы с формами внутри реакта

```bash
npm i react-hook-form
```

Далее нужно определить, что будет получать форма. В неё будет попадать имя пользователя, заголовок, рейтинг и описание

`components / ReviewForm / ReviewForm.interface.ts`
```TS
export interface IReviewForm {  
   name: string;  
   title: string;  
   description: string;  
   rating: number;  
}
```

Далее мы создаём хук формы, который принимает в себя вышеописанный интерфейс, тем самым определяя, какие поля в форме будут 

Чтобы привязать неуправляемые компоненты к форме, придётся воспользоваться привязкой через `{...register('name')}` деструктуризацию объекта функции регистрации, куда мы передаём имя формы

Далее, чтобы сделать рейтинг управляемым, его нужно сложить в контроллер, который привязан к нашему `useForm`. Стейт хранить будет сам рейтинг, а управлять стейтом будет контроллер, в который вложен рейтинг.

`components / ReviewForm / ReviewForm.tsx`
```TSX  
export const ReviewForm = ({ productId, className, ...props }: ReviewFormProps): JSX.Element => {  
	// register - регистрирует форму  
	// control - регистрирует управляемые формы   
	// handleSubmit - функция хэндлинга сабмита   
   const { register, control, handleSubmit } = useForm<IReviewForm>();  
  
   const onSubmit = (data: IReviewForm) => {  
      console.log(data);  
   };  
  
   return (  
      // при отправке формы, нужно вложить функцию, которую мы получаем из useForm, и вложить в неё функцию, которая вызовется после сабмита  
      <form onSubmit={handleSubmit(onSubmit)}>  
         <div className={cn(styles.reviewForm, className)}  
            {...props}  
         >  
            <Input {...register('name')} placeholder='Имя' />  
            <Input {...register('title')} placeholder='Заголовок отзыва' className={styles.title} />  
            <div className={styles.rating}>  
               <span>Оценка:</span>  
               <Controller  
                  control={control}  
                  name='rating'  
                  render={({ field }) => (  
                     <Rating 
	                     isEditable 
	                     ref={field.ref} 
	                     rating={field.value} 
	                     setRating={field.onChange} 
					/>  
                  )}  
               />  
            </div>  
            <Textarea  {...register('description')} placeholder='Текст отзыва' className={styles.description} />  
            <div className={styles.submit}>  
               <Button appearance="primary">Отправить</Button>  
               <span className={styles.info}>* Перед публикацией отзыв пройдет предварительную модерацию и проверку</span>  
            </div>  
         </div>  

         {/* это оповещение, которое отправится после сабмита нового отзыва */}  
         <div className={styles.success}>  
            <div className={styles.successTitle}>Ваш отзыв отправлен</div>  
            <div>  
               Спасибо, ваш отзыв будет опубликован после проверки.  
            </div>  
            <CloseIcon className={styles.close} />  
         </div>  
      </form>  
   );  
};
```

Осталось только решить проблему с пробросом ref и мы будем получать все данные с форм

![](_png/Pasted%20image%2020230212174304.png)

## 005 Проброс ref

reference определённого элемента позволяет нам:

![](_png/Pasted%20image%2020230213134103.png)

Чтобы передать `ref` в компонент, нужно саму функцию компонента обернуть в функцию `forwardRef`, которая позволит передать ему этот пропс `ref` внутрь компонента в качестве атрибута

![](_png/Pasted%20image%2020230213134243.png)

Прокидываем `ref` через `forwardRef` в `Textarea`

`components / Textarea / Textarea.tsx`
```TSX
export const Textarea = forwardRef(  
   (  
      { className, ...props }: TextareaProps,  
      ref: ForwardedRef<HTMLTextAreaElement>,  
   ): JSX.Element => {  
      return <textarea ref={ref} className={cn(className, styles.input)} {...props} />;  
   },  
);
```

Прокидываем `ref` через `forwardRef` в `Input`

`components / Input / Input.tsx`
```TSX
export const Input = forwardRef(  
   ({ className, ...props }: InputProps, 
	ref: ForwardedRef<HTMLInputElement>
   ): JSX.Element => {  
      return <input ref={ref} className={cn(className, styles.input)} {...props} />;  
   },  
);
```

Прокидываем `ref` через `forwardRef` в компонент рейтинга

`components / Rating / Rating.tsx`
```TSX
export const Rating = forwardRef(  
   (  
      { isEditable = false, rating, setRating, ...props }: RatingProps,  
      ref: ForwardedRef<HTMLDivElement>,  
   ): JSX.Element => {  
      const [ratingArray, setRatingArray] = useState<JSX.Element[]>(new Array(5).fill(<></>));  
  
      /// CODE ...
  
      return (  
         <div {...props} ref={ref}>  
            {ratingArray.map((r, i) => (  
               <span key={i}>{r}</span>  
            ))}  
         </div>  
      );  
   },  
);
```

И сейчас мы можем получить данные из неуправляемых компонентов 

![](_png/Pasted%20image%2020230213135146.png)

## 006 Обработка ошибок

Компонент `useForm` может вернуть нам состояние формы `formState`. Из этого состояния нам нужно только одно свойство `{ errors }`, которое мы получаем, когда формы встретились с поведением, которое приводит к ошибке (нам нужно, чтобы формы всегда были заполнены данными).

Конкретно в каждом неуправляемом компоненте формы мы добавляем в функцию `register` объект с опциями `{ required: { value: true, message: 'Заполните имя' } }`, в которой передаём требования данных формы `required`, где указываем обязательным, чтобы в формы обязательно попадало значение `value`. Если `value` нет, то выводим ошибку, которую укажем в `message`.
Если нам нужно накинуть данные требования внутрь компонента, который находится внутри `<Controller>`, то эти требования нужно внести в атрибут `rules`.

Далее нам нужно передать ошибки `errors`, которые мы получили из состояния `formState`, внутрь компонентов через атрибут `error`.

`components / ReviewForm / ReviewForm.tsx`
```TSX
export const ReviewForm = ({ productId, className, ...props }: ReviewFormProps): JSX.Element => {  
   const {  
      register,  
      control,  
      handleSubmit,  
      // тут получаем ошибки из состояния формы  
      formState: { errors },  
   } = useForm<IReviewForm>();  
  
   const onSubmit = (data: IReviewForm) => {  
      console.log(data);  
   };  
  
   return (  
      <form onSubmit={handleSubmit(onSubmit)}>  
         <div className={cn(styles.reviewForm, className)} {...props}>  
            <Input  
               {...register('name', 
	               { required: 
		               { value: true, message: 'Заполните имя' } 
		        })}  
               placeholder='Имя'  
               error={errors.name}  
            />  
            <Input  
               // Указываем требования по обязательным условиям полей  
               {...register('title', {  
                  required: { value: true, message: 'Заполните заголовок' },  
               })}  
               placeholder='Заголовок отзыва'  
               className={styles.title}  
               //передаём ошибку внутрь компонента  
               error={errors.title}  
            />  
            <div className={styles.rating}>  
               <span>Оценка:</span>  
               <Controller  
                  control={control}  
                  name='rating'  
                  // аналог атрибута опций функции register  
                  rules={{  
                     required: { value: true, message: 'Укажите рейтинг' },  
                  }}  
                  render={({ field }) => (  
                     <Rating  
                        isEditable  
                        ref={field.ref}  
                        rating={field.value}  
                        setRating={field.onChange}  
                        error={errors.rating}  
                     />  
                  )}  
               />  
            </div>  
            <Textarea  
               {...register('description', {  
                  required: { value: true, message: 'Заполните заголовок' },  
               })}  
               placeholder='Текст отзыва'  
               className={styles.description}  
               error={errors.description}  
            />  
            <div className={styles.submit}>  
               <Button appearance='primary'>Отправить</Button>  
               <span className={styles.info}>  
                  * Перед публикацией отзыв пройдет предварительную модерацию и проверку  
               </span>  
            </div>  
         </div>  
         <div className={styles.success}>  
            <div className={styles.successTitle}>Ваш отзыв отправлен</div>  
            <div>Спасибо, ваш отзыв будет опубликован после проверки.</div>  
            <CloseIcon className={styles.close} />  
         </div>  
      </form>  
   );  
};
```

Далее нужно в интерфейсах компонентов добавить пропс `error`, который мы передаём из родительского компонента, чтобы иметь возможность написать логику реагирования компонента на попадение в него ошибки

`components / Textarea / Textarea.props.ts`
```TS
import { DetailedHTMLProps, TextareaHTMLAttributes } from 'react';  
import { FieldError } from 'react-hook-form';  
  
export interface TextareaProps  
   extends DetailedHTMLProps<TextareaHTMLAttributes<HTMLTextAreaElement>, HTMLTextAreaElement> {  
   error?: FieldError;  
}
```

`components / Input / Input.props.ts`
```TS
export interface InputProps  
   extends DetailedHTMLProps<InputHTMLAttributes<HTMLInputElement>, HTMLInputElement> {  
   error?: FieldError;  
}
```

`components / Rating / Rating.props.ts`
```TS
export interface RatingProps  
   extends DetailedHTMLProps<HTMLAttributes<HTMLDivElement>, HTMLDivElement> {  
   isEditable?: boolean;  
   rating: number;  
   setRating?: (rating: number) => void;  
   error?: FieldError;  
}
```

Далее мы должны задать определённый стиль для самих `input`, `Rating` и `textarea`, если ошибка в принципе была передана, а так же вывести саму ошибку под компонентом формы

Инпут:

`components / Input / Input.tsx`
```TSX
export const Input = forwardRef(  
   (  
      { className, error, ...props }: InputProps,  
      ref: ForwardedRef<HTMLInputElement>,  
   ): JSX.Element => {  
      return (  
         <div className={cn(className, styles.inputWrapper)}>  
            <input  
               ref={ref}  
               className={cn(styles.input, {  
                  [styles.error]: error,  
               })}  
               {...props}  
            />  
            {error && <span className={styles.errorMessage}>{error.message}</span>}  
         </div>  
      );  
   },  
);
```

`components / Input / Input.module.css`
```CSS
.inputWrapper {  
   position: relative;  
}  
  
.input {  
   padding: 7px 15px;  
  
   color: var(--black);  
   border: none;  
   outline-color: var(--primary);  
   background: var(--white);  
   box-shadow: 0px 4px 4px rgba(0, 0, 0, 0.05);  
   border-radius: 5px;  
  
   font-size: 16px;  
   line-height: 22px;  
   font-family: var(--font-family);  
}  
  
.input::placeholder {  
   color: var(--gray);  
}  
  
.error {  
   border: 1px solid var(--red);  
}  
  
.errorMessage {  
   position: absolute;  
   bottom: -20px;  
   left: 12px;  
  
   color: var(--red);  
}
```

Текстареа:

`components / Textarea / Textarea.tsx`
```TSX
export const Textarea = forwardRef(  
   (  
      { error, className, ...props }: TextareaProps,  
      ref: ForwardedRef<HTMLTextAreaElement>,  
   ): JSX.Element => {  
      return (  
         <div className={cn(styles.textareaWrapper, className)}>  
            <textarea  
               ref={ref}  
               className={cn(styles.textarea, {  
                  [styles.error]: error,  
               })}  
               {...props}  
            />  
            {error && <span className={styles.errorMessage}>{error.message}</span>}  
         </div>  
      );  
   },  
);
```

`components / Textarea / Textarea.module.css`
```CSS
.textarea {  
   padding: 7px 15px;  
  
   width: 100%;  
  
   color: var(--black);  
   border: none;  
   outline-color: var(--primary);  
   background: var(--white);  
   box-shadow: 0px 4px 4px rgba(0, 0, 0, 0.05);  
   border-radius: 5px;  
  
   font-size: 16px;  
   line-height: 22px;  
   font-family: var(--font-family);  
}  
  
.textarea::placeholder {  
   color: var(--gray);  
}  
  
.textareaWrapper {  
   position: relative;  
}  
  
.error {  
   border: 1px solid var(--red);  
}  
  
.errorMessage {  
   position: absolute;  
   bottom: -15px;  
   left: 12px;  
  
   color: var(--red);  
}
```

Компонент рейтинга:

`components / Rating / Rating.tsx`
```TSX
export const Rating = forwardRef(  
   (  
      { isEditable = false, className, error, rating, setRating, ...props }: RatingProps,  
      ref: ForwardedRef<HTMLDivElement>,  
   ): JSX.Element => {  
      const [ratingArray, setRatingArray] = useState<JSX.Element[]>(new Array(5).fill(<></>));  
  
      /// CODE ...
  
      return (  
         <div  
            className={cn(className, styles.ratingWrapper, {  
               [styles.error]: error,  
            })}  
            {...props}  
            ref={ref}  
         >            {ratingArray.map((r, i) => (  
               <span key={i}>{r}</span>  
            ))}  
            {error && <span className={styles.errorMessage}>{error.message}</span>}  
         </div>  
      );  
   },  
);
```

`components / Rating / Rating.module.css`
```CSS
.filled svg {  
   fill: var(--primary);  
}  
  
.star svg {  
   margin-right: 5px;  
}  
  
.editable {  
   cursor: pointer;  
}  
  
.ratingWrapper {  
   position: relative;  
}  
  
.error {  
   border: 1px solid var(--red);  
   border-radius: 5px;  
}  
  
.errorMessage {  
   position: absolute;  
   bottom: -20px;  
   left: 5px;  
  
   color: var(--red);  
}
```

Итог: теперь при нажатии на кнопку отправки формы у нас появляются сообщения у пустых форм и указатель сразу попадает на первую пустую форму, чтобы пользователь смог сразу начать её вводить

![](_png/Pasted%20image%2020230213161143.png)

## 008 Отправка запроса со страницы















## 009 useRef







## 010 Упражнение - Исправление бага useReducer







