
## 001 Компонент отзыва

Сейчас нужно реализовать компонент отзыва. 
Он будет в себя принимать те же пропсы, что описаны в `ReviewModel`

`components / Review / Review.props.ts`
```TS
import { DetailedHTMLProps, HTMLAttributes } from 'react';  
import { ReviewModel } from '../../interfaces/product.interface';  
  
export interface ReviewProps  
   extends DetailedHTMLProps<HTMLAttributes<HTMLDivElement>, HTMLDivElement> {  
   review: ReviewModel;  
}
```

Сам компонент обзора:

`components / Review / Review.tsx`
```TSX
import React from 'react';
import cn from 'classnames';
import { format } from 'date-fns';
import { ru } from 'date-fns/locale';
import styles from './Review.module.css';
import UserIcon from './user.svg';
import { ReviewProps } from './Review.props';
import { Rating } from '../Rating/Rating';

export const Review = ({ review, className, ...props }: ReviewProps): JSX.Element => {
	const { name, title, rating, description, createdAt } = review;

	return (
		<div className={cn(styles.review, className)} {...props}>
			<UserIcon className={styles.user} />
			<div className={styles.title}>
				<span className={styles.name}>{name}:</span>&nbsp;&nbsp;
				<span>{title}</span>
			</div>
			<div className={styles.date}>
				{/*
				 * создаём новую дату из createdAt,
				 * далее указываем дату (заглавные - пропись)
				 * и потом указываем язык
				 */}
				{format(new Date(createdAt), 'dd MMMM yyyy', { locale: ru })}
			</div>
			<div className={styles.rating}>
				<Rating rating={rating} />
			</div>
			<div className={styles.description}>{description}</div>
		</div>
	);
};
```

Стили компонента обзора:

`components / Review / Review.module.css`
```CSS
.review {  
   display: grid;  
   grid-template-columns: [start] auto 1fr auto auto [end];  
   align-items: center;  
   gap: 10px;  
  
   font-size: 14px;  
   line-height: 24px;  
}  
  
.description {  
   grid-column: start / end;  
}  
  
.date {  
   margin-right: 10px;  
}  
  
.name {  
   font-weight: bold;  
}  
  
@media (max-width: 640px) {  
   .review {  
      grid-template-columns: [start] 30px [titlestart] auto [dateend] 1fr [end];  
   }  
  
   .title {  
      grid-column: titlestart / end;  
   }  
  
   .date {  
      grid-column: start / dateend;  
   }  
}  
  
@media (max-width: 480px) {  
  
   .rating {  
      grid-column: start / end;  
   }  
  
   .date {  
      grid-column: start / end;  
   }  
}
```

Сокращаем путь до компонента

`components / index.ts`
```TS
export * from './Review/Review';
```

Компонент отзыва будет выводить в отдельной карточке, которая будет изначально закрыта. Для открытия и закрытия будем использовать `useState`, который будет изменяться при нажатии на кнопку в первой карточке

`components / Product / Product.tsx`
```TSX
export const Product = ({ product }: ProductProps): JSX.Element => {  
   const [isReviewOpened, setIsReviewOpened] = useState<boolean>(false);  
  
   return (  
      <>  
         {/* обернём продукт в карточку */}  
         <Card className={styles.product}>  
            /// CODE ....
            
            {/* тут будут находиться кнопки */}
				<div className={styles.actions}>
					<Button appearance={'primary'}>Узнать подробнее</Button>
					<Button
						appearance={'ghost'}
						arrow={isReviewOpened ? 'down' : 'right'}
						className={styles.review}
						{/* меняем состояние отзывов */}
						onClick={() => setIsReviewOpened(!isReviewOpened)}
					>
						Читать отзывы
					</Button>
				</div>
         </Card>  
         <Card
				color={'blue'}
				className={cn(styles.reviews, {
					[styles.opened]: isReviewOpened,
					[styles.closed]: !isReviewOpened,
				})}
			>
				{product.reviews.map(r => (
					<>
						<Review key={r._id} review={r} />
						<Divider />
					</>
				))}
			</Card>
      </>  
   );  
};
```

Стили для открытого и закрытого меню с отзывами

`components / Product / Product.module.css`
```CSS
/*
	* Вторая карточка
*/

.opened {
	max-height: auto;
	padding: 30px;
}

/* чтобы нормально заанимировать изменение высоты, нам нельзя использовать display: none */
.closed {
	max-height: 0;
	padding: 0;
	overflow: hidden;
}
```

Итог:

![](_png/Pasted%20image%2020230208102456.png)

## 002 Форма отзыва

Компонент формы будет на вход принимать в себя `id` продукта, к которому он относится

`components / ReviewForm / ReviewForm.props.ts`
```TS
import { DetailedHTMLProps, HTMLAttributes } from 'react';

export interface ReviewFormProps
	extends DetailedHTMLProps<HTMLAttributes<HTMLDivElement>, HTMLDivElement> {
	productId: string;
}
```

Сама форма добавления нового отзыва состоит из уже подготовленных компонентов ввода `Input` с `Textarea` и выглядит следующим образом:

`components / ReviewForm / ReviewForm.tsx`
```TSX
import React from 'react';
import cn from 'classnames';
import styles from './ReviewForm.module.css';
import { ReviewFormProps } from './ReviewForm.props';
import { Input } from '../Input/Input';
import { Rating } from '../Rating/Rating';
import { Textarea } from '../Textarea/Textarea';
import { Button } from '../Button/Button';
import CloseIcon from './close.svg';

export const ReviewForm = ({ productId, className, ...props }: ReviewFormProps): JSX.Element => {
	return (
		<>
			<div className={cn(styles.reviewForm, className)} {...props}>
				<Input placeholder={'Имя'} />
				<Input placeholder={'Заголовок'} className={styles.title} />
				<div className={styles.rating}>
					<span>Оценка:</span>
					<Rating isEditable={true} rating={0} />
				</div>
				<Textarea placeholder={'Текст отзыва'} className={styles.description} />
				<div className={styles.submit}>
					<Button className={styles.button} appearance={'primary'}>
						Отправить
					</Button>
					<span className={styles.info}>
						* Перед публикацией отзыв пройдет предварительную модерацию и проверку
					</span>
				</div>
			</div>

			{/* это оповещение, которое отправится после сабмита нового отзыва */}
			<div className={styles.success}>
				<div className={styles.successTitle}>Ваш отзыв отправлен!</div>
				<div className={styles.successDescription}>
					Спасибо, ваш отзыв будет опубликован после проверки.
				</div>
				<CloseIcon className={styles.close} />
			</div>
		</>
	);
};
```

Сокращаем путь до компонента

`components / index.ts`
```TS
export * from './ReviewForm/ReviewForm';
```

Стили компонента с адаптивом:

`components / ReviewForm / ReviewForm.module.css`
```CSS
.reviewForm {
	display: grid;
	grid-template-columns: [start] auto 1fr auto [end];
	align-items: center;
	gap: 20px 30px;

	margin-bottom: 20px; /* отбиваем снизу уведомление об отправке */

	font-size: 14px;
	line-height: 24px;
}

.description, .submit {
	grid-column: start / end;
}

.title {
	/* инпут с заголовком прибился к левому краю */
	justify-self: left;
}

.button {
	margin-right: 20px;
}

.rating {
	display: grid;
	grid-template-columns: auto 1fr;
	gap: 20px;
}

.success {
	position: relative;

	padding: 20px;

	border-radius: 5px;

	background: var(--green-light);
}

.successTitle {
	font-weight: bold;
}

.close {
	position: absolute;
	top: 20px;
	right: 20px;
	cursor: pointer;
}

@media (max-width: 1100px) {
	.reviewForm {
		grid-template-columns: [start] 1fr 1fr [end];
	}

	.title {
		/* чтобы инпут с заголовком не прибивался к левому краю */
		justify-self: normal;
	}

	.rating {
		grid-column: start / end;
	}
}

@media (max-width: 640px) {
	.reviewForm {
		grid-template-columns: [start] 1fr [end];
	}
}
```

И тут мы выводим форму  добавления обзора `ReviewForm`

`components / Product / Product.tsx`
```TSX
<Card
	color={'blue'}
	className={cn(styles.reviews, {
		[styles.opened]: isReviewOpened,
		[styles.closed]: !isReviewOpened,
	})}
>
	{product.reviews.map(r => (
		<>
			<Review key={r._id} review={r} />
			<Divider />
		</>
	))}
	
	{/* форма написания обзора */}
	<ReviewForm productId={product._id} />
</Card>
```

Итог:

![](_png/Pasted%20image%2020230208195220.png)


## 003 useForm

Первым делом нужно сказать, что события реакта и события в DOM - это отдельные вещи. Между обоими деревьями есть прослойка, которая проксирует их взаимодействия (ветка реакта / ветка html и между ними сравнение)  

![](_png/Pasted%20image%2020230208200314.png)

При работе с формами внутри реакта, мы можем работать собственными силами или использовать готовые библиотеки, которые воспроизводят нужный нам функционал. Минусом второго подхода является то, что библиотека несёт за собой дополнительную зависимость и дополнительный вес на страницу, а так же эту зависимость нужно поддерживать и своевременно обновлять.

Если:
- Формы присутствуют только на регистрации или они простые, то самым оптимальным решением будет самому реализовать формы
- Формы используются в большом количестве (работа с паспортными данными или CRM-система), то тут уже можно использовать библиотеку 

![](_png/Pasted%20image%2020230208200534.png)

Управляемый компонент - это компонент, значения которого управляются в стейте этого же компонента.

Если мы возьмём обычный `<input>`, то его значение хранится в DOM-дереве. Если мы берём тот же компонент `<Rating />`, то его состояние (значение рейтинга) хранится в самом компоненте рейтинга.

![](_png/Pasted%20image%2020230208201400.png)

В проекте будет использоваться ==React Hook Form==

![](_png/Pasted%20image%2020230208201633.png)

Параметры, которые возвращает хук формы `useForm`: 

![](_png/Pasted%20image%2020230208202144.png)

Оформление неуправляемых компонентов:

![](_png/Pasted%20image%2020230208202410.png)

Пример оформления управляемого компонента: контроллер указывает на то, чем он будет управлять

![](_png/Pasted%20image%2020230208202559.png)

## 004 Работа с формами

Прежде всего нужно поправить старые ошибки. Если мы используем списки и выводим повторяющиеся элементы, то нам нужно атрибут `key` переносить на самый внешний элемент

![](_png/Pasted%20image%2020230212153855.png)

Далее нужно установить модуль работы с формами внутри реакта

```bash
npm i react-hook-form
```










## 005 Проброс ref







## 006 Обработка ошибок







## 007 Упражнение - Обработка ошибок Rating







## 008 Отправка запроса со страницы







## 009 useRef







## 010 Упражнение - Исправление бага useReducer







