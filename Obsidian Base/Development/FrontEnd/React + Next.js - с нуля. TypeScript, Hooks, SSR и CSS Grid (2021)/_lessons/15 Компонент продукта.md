
## 001 Компонент Input

Компонент будет получать пропсы типа `HTMLInputElement`

`components / Input / Input.props.ts`
```TS
import { DetailedHTMLProps, InputHTMLAttributes } from 'react';  
  
export interface InputProps  
   extends DetailedHTMLProps<InputHTMLAttributes<HTMLInputElement>, HTMLInputElement> {}
```

Тут мы просто передаём пропсы и добавляем свои и передаваемые классы со стилями

`components / Input / Input.tsx`
```TSX
export const Input = ({ className, ...props }: InputProps): JSX.Element => {
	return <input className={cn(className, styles.input)} {...props} />;
};
```

Стилизуем элемент. Обязательно указываем свойство `outline`, которое позволяет ориентироваться табами по странице (можем даже для этого пойти не по макету)

`components / Input / Input.module.css`
```CSS
.input {
	padding: 7px 15px; /* отступ от внутреннего контента */

	color: var(--black);
	border: none;
	outline-color: var(--black); /* аутлайн обязательно нужен, так как он позволяет навигироваться по инпутам */
	background: var(--white);

	box-shadow: 0px 4px 4px rgba(0, 0, 0, 0.05);
	border-radius: 5px;

	font-family: var(--font-family); /* в инпуте нужно насильно указать наш шрифт */
	font-size: 16px;
	line-height: 22px;
}

.input::placeholder {
	color: var(--gray);
}
```

Сокращаем путь до компонента

`components / index.ts`
```TS
export * from './Input/Input';
```

Так мы его добавляем на страницу

`pages / index.tsx`
```TSX
<Input placeholder={'Тест'} />
```

И так выглядит итоговый инпут

![](_png/Pasted%20image%2020230206104140.png)

## 002 Упражнение - Компонент Textarea

Тут мы создаём компонент `textarea`, который принимает в себя все пропсы и стили (кастом + пропсы)

`components / Textarea / Textarea.tsx`
```TSX
export const Textarea = ({ className, ...props }: TextareaProps): JSX.Element => {
	return <textarea className={cn(className, styles.input)} {...props} />;
};
```

Представленный компонент будет в себя принимать те же пропсы, что и `HTMLTextAreaElement` и атрибуты `TextareaHTMLAttributes` 

`components / Textarea / Textarea.props.ts`
```TS
import { DetailedHTMLProps, TextareaHTMLAttributes } from 'react';  
  
export interface TextareaProps  
   extends DetailedHTMLProps<TextareaHTMLAttributes<HTMLTextAreaElement>, HTMLTextAreaElement> {}
```

Стили остаются те же самые, что и у инпута

`components / Textarea / Textarea.module.css`
```CSS
.input {
	padding: 7px 15px; /* отступ от внутреннего контента */

	color: var(--black);
	border: none;
	outline-color: var(--black); /* аутлайн обязательно нужен, так как он позволяет навигироваться по инпутам */
	background: var(--white);

	box-shadow: 0px 4px 4px rgba(0, 0, 0, 0.05);
	border-radius: 5px;

	font-family: var(--font-family); /* в инпуте нужно насильно указать наш шрифт */
	font-size: 16px;
	line-height: 22px;
}

.input::placeholder {
	color: var(--gray);
}
```

Далее сокращаем путь к компоненту

`components / index.ts`
```TS
export * from './Textarea/Textarea';
```

И используем компонент `Textarea` 

`pages / index.tsx`
```TSX
<Textarea placeholder={'Вводим текст'} />
```

![](_png/Pasted%20image%2020230206105619.png)

## 003 Компонент поиска

В качестве пропсов поиск будет принимать атрибуты дива 

`components / Search / Search.props.ts`
```TS
import { DetailedHTMLProps, HTMLAttributes } from 'react';

export interface SearchProps extends DetailedHTMLProps<HTMLAttributes<HTMLDivElement>, HTMLDivElement> {}
```

Так выглядит сам компонент поиска, который ищет значения по определённому `url` и генерит под результаты поиска отдельный роут 

`components / Search / Search.tsx`
```TSX
import { useState } from 'react';
import cn from 'classnames';
import { SearchProps } from './Search.props';
import styles from './Search.module.css';
import { Input } from '../Input/Input';
import { Button } from '../Button/Button';
import GlassIcon from './glass.svg';
import { useRouter } from 'next/router';

export const Search = ({ className, ...props }: SearchProps): JSX.Element => {
	const [search, setSearch] = useState<string>('');
	const router = useRouter();

	// функция перехода по нужному нам url
	const goToSearch = () => {
		// метод push позволяет запушить новое значение url в состояние
		router.push({
			pathname: '/search',
			query: {
				q: search,
			},
		});
	};

	// данная функция будет триггерить выполнение поиска на клавишу
	const handleKeyDown = (e: KeyboardEvent) => {
		// при клике на enter...
		if (e.key == 'Enter') {
			// ... будет выполняться поиск
			goToSearch();
		}
	};

	return (
		<div className={cn(className, styles.search)} {...props}>
			{/*
			 * Изначальное значение поиска = state
			 * Каждый раз, когда мы что-то вводим, это значение будет записываться в стейт
			 */}
			<Input
				className={styles.input}
				placeholder={'Поиск...'}
				// значением будет начальное значение стейта
				value={search}
				// при изменении
				onChange={e => setSearch(e.target.value)}
				// при нажатии на клавишу
				onKeyDown={handleKeyDown}
			/>
			<Button appearance={'primary'} className={styles.button} onClick={goToSearch}>
				<GlassIcon />
			</Button>
		</div>
	);
};
```

Поиск делаем релативным, а уже кнопку делаем с абсолютным позиционированием, чтобы она была на уровне поиска

`components / Search / Search.module.css`
```CSS
.search {
	position: relative;
	width: 100%;
}

.input {
	width: 100%;
}

.button {
	position: absolute;
	top: 3px;
	right: 3px;

	width: 30px;
	height: 30px;

	padding: 8px;
}
```

Добавляем поиск в сайдбар

`layout / Sidebar / Sidebar.tsx`
```TSX
export const Sidebar = ({ className, ...props }: SidebarProps): JSX.Element => {
	return (
		<div className={cn(className, styles.sidebar)} {...props}>
			<Logo className={styles.logo} />
			<Search />
			<Menu />
		</div>
	);
};
```

Сокращаем путь до импорта

`components / index.ts`
```TS
export * from './Search/Search';
```

И примерно так выглядит поиск на странице

![](_png/Pasted%20image%2020230206122237.png)

## 004 Компонент продукта - планирование

Далее нам нужно сверстать компонент с достаточно сложной сеткой. Чтобы упростить себе немного работу стоит сделать скриншот данного макета и попробовать разбить его сеткой

![](_png/Pasted%20image%2020230206124301.png)

Плюсы:
1) Тут используется всего одна сетка
2) Теги курса и {цена, кредит и отзывы} находятся в одной строке, что позволит нам не выравнивать их друг относительно друга

Минусы:
1) Придётся использовать отрицательные марджины, чтобы прибивать элементы к нужным нам местам

![](_png/Pasted%20image%2020230206123648.png)

Плюсы:
1) Упрощается вёрстка каждой сетки

Минусы:
1) Сеток 3
2) Нужно выравнивать элементы из разных сеток друг под друга

![](_png/Pasted%20image%2020230206124533.png)

Плюсы:
1) Позволит точно сверстать компонент

Минусы:
1) Вёрстка будет сложной
2) Используется 7 колонок

![](_png/Pasted%20image%2020230206124822.png)

Первым делом нужно определить получаемые пропсы компонентом: это пропсы компонента

`layout / Product / Product.module.ts`
```TS
import { DetailedHTMLProps, HTMLAttributes } from 'react';
import { ProductModel } from '../../interfaces/product.interface';

export interface ProductProps
	extends DetailedHTMLProps<HTMLAttributes<HTMLDivElement>, HTMLDivElement> {
	product: ProductModel;
}
```

Далее нужно создать компонент продукта

`layout / Product / Product.tsx`
```TSX
export const Product = ({ product }: ProductProps): JSX.Element => {
	return <div>{product.title}</div>;
};
```

Сокращаем путь до компонента

`components / index.ts`
```TS
export * from './Product/Product';
```

И далее вставляем компонент `<Product>` в компонент страницы

`page-components / TopPageComponent / TopPage.component.tsx`
![](_png/Pasted%20image%2020230206130539.png)


## 005 Компонент продукта - сетка














## 006 Компонент продукта - стили











## 007 Склонение слов











## 008 Компонент Image











## 009 Компонент продукта - адаптив















