#ARIA #Accessability

## 001 Виды доступности

Что включает в себя доступность сайта?:
- Цветовая схема. Сложно будет разобрать определённые малоконтрастные цвета на странице, если экран нашего устройства плохой, мы пользуемся проектором или на экран падает свет
- Работа с клавиатуры. Части людей удобно пользоваться компьютером только с помощью клавиатуры / у человека нет мыши / у человека Туннельный синдром, что мешает пользоваться мышкой
- Увеличение шрифта. Кому-то удобнее увеличить размер сайта, чтобы шрифт был виднее.
- Работа со скринридером. Адаптация сайта под слабовидящих.
- Уменьшение движения. Адаптация сайта под людей, которые плохо переносят анимации на сайте. Если на ПК включена функция уменьшения движения, то и сайт должен поддерживать такой функционал.

![](_png/Pasted%20image%2020230217154619.png)

Сайт нормально себя ведёт при сильном увеличении, поэтому четвёртый пункт уже реализован

![](_png/Pasted%20image%2020230217155443.png)

## 002 Цветовая доступность

Первым делом, чтобы понять, какие проблемы могут быть связаны с цветами, можно проверить параметр Accessability через Lighthouse. 

Сейчас нужно взглянуть на контрастность цветов - конкретно мы можем перейти к определённым элементам, которые имеют неподходящие цвета

![](_png/Pasted%20image%2020230217162901.png)

Далее мы можем быстро перейти на страницу, выделить нужный элемент для изменения, тыкнуть по квадрату его цвета, раскрыть параметр подходящих контрастных цветов и выбрать тот, что нам предлагает девтулз. Таким образом мы получим актуальный цвет, который будет иметь достаточную контрастность, чтобы быть рассмотренным на странице.  
==Contrast ratio== зависит не только от самого цвета, но и от размера шрифта. Чем больше шрифт, тем меньше ему нужен контрастный цвет, чтобы различаться на странице.

![](_png/Pasted%20image%2020230217163213.png)

Так же нужно отметить, что мы имеем уровни контрастности:
- АА - достаточная контрастность. Используем обычно
- ААА - самый контрастный подходящий цвет. Используем, если нужно оптимизировать сайт под слабовидящих

![](_png/Pasted%20image%2020230217163227.png)

И далее нужно просто заменить корневые цвета на странице, чтобы поменялись все нужные нам элементы

`styles / global.css`
```CSS
:root {  
   --primary: #7351f5;
   --green: #077b4b;
}
```

Данный плагин позволит посмотреть на сайт совзгляда человека с определёнными нарушениями в цветовосприятии

![](_png/Pasted%20image%2020230217165058.png)

## 003 Доступность меню с клавиатуры

За доступность элементов с клавиатуры отвечает атрибут `tabIndex={число}`, где число отвечает за доступность элемента для клавиатуры:
- `0` - стандартная доступность, где элемент встаёт в очередь с остальными элементами
- `-1` - элемент не доступен для выбора с клавиатуры
- `> 0` - работает как `z-index` и чем выше число, тем первее выделится элемент (является не самой лучшей практикой, кроме некоторых исключений)

В меню страницы было внесено достаточно много изменений, чтобы поддерживать клавиатуру:
- была добавлена функция `openSecondLevelKey`, которая позволяет открыть список меню при нажатии на пробел или энтер
- в качестве события нажатия клавиши, был использован тип `KeyboardEvent`, который был взят из реакта
- далее мы указали для второго уровня меню `tabIndex={0}`, чтобы он протыкивался
- повесили на этот уровень функцию `openSecondLevelKey`
- в функции `buildThirdLevel` добавили третий параметр, который принимал в себя состояние открытости меню - если оно закрыто, то индекс для таба весь список принимал `-1`

`Layout / Menu / Menu.tsx`
```TSX
import styles from './Menu.module.css';  
import cn from 'classnames';  
import { useContext, KeyboardEvent } from 'react';  
import { AppContext } from '../../context/app.context';  
import { FirstLevelMenuItem, PageItem } from '../../interfaces/menu.interface';  
import Link from 'next/link';  
import { useRouter } from 'next/router';  
import { firstLevelMenu } from '../../helpers/helpers';  
import { motion } from 'framer-motion';  
  
export const Menu = (): JSX.Element => {  
   const { menu, setMenu, firstCategory } = useContext(AppContext);  
   const router = useRouter();  
  
   const variants = {  
      hidden: {  
         marginBottom: 0,  
      },  
      visible: {  
         marginBottom: 20,  
         transition: {  
            when: 'beforeChildren',  
            staggerChildren: 0.1,  
         },  
      },  
   };  
  
   const variantsChildren = {  
      hidden: { opacity: 0, height: 0 },  
      visible: { opacity: 1, height: 29 },  
   };  
  
   const openSecondLevel = (secondCategory: string) => {  
      setMenu &&  
         setMenu(  
            menu.map(m => {  
               if (m._id.secondCategory == secondCategory) {  
                  m.isOpened = !m.isOpened;  
               }  
               return m;  
            }),  
         );  
   };  
  
   // эта функция будет открывать выбранное нами с клавиатуры меню через пробел  
   const openSecondLevelKey = (key: KeyboardEvent, secondCategory: string) => {  
      if (key.code == 'Space' || key.code == 'Enter') {  
         // предотвращаем стандартную логику поведения при нажатии клавиши (пробел - пролистывание)  
         key.preventDefault();  
         // переиспользуем функцию раскрытия меню  
         openSecondLevel(secondCategory);  
      }  
   };  
  
   const buildFirstLevel = () => {  
      return (  
         <>  
            {firstLevelMenu.map(m => (  
               <div key={m.route}>  
                  <Link href={`/${m.route}`}>  
                     <div  
                        className={cn(styles.firstLevel, {  
                           [styles.firstLevelActive]: m.id == firstCategory,  
                        })}  
                     >  
                        {m.icon}  
                        <span>{m.name}</span>  
                     </div>  
                  </Link>  
                  {m.id == firstCategory && buildSecondLevel(m)}  
               </div>  
            ))}  
         </>  
      );  
   };  
  
   const buildSecondLevel = (menuItem: FirstLevelMenuItem) => {  
      return (  
         <div className={styles.secondBlock}>  
            {menu.map(m => {  
               if (m.pages.map(p => p.alias).includes(router.asPath.split('/')[2])) {  
                  m.isOpened = true;  
               }  
               return (  
                  <div key={m._id.secondCategory}>  
                     <div  
                        className={styles.secondLevel}  
                        /* указываем табИндекс */  
                        tabIndex={0}  
                        /* присваиваем открытие по пробелу */  
                        onKeyDown={(key: KeyboardEvent) =>  
                           openSecondLevelKey(key, m._id.secondCategory)  
                        }  
                        onClick={() => openSecondLevel(m._id.secondCategory)}  
                     >  
                        {m._id.secondCategory}  
                     </div>  
  
                     {/* родительский элемент для третьего уровня меню */}  
                     <motion.div  
                        layout  
                        initial={m.isOpened ? 'visible' : 'hidden'}  
                        animate={m.isOpened ? 'visible' : 'hidden'}  
                        variants={variants}  
                        className={cn(styles.secondLevelBlock)}  
                     >  
                        {/* тут передадим парамер состояния октрытости меню */} 
                        {buildThirdLevel(m.pages, menuItem.route, m.isOpened ?? false)}  
                     </motion.div>  
                  </div>  
               );  
            })}  
         </div>  
      );  
   };  
  
   const buildThirdLevel = (pages: PageItem[], route: string, isOpened: boolean) => {  
      return pages.map(p => (  
         <motion.div variants={variantsChildren} key={p._id}>  
            <Link  
               /* если список открыт, то по нему можно будет перейти с клавиатуры, если нет - то нельзя */  
               tabIndex={isOpened ? 0 : -1}  
               href={`/${route}/${p.alias}`}  
               className={cn(styles.thirdLevel, {  
                  [styles.thirdLevelActive]: `/${route}/${p.alias}` == router.asPath,  
               })}  
            >  
               {p.category}  
            </Link>  
         </motion.div>  
      ));  
   };  
  
   return <div className={styles.menu}>{buildFirstLevel()}</div>;  
};
```

Далее в стилях меню нужно убрать свойство `line-height`, которое искривляет аутлайн и уменьшить сам аутлайн внутрь, чтобы он не обрезался через `outline-offset`

`Layout / Menu / Menu.module.css`
```CSS
.secondLevel {  
   margin-bottom: 10px;  
  
   cursor: pointer;  
   text-transform: uppercase;  
  
   color: var(--gray-dark);  
  
   font-weight: 300;  
   font-size: 12px;  
}

.thirdLevel {  
   margin-bottom: 10px;  
   display: block;  
  
   cursor: pointer;  
  
   color: var(--gray-dark);  
   font-weight: 500;  
   font-size: 14px;  
  
	/*  
      уменьшаем аутлайн, чтобы он выглядел лучше      
      убираем line-height, чтобы аутлайн не был кривым  
	*/   
    outline-offset: -1px;  
}
```

Далее нам нужно сделать элемент, который позволит пропустить список меню и сразу попасть на контент:
- создаём состояние `isSkipLinkDisplayed`, которое будет отслеживать скрытость кнопки перехода на контент
- далее нужно получить референс на бади `bodyRef`
- далее нужно реализовать функцию `skipContentAction`, которая будет осуществлять переход на нужный элемент страницы
- далее реализуем в `return` вёрстке ссылку `<a>`, которая и будет осуществлять переход на этот бади. Этой ссылке нужно поставить самый высокий табиндекс на странице, присвоить функции при клавиатурном нажатии (переход на контент) и на фокусе (отображение)
- `<div>` с контентом нужно сделать кликабельным через табиндекс и в него нужно вставить референс

`layout / Layout / Layout.tsx`
```TSX
const Layout = ({ children }: LayoutProps): JSX.Element => {  
   const [isSkipLinkDisplayed, setIsSkipLinkDisplayed] = useState<boolean>(false);  
  
   const bodyRef = useRef<HTMLDivElement>(null);  
  
   const skipContentAction = (key: KeyboardEvent) => {  
      if (key.code == 'Space' || key.code == 'Enter') {  
         key.preventDefault();  
         bodyRef.current?.focus();  
      }  
  
      setIsSkipLinkDisplayed(false);  
   };  
  
   return (  
      <div className={styles.wrapper}>  
         <a  
            tabIndex={1}  
            onFocus={() => setIsSkipLinkDisplayed(true)}  
            onKeyDown={skipContentAction}  
            href='#'  
            className={cn(styles.skipLink, {  
               [styles.displayed]: isSkipLinkDisplayed,  
            })}  
         >  
            Перейти сразу к содержанию  
         </a>  
         <Header className={styles.header} />  
         <Sidebar className={styles.sidebar} />  
         <div tabIndex={0} ref={bodyRef} className={styles.body}>  
            {children}  
         </div>  
         <Footer className={styles.footer} />  
         <Up />  
      </div>  
   );  
};
```

В стилях делаем скрытие элемента `skipLink` не через `display: none`, так как элемент не будет табательным - его нужно скрыть через оверфлоу и уменьшение высоты. Далее нам нужно убрать аутлайн с бади, чтобы он весь не выделялся.

`layout / Layout / Layout.module.css`
```CSS
.body {  
   grid-area: body;  
   outline: none;  
}  
  
.skipLink {  
   display: block;  
  
   position: fixed;  
   left: 100px;  
   top: 0;  
  
   height: 0;  
  
   overflow: hidden;  
  
   color: var(--white);  
   background: var(--primary);  
}  
  
.displayed {  
   height: auto;  
}
```

И сразу после строки поиска мы можем перейти первым табом на эту кнопку - она появится и скроется при табе

![](_png/Pasted%20image%2020230217185943.png)

## 004 Доступность форм с клавиатуры









## 005 Упражнение - доступность сортировки









## 006 ARIA атрибуты









## 007 Использование Screen Reader









## 008 Aria-label и aria-labelledby









## 009 Aria-hidden









## 010 Добавление landmarks









## 011 Доступность форм









## 012 Упражнение - Доступность оповещений









## 013 Доступность меню и списка









## 014 Уменьшение движения






