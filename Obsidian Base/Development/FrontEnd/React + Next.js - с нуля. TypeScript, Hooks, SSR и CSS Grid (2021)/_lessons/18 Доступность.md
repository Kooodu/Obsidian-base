#ARIA #Accessability

## 001 Виды доступности

Что включает в себя доступность сайта?:
- Цветовая схема. Сложно будет разобрать определённые малоконтрастные цвета на странице, если экран нашего устройства плохой, мы пользуемся проектором или на экран падает свет
- Работа с клавиатуры. Части людей удобно пользоваться компьютером только с помощью клавиатуры / у человека нет мыши / у человека Туннельный синдром, что мешает пользоваться мышкой
- Увеличение шрифта. Кому-то удобнее увеличить размер сайта, чтобы шрифт был виднее.
- Работа со скринридером. Адаптация сайта под слабовидящих.
- Уменьшение движения. Адаптация сайта под людей, которые плохо переносят анимации на сайте. Если на ПК включена функция уменьшения движения, то и сайт должен поддерживать такой функционал.

![](_png/Pasted%20image%2020230217154619.png)

Сайт нормально себя ведёт при сильном увеличении, поэтому четвёртый пункт уже реализован

![](_png/Pasted%20image%2020230217155443.png)

## 002 Цветовая доступность

Первым делом, чтобы понять, какие проблемы могут быть связаны с цветами, можно проверить параметр Accessability через Lighthouse. 

Сейчас нужно взглянуть на контрастность цветов - конкретно мы можем перейти к определённым элементам, которые имеют неподходящие цвета

![](_png/Pasted%20image%2020230217162901.png)

Далее мы можем быстро перейти на страницу, выделить нужный элемент для изменения, тыкнуть по квадрату его цвета, раскрыть параметр подходящих контрастных цветов и выбрать тот, что нам предлагает девтулз. Таким образом мы получим актуальный цвет, который будет иметь достаточную контрастность, чтобы быть рассмотренным на странице.  
==Contrast ratio== зависит не только от самого цвета, но и от размера шрифта. Чем больше шрифт, тем меньше ему нужен контрастный цвет, чтобы различаться на странице.

![](_png/Pasted%20image%2020230217163213.png)

Так же нужно отметить, что мы имеем уровни контрастности:
- АА - достаточная контрастность. Используем обычно
- ААА - самый контрастный подходящий цвет. Используем, если нужно оптимизировать сайт под слабовидящих

![](_png/Pasted%20image%2020230217163227.png)

И далее нужно просто заменить корневые цвета на странице, чтобы поменялись все нужные нам элементы

`styles / global.css`
```CSS
:root {  
   --primary: #7351f5;
   --green: #077b4b;
}
```

Данный плагин позволит посмотреть на сайт совзгляда человека с определёнными нарушениями в цветовосприятии

![](_png/Pasted%20image%2020230217165058.png)

## 003 Доступность меню с клавиатуры

За доступность элементов с клавиатуры отвечает атрибут `tabIndex={число}`, где число отвечает за доступность элемента для клавиатуры:
- `0` - стандартная доступность, где элемент встаёт в очередь с остальными элементами
- `-1` - элемент не доступен для выбора с клавиатуры
- `> 0` - работает как `z-index` и чем выше число, тем первее выделится элемент (является не самой лучшей практикой, кроме некоторых исключений)

В меню страницы было внесено достаточно много изменений, чтобы поддерживать клавиатуру:
- была добавлена функция `openSecondLevelKey`, которая позволяет открыть список меню при нажатии на пробел или энтер
- в качестве события нажатия клавиши, был использован тип `KeyboardEvent`, который был взят из реакта
- далее мы указали для второго уровня меню `tabIndex={0}`, чтобы он протыкивался
- повесили на этот уровень функцию `openSecondLevelKey`
- в функции `buildThirdLevel` добавили третий параметр, который принимал в себя состояние открытости меню - если оно закрыто, то индекс для таба весь список принимал `-1`

`Layout / Menu / Menu.tsx`
```TSX
import styles from './Menu.module.css';  
import cn from 'classnames';  
import { useContext, KeyboardEvent } from 'react';  
import { AppContext } from '../../context/app.context';  
import { FirstLevelMenuItem, PageItem } from '../../interfaces/menu.interface';  
import Link from 'next/link';  
import { useRouter } from 'next/router';  
import { firstLevelMenu } from '../../helpers/helpers';  
import { motion } from 'framer-motion';  
  
export const Menu = (): JSX.Element => {  
   const { menu, setMenu, firstCategory } = useContext(AppContext);  
   const router = useRouter();  
  
   const variants = {  
      hidden: {  
         marginBottom: 0,  
      },  
      visible: {  
         marginBottom: 20,  
         transition: {  
            when: 'beforeChildren',  
            staggerChildren: 0.1,  
         },  
      },  
   };  
  
   const variantsChildren = {  
      hidden: { opacity: 0, height: 0 },  
      visible: { opacity: 1, height: 29 },  
   };  
  
   const openSecondLevel = (secondCategory: string) => {  
      setMenu &&  
         setMenu(  
            menu.map(m => {  
               if (m._id.secondCategory == secondCategory) {  
                  m.isOpened = !m.isOpened;  
               }  
               return m;  
            }),  
         );  
   };  
  
   // эта функция будет открывать выбранное нами с клавиатуры меню через пробел  
   const openSecondLevelKey = (key: KeyboardEvent, secondCategory: string) => {  
      if (key.code == 'Space' || key.code == 'Enter') {  
         // предотвращаем стандартную логику поведения при нажатии клавиши (пробел - пролистывание)  
         key.preventDefault();  
         // переиспользуем функцию раскрытия меню  
         openSecondLevel(secondCategory);  
      }  
   };  
  
   const buildFirstLevel = () => {  
      return (  
         <>  
            {firstLevelMenu.map(m => (  
               <div key={m.route}>  
                  <Link href={`/${m.route}`}>  
                     <div  
                        className={cn(styles.firstLevel, {  
                           [styles.firstLevelActive]: m.id == firstCategory,  
                        })}  
                     >  
                        {m.icon}  
                        <span>{m.name}</span>  
                     </div>  
                  </Link>  
                  {m.id == firstCategory && buildSecondLevel(m)}  
               </div>  
            ))}  
         </>  
      );  
   };  
  
   const buildSecondLevel = (menuItem: FirstLevelMenuItem) => {  
      return (  
         <div className={styles.secondBlock}>  
            {menu.map(m => {  
               if (m.pages.map(p => p.alias).includes(router.asPath.split('/')[2])) {  
                  m.isOpened = true;  
               }  
               return (  
                  <div key={m._id.secondCategory}>  
                     <div  
                        className={styles.secondLevel}  
                        /* указываем табИндекс */  
                        tabIndex={0}  
                        /* присваиваем открытие по пробелу */  
                        onKeyDown={(key: KeyboardEvent) =>  
                           openSecondLevelKey(key, m._id.secondCategory)  
                        }  
                        onClick={() => openSecondLevel(m._id.secondCategory)}  
                     >  
                        {m._id.secondCategory}  
                     </div>  
  
                     {/* родительский элемент для третьего уровня меню */}  
                     <motion.div  
                        layout  
                        initial={m.isOpened ? 'visible' : 'hidden'}  
                        animate={m.isOpened ? 'visible' : 'hidden'}  
                        variants={variants}  
                        className={cn(styles.secondLevelBlock)}  
                     >  
                        {/* тут передадим парамер состояния октрытости меню */} 
                        {buildThirdLevel(m.pages, menuItem.route, m.isOpened ?? false)}  
                     </motion.div>  
                  </div>  
               );  
            })}  
         </div>  
      );  
   };  
  
   const buildThirdLevel = (pages: PageItem[], route: string, isOpened: boolean) => {  
      return pages.map(p => (  
         <motion.div variants={variantsChildren} key={p._id}>  
            <Link  
               /* если список открыт, то по нему можно будет перейти с клавиатуры, если нет - то нельзя */  
               tabIndex={isOpened ? 0 : -1}  
               href={`/${route}/${p.alias}`}  
               className={cn(styles.thirdLevel, {  
                  [styles.thirdLevelActive]: `/${route}/${p.alias}` == router.asPath,  
               })}  
            >  
               {p.category}  
            </Link>  
         </motion.div>  
      ));  
   };  
  
   return <div className={styles.menu}>{buildFirstLevel()}</div>;  
};
```

Далее в стилях меню нужно убрать свойство `line-height`, которое искривляет аутлайн и уменьшить сам аутлайн внутрь, чтобы он не обрезался через `outline-offset`

`Layout / Menu / Menu.module.css`
```CSS
.secondLevel {  
   margin-bottom: 10px;  
  
   cursor: pointer;  
   text-transform: uppercase;  
  
   color: var(--gray-dark);  
  
   font-weight: 300;  
   font-size: 12px;  
}

.thirdLevel {  
   margin-bottom: 10px;  
   display: block;  
  
   cursor: pointer;  
  
   color: var(--gray-dark);  
   font-weight: 500;  
   font-size: 14px;  
  
	/*  
      уменьшаем аутлайн, чтобы он выглядел лучше      
      убираем line-height, чтобы аутлайн не был кривым  
	*/   
    outline-offset: -1px;  
}
```

Далее нам нужно сделать элемент, который позволит пропустить список меню и сразу попасть на контент:
- создаём состояние `isSkipLinkDisplayed`, которое будет отслеживать скрытость кнопки перехода на контент
- далее нужно получить референс на бади `bodyRef`
- далее нужно реализовать функцию `skipContentAction`, которая будет осуществлять переход на нужный элемент страницы
- далее реализуем в `return` вёрстке ссылку `<a>`, которая и будет осуществлять переход на этот бади. Этой ссылке нужно поставить самый высокий табиндекс на странице, присвоить функции при клавиатурном нажатии (переход на контент) и на фокусе (отображение)
- `<div>` с контентом нужно сделать кликабельным через табиндекс и в него нужно вставить референс

`layout / Layout / Layout.tsx`
```TSX
const Layout = ({ children }: LayoutProps): JSX.Element => {  
   const [isSkipLinkDisplayed, setIsSkipLinkDisplayed] = useState<boolean>(false);  
  
   const bodyRef = useRef<HTMLDivElement>(null);  
  
   const skipContentAction = (key: KeyboardEvent) => {  
      if (key.code == 'Space' || key.code == 'Enter') {  
         key.preventDefault();  
         bodyRef.current?.focus();  
      }  
  
      setIsSkipLinkDisplayed(false);  
   };  
  
   return (  
      <div className={styles.wrapper}>  
         <a  
            tabIndex={1}  
            onFocus={() => setIsSkipLinkDisplayed(true)}  
            onKeyDown={skipContentAction}  
            href='#'  
            className={cn(styles.skipLink, {  
               [styles.displayed]: isSkipLinkDisplayed,  
            })}  
         >  
            Перейти сразу к содержанию  
         </a>  
         <Header className={styles.header} />  
         <Sidebar className={styles.sidebar} />  
         <div tabIndex={0} ref={bodyRef} className={styles.body}>  
            {children}  
         </div>  
         <Footer className={styles.footer} />  
         <Up />  
      </div>  
   );  
};
```

В стилях делаем скрытие элемента `skipLink` не через `display: none`, так как элемент не будет табательным - его нужно скрыть через оверфлоу и уменьшение высоты. Далее нам нужно убрать аутлайн с бади, чтобы он весь не выделялся.

`layout / Layout / Layout.module.css`
```CSS
.body {  
   grid-area: body;  
   outline: none;  
}  
  
.skipLink {  
   display: block;  
  
   position: fixed;  
   left: 100px;  
   top: 0;  
  
   height: 0;  
  
   overflow: hidden;  
  
   color: var(--white);  
   background: var(--primary);  
}  
  
.displayed {  
   height: auto;  
}
```

И сразу после строки поиска мы можем перейти первым табом на эту кнопку - она появится и скроется при табе

![](_png/Pasted%20image%2020230217185943.png)

## 004 Доступность форм с клавиатуры

Далее основной задачей будет реализовать добавление управления форм с клавиатуры.

- В компоненте продуктов сделаем сразу выделение всей формы, когда мы нажимаем на отзывы или при открытии формы отзывов
- Далее на карточку нужно навесить табиндекс, если та открыта
- Далее в ревьюформу закидываем состояние открытости этой формы

`components / Product / Product.tsx`
```TSX
export const Product = motion(  
   forwardRef(  
      (  
         { product, className, ...props }: ProductProps,  
         ref: ForwardedRef<HTMLDivElement>,  
      ): JSX.Element => {  
         const [isReviewOpened, setIsReviewOpened] = useState<boolean>(false);  
  
         const reviewRef = useRef<HTMLDivElement>(null);  
  
         const scrollToReview = () => {  
            setIsReviewOpened(true);  
  
            reviewRef.current?.scrollIntoView({  
               behavior: 'smooth',  
               block: 'center',  
            });  
  
            // при скролле во вью, будем выделять саму форму  
            reviewRef.current?.focus();  
         };  
  
         const variants = {  
            visible: { opacity: 1, height: 'auto' },  
            hidden: { opacity: 0, height: 0 },  
         };  
  
         return (  
            <div ref={ref} className={className} {...props}>  
                              
               
               {/* CODE ... */}
                              
               
               {/* моушн-див с карточкой */}  
               <motion.div  
                  variants={variants}  
                  initial={'hidden'}  
                  animate={isReviewOpened ? 'visible' : 'hidden'}  
               >  
                  {/* добавляем табиндекс */}  
                  <Card  
                     tabIndex={isReviewOpened ? 0 : -1}  
                     ref={reviewRef}  
                     color='blue'  
                     className={styles.reviews}  
                  >  
                     {product.reviews.map(r => (  
                        <div key={r._id}>  
                           <Review review={r} />  
                           <Divider />  
                        </div>  
                     ))}  
  
                     {/* прокидываем из продукта состояние открытости формы внутрь этой формы */}  
                     <ReviewForm productId={product._id} isOpened={isReviewOpened} />  
                  </Card>  
               </motion.div>  
            </div>  
         );  
      },  
   ),  
);
```

В форме обзора будем принимать из родительского компонента атрибут `isOpened`, который будет отвечать за открытое состояние формы или закрытое

`components / ReviewForm / ReviewForm.props.ts`
```TS
import { DetailedHTMLProps, HTMLAttributes } from 'react';  
  
export interface ReviewFormProps  
   extends DetailedHTMLProps<HTMLAttributes<HTMLDivElement>, HTMLDivElement> {  
   productId: string;  
   isOpened: boolean; // из продукта прокидываем состояние открытости формы  
}
```

- Устанавливаем `tabIndex={isOpened ? 0 : -1}` на все элементы, чтобы форма реагировала на состояние открытости и закрытости
- Рейтинг уже будет использовать такую запись для реализации перелистывания и блокировки перелистывания оценки

`components / ReviewForm / ReviewForm.tsx`
```TSX
export const ReviewForm = ({  
   isOpened,  
   productId,  
   className,  
   ...props  
}: ReviewFormProps): JSX.Element => {  
   const {  
      register,  
      control,  
      handleSubmit,  
      formState: { errors },  
      reset,  
   } = useForm<IReviewForm>();  
  
   /// CODE ...
  
   return (  
      <form onSubmit={handleSubmit(onSubmit)}>  
         <div className={cn(styles.reviewForm, className)} {...props}>  
            <Input  
               {...register('name', { required: { value: true, message: 'Заполните имя' } })}  
               placeholder='Имя'  
               error={errors.name}  

			   /* добавляем табиндекс */
               tabIndex={isOpened ? 0 : -1}  
            />  
            <Input  
               {...register('title', {  
                  required: { value: true, message: 'Заполните заголовок' },  
               })}  
               placeholder='Заголовок отзыва'  
               className={styles.title}  
               error={errors.title}  
               
               /* добавляем табиндекс */  
               tabIndex={isOpened ? 0 : -1}  
            />  
            <div className={styles.rating}>  
               <span>Оценка:</span>  
               <Controller  
                  control={control}  
                  name='rating'  
                  rules={{  
                     required: { value: true, message: 'Укажите рейтинг' },  
                  }}  
                  render={({ field }) => (  
                     <Rating  
                        isEditable  
                        ref={field.ref}  
                        rating={field.value}  
                        setRating={field.onChange}  
                        error={errors.rating}  
                        
                        /* прокидываем внутрь табиндекс */  
                        tabIndex={isOpened ? 0 : -1}  
                     />  
                  )}  
               />  
            </div>  
            <Textarea  
               {...register('description', {  
                  required: { value: true, message: 'Заполните заголовок' },  
               })}  
               placeholder='Текст отзыва'  
               className={styles.description}  
               error={errors.description}  
               
               /* добавляем табиндекс */  
               tabIndex={isOpened ? 0 : -1}  
            />  
            <div className={styles.submit}>  
               
               {/* добавляем табиндекс */}  
               <Button appearance='primary' tabIndex={isOpened ? 0 : -1}>  
                  Отправить  
               </Button>  
               <span className={styles.info}>  
                  * Перед публикацией отзыв пройдет предварительную модерацию и проверку  
               </span>  
            </div>  
         </div>
           
         
         {/* CODE ... */}
      
      
      </form>  
   );  
};
```

Рейтинг уже реализован более сложным образом:
- создаём массив рефов `ratingArrayRef`
- далее нам нужна функция `computeFocus`, которая будет определять состояние доступности табиндекса элемента
- в `useEffect` добавляем в зависимости для перестройки рейтинга `tabIndex`
- в функции `constructRating` мы добавим определение табиндекса и добавим спан в массив рефов
- функция `handleKey` будет обрабатывать переход внутри рейтинга по стрелкам клавиатуры

`components / Rating / Rating.tsx`
```TSX
export const Rating = forwardRef(  
   (  
      {  
         isEditable = false,  
         className,  
         error,  
         rating,  
         setRating,  
         tabIndex,  
         ...props  
      }: RatingProps,  
      ref: ForwardedRef<HTMLDivElement>,  
   ): JSX.Element => {  
      const [ratingArray, setRatingArray] = useState<JSX.Element[]>(new Array(5).fill(<></>));  
  
      // данная константа будет хранить массив спанов рейтинга (звёздочки)  
      const ratingArrayRef = useRef<(HTMLSpanElement | null)[]>([]);  
  
      // эта функция будет открывать и закрывать доступ для перехода через клавиатуру в определённых условиях  
      const computeFocus = (r: number, i: number): 0 | -1 => {  
         // если нельзя редактировать элемент, то возвращаем -1  
         if (!isEditable) {  
            return -1;  
         }  
  
         // если рейтинга нет и текущий индекс = 0, то возвращаем 0  
         if (!rating && i == 0) {  
            // если имеется переданный tabIndex, то ставим его, если нет - то 0  
            return tabIndex ?? 0;  
         }  
  
         // следующий элемент для выбора тоже оставим ему 0  
         if (r == i + 1) {  
            return tabIndex ?? 0;  
         }  
  
         // в остальных случаях -1  
         return -1;  
      };  
  
      useEffect(() => {  
         constructRating(rating);  
      }, [rating, tabIndex]);  
  
      const constructRating = (currentRating: number) => {  
         const updatedArray = ratingArray.map((r: JSX.Element, i: number) => {  
            return (  
               <span  
                  className={cn(styles.star, {  
                     [styles.filled]: i < currentRating,  
                     [styles.editable]: isEditable,  
                  })}  
                  onMouseEnter={() => changeDisplay(i + 1)}  
                  onMouseLeave={() => changeDisplay(rating)}  
                  onClick={() => onClick(i + 1)}  
                  onKeyDown={handleKey}  
                  /* тут уже используется функция для определения доступности элемента */  
                  tabIndex={computeFocus(rating, i)}  
                  /* тут мы заполняем массив рефов отдельными рефами */  
                  ref={r => ratingArrayRef.current?.push(r)}  
               >
	               <StarIcon />  
               </span>  
            );  
         });  
         setRatingArray(updatedArray);  
      };  
  
      const changeDisplay = (i: number) => {  
         if (!isEditable) {  
            return;  
         }  
         constructRating(i);  
      };  
  
      const onClick = (i: number) => {  
         if (!isEditable || !setRating) {  
            return;  
         }  
         setRating(i);  
      };  
  
      // теперь вместо обработки пробелов, тут будет обрабатываться переключение рейтинга через стрелки клавиатуры  
      const handleKey = (e: KeyboardEvent) => {  
         // если оценка нередактируемая или нет функции установки рейтинга  
         if (!isEditable || !setRating) {  
            return;  
         }  
  
         // при нажатии на срелки вправо и вверх - поднимаем рейтинг  
         if (e.code == 'ArrowRight' || e.code == 'ArrowUp') {  
            if (!rating) {  
               setRating(1);  
            } else {  
               e.preventDefault();  
               setRating(rating < 5 ? rating + 1 : 5);  
            }  
  
            // фокусим текущий элемент массива  
            ratingArrayRef.current[rating]?.focus();  
         }  
  
         // при нажатии на срелки вниз и влево - опускаем рейтинг  
         if (e.code == 'ArrowLeft' || e.code == 'ArrowDown') {  
            e.preventDefault();  
            setRating(rating > 1 ? rating - 1 : 1);  
  
            // тут -2, так как рейтинг не будет применён, когда мы его еще будем вычитать  
            ratingArrayRef.current[rating - 2]?.focus();  
         }  
      };  
  
      return (  
         <div  
            className={cn(className, styles.ratingWrapper, {  
               [styles.error]: error,  
            })}  
            {...props}  
            ref={ref}  
         >            {ratingArray.map((r, i) => (  
               <span key={i}>{r}</span>  
            ))}  
            {error && <span className={styles.errorMessage}>{error.message}</span>}  
         </div>  
      );  
   },  
);
```

Сделаем звёздочки инлайн-блоковыми, чтобы аутлайн не был кривым

`components / Rating / Rating.module.css`
```CSS
.star {  
   display: inline-block;  
}
```

Итог: теперь, когда форма отзывов закрыта, мы на неё не попадаем. Мы можем спокойно переходить по элементам формы, переключать рейтинг и отправлять форму с клавиатуры.

![](_png/Pasted%20image%2020230218082246.png)

## 005 Упражнение - доступность сортировки









## 006 ARIA атрибуты









## 007 Использование Screen Reader









## 008 Aria-label и aria-labelledby









## 009 Aria-hidden









## 010 Добавление landmarks









## 011 Доступность форм









## 012 Упражнение - Доступность оповещений









## 013 Доступность меню и списка









## 014 Уменьшение движения






