
## 001 Компонент Link

Главная особеность тега `<Link>`, которую предоставляет нам ==NextJS== является то, что этот тег заставляет перезагружать только отдельную часть документа, где меняется контент, а не весь документ сразу. Это обеспечивает работу со страницей как с клиентским приложением, когда у нас перезагружается на вся форма, а только отдельная его часть

- href
- as - он уже позволит указать то, что будет отображаться в браузере, если ссылки не совпадают
- replace - если `false`, то при возвращении обратно на эту страницу, будет совершён возврат на предыдущую за ней
- shallow - если `true`, то эта настройка запретит запускать получение пропсов и путей с сервера (функции некста)

![](_png/Pasted%20image%2020221227175557.png)

Чтобы указать наш линк, нужно записать этот тег внутри написать блок с ссылкой `<a>`.
Начиная с ==NextJS 13== тег `<a>` для указания ссылки использовать нельзя.

![](_png/Pasted%20image%2020221227175946.png)

Так выглядит пробрасывание ссылки из `Link` во вложенный внутрь него компонент

![](_png/Pasted%20image%2020221227180023.png)

Так же мы имеем возможность прокинуть не просто ссылку, а полноценный объект, в котором укажем все части ссылки. Это предоставит более понятную и читабельную ссылку.

![](_png/Pasted%20image%2020221227180217.png)

Чтобы тег `Link` заработал в нашем проекте, нужно просто заменить `<a>` на `<Link>`. 
Конкретно вот так сейчас выглядят функции с ссылками:

`layout / menu / Menu.tsx`
```TSX
// Тут мы строим первый уровень меню
const buildFirstLevel = () => {
	return (
		<>
			{/* Проходимся по всем элементам меню */}
			{firstLevelMenu.map((m) => (
				// Будем создавать элементы по роуту
				<div key={m.route}>
					<Link href={`/${m.route}`}>
						<div
							className={cn(styles.firstLevel, {
								[styles.firstLevelActive]: m.id == firstCategory,
							})}
>
							{m.icon}
							<span>{m.name}</span>
						</div>
					</Link>
					{/* Далее мы строим второй уровень, если id меню совпадает с id выбранной категории */}
					{m.id == firstCategory && buildSecondLevel(m)}
				</div>
			))}
		</>
	);
};

// функция для построения третьего уровня меню
const buildThirdLevel = (pages: PageItem[], route: string) => {
	// на третьем уровне нужно будет просто вывести ссылки под вторым уровнем
	return pages.map((p) => (
		<Link
			// тут мы указываем главный роут и алиас страницы
			href={`/${route}/${p.alias}`}
			className={cn(styles.thirdLevel, {
				[styles.thirdLevelActive]: false,
			})}
>
			{p.category}
		</Link>
	));
};
```

Теперь наша страница не перезагружается при переходе по роутам - обновляются только те данные, которые изменились на странице

![](_png/Pasted%20image%2020230129175308.png)

## 002 useRouter

*`useRouter` - это хук доступный исключительно в NextJS*

Так роутер используется

```TSX
const router = useRouter();
```

Роутер состоит из:
- `route` - это текущий роут, на котором мы находимся
- `pathname` - текущий путь, по которому мы находимся
- `query` - параметры пути
- `asPath` - если задали `as` при переходе на `Link`
- `basePath`- базовый путь, который был задан
И свойства, которые относятся к языку:
- `locale`
- `locales`
- `defaultLocale`
- `domainLocales`
- `isLocaleDomen`

Так же у него имеются методы и события, которые позволяют скорректировать роуты:

```TS
Pick<Router, 'push' | 'replace' | 'reload' | 'back' | ... >
```

![](_png/Pasted%20image%2020230129181124.png)

План работ:
- Нужно скрывать все остальные уровни, когда у нас выбран определённый раздел
- Нужно выделить активным то меню, в котором мы сейчас находимся

![](_png/Pasted%20image%2020230130144229.png)

Для того, чтобы отобразить выбранный элемент, нужно в `buildSecondLevel` указывать стиль `Opened` только указанному элементу

`layout / menu / Menu.tsx`
```TSX
// функция построения второго уровня меню
const buildSecondLevel = (menuItem: FirstLevelMenuItem) => {
	return (
		<div className={styles.secondBlock}>
			{menu.map((m) => {

				// будет отображать только тот блок с курсами, на котором сейчас находится пользователь
				// проверка происходит по наличию в пути страницы значения алиаса страницы
				if (m.pages.map((p) => p.alias).includes(router.asPath.split('/')[2])) m.isOpened = true;

				return (
					<div key={m._id.secondCategory}>
						<div className={styles.secondLevel}>{m._id.secondCategory}</div>
						<div
							className={cn(styles.secondLevelBlock, {
								[styles.secondLevelBlockOpened]: m.isOpened,
							})}
>
							{buildThirdLevel(m.pages, menuItem.route)}
						</div>
					</div>
				);
			})}
		</div>
	);
};
```

Скроем изначально все блоки и будем показывать их содержимое через `secondLevelBlockOpened`

`layout / menu / Menu.module.css`
```CSS
.secondLevelBlock {
	display: none;
}

.secondLevelBlockOpened {
	display: block;
}
```

И сейчас мы видим, что все остальные меню скрылись

![](_png/Pasted%20image%2020230130150715.png)

Тут мы укажем, что заголовок третьего уровня будет активен, если имя его роута (путь в браузере) будет совпадать с тем, где сейчас находится роутер (в браузере)

`layout / menu / Menu.tsx`
```TSX
// функция для построения третьего уровня меню
const buildThirdLevel = (pages: PageItem[], route: string) => {
	// на третьем уровне нужно будет просто вывести ссылки под вторым уровнем
	return pages.map((p) => (
		<Link
			// тут мы указываем главный роут и алиас страницы
			href={`/${route}/${p.alias}`}
			className={cn(styles.thirdLevel, {
				[styles.thirdLevelActive]: `/${route}/${p.alias}` == router.asPath,
			})}
		>
			{p.category}
		</Link>
	));
};
```

Сейчас мы можем нажать на определённую страницу и она будет выделена в меню

![](_png/Pasted%20image%2020230130150905.png)

Далее нужно добавить метод `openSecondLevel`, который будет свитчить состояние открытости или закрытости блока (менять его между друг другом). Далее нужно будет поместить его на клик в заголовок второго уровня меню. 

`layout / menu / Menu.tsx`
```TSX
// данная функция будет скрывать или показывать блок второго уровня меню по клику
const openSecondLevel = (secondCategory: string) => {
	// так как setMenu может и не быть (= null), то нужно обязательно прописать проверку через &&, что нужно выполнять функцию при условии её наличия
	setMenu &&
		setMenu(
			menu.map((m) => {
				if (m._id.secondCategory == secondCategory) {
					m.isOpened = !m.isOpened;
				}
				return m;
			}),
		);
};

// функция построения второго уровня меню
const buildSecondLevel = (menuItem: FirstLevelMenuItem) => {
	return (
		<div className={styles.secondBlock}>
			{menu.map((m) => {
	// будет отображать только тот блок с курсами, на котором сейчас находится пользователь
				// проверка происходит по наличию в пути страницы значения алиаса страницы
				if (m.pages.map((p) => p.alias).includes(router.asPath.split('/')[2])) {
					m.isOpened = true;
				}
				return (
					<div key={m._id.secondCategory}>
						<div
							className={styles.secondLevel}
					// при нажатии на уровень будет происходить изменение видимости блока							
							onClick={() => openSecondLevel(m._id.secondCategory)}
>
							{m._id.secondCategory}
						</div>
						<div
							className={cn(styles.secondLevelBlock, {
								[styles.secondLevelBlockOpened]: m.isOpened,
							})}
>
							{buildThirdLevel(m.pages, menuItem.route)}
						</div>
					</div>
				);
			})}
		</div>
	);
};
```

На данном этапе мы уже можем открывать и скрывать определённые разделы с курсами

![](_png/Pasted%20image%2020230130152736.png)

## 003 Упражнение - Добавление страниц
























## 004 Структура роутинга

















## 005 Вёрстка Sidebar






