
## 001 Компонент Link

Главная особеность тега `<Link>`, которую предоставляет нам ==NextJS== является то, что этот тег заставляет перезагружать только отдельную часть документа, где меняется контент, а не весь документ сразу. Это обеспечивает работу со страницей как с клиентским приложением, когда у нас перезагружается на вся форма, а только отдельная его часть

- href
- as - он уже позволит указать то, что будет отображаться в браузере, если ссылки не совпадают
- replace - если `false`, то при возвращении обратно на эту страницу, будет совершён возврат на предыдущую за ней
- shallow - если `true`, то эта настройка запретит запускать получение пропсов и путей с сервера (функции некста)

![](_png/Pasted%20image%2020221227175557.png)

Чтобы указать наш линк, нужно записать этот тег внутри написать блок с ссылкой `<a>`.
Начиная с ==NextJS 13== тег `<a>` для указания ссылки использовать нельзя.

![](_png/Pasted%20image%2020221227175946.png)

Так выглядит пробрасывание ссылки из `Link` во вложенный внутрь него компонент

![](_png/Pasted%20image%2020221227180023.png)

Так же мы имеем возможность прокинуть не просто ссылку, а полноценный объект, в котором укажем все части ссылки. Это предоставит более понятную и читабельную ссылку.

![](_png/Pasted%20image%2020221227180217.png)

Чтобы тег `Link` заработал в нашем проекте, нужно просто заменить `<a>` на `<Link>`. 
Конкретно вот так сейчас выглядят функции с ссылками:

`layout / menu / Menu.tsx`
```TSX
// Тут мы строим первый уровень меню
const buildFirstLevel = () => {
	return (
		<>
			{/* Проходимся по всем элементам меню */}
			{firstLevelMenu.map((m) => (
				// Будем создавать элементы по роуту
				<div key={m.route}>
					<Link href={`/${m.route}`}>
						<div
							className={cn(styles.firstLevel, {
								[styles.firstLevelActive]: m.id == firstCategory,
							})}
>
							{m.icon}
							<span>{m.name}</span>
						</div>
					</Link>
					{/* Далее мы строим второй уровень, если id меню совпадает с id выбранной категории */}
					{m.id == firstCategory && buildSecondLevel(m)}
				</div>
			))}
		</>
	);
};

// функция для построения третьего уровня меню
const buildThirdLevel = (pages: PageItem[], route: string) => {
	// на третьем уровне нужно будет просто вывести ссылки под вторым уровнем
	return pages.map((p) => (
		<Link
			// тут мы указываем главный роут и алиас страницы
			href={`/${route}/${p.alias}`}
			className={cn(styles.thirdLevel, {
				[styles.thirdLevelActive]: false,
			})}
>
			{p.category}
		</Link>
	));
};
```

Теперь наша страница не перезагружается при переходе по роутам - обновляются только те данные, которые изменились на странице

![](_png/Pasted%20image%2020230129175308.png)

## 002 useRouter

*`useRouter` - это хук доступный исключительно в NextJS*

Так роутер используется

```TSX
const router = useRouter();
```

Роутер состоит из:
- `route` - это текущий роут, на котором мы находимся
- `pathname` - текущий путь, по которому мы находимся
- `query` - параметры пути
- `asPath` - если задали `as` при переходе на `Link`
- `basePath`- базовый путь, который был задан
И свойства, которые относятся к языку:
- `locale`
- `locales`
- `defaultLocale`
- `domainLocales`
- `isLocaleDomen`

Так же у него имеются методы и события, которые позволяют скорректировать роуты:

```TS
Pick<Router, 'push' | 'replace' | 'reload' | 'back' | ... >
```

![](_png/Pasted%20image%2020230129181124.png)

План работ:
- Нужно скрывать все остальные уровни, когда у нас выбран определённый раздел
- Нужно выделить активным то меню, в котором мы сейчас находимся

![](_png/Pasted%20image%2020230130144229.png)

Для того, чтобы отобразить выбранный элемент, нужно в `buildSecondLevel` указывать стиль `Opened` только указанному элементу













## 003 Упражнение - Добавление страниц





## 004 Структура роутинга





## 005 Вёрстка Sidebar






