
Так как мы писали сайт, используя `rem`, а не `px`, то нам для частичной адаптивности достаточно добавить изменение размера шрифта в теге `html`.

Однако подобная запись, когда мы должны отдельно прописывать `@media` для каждого элемента - это неудобно. Лучше использовать в данном случае миксины

```SCSS
html {
    font-size: 10px;
    @media (max-width: 600px) {
        font-size: 4px;
    }
}
```

Чтобы упростить себе задачу, можно написать универсальный миксин, который будет в себя принимать изменения в зависимости от принимаемого аргумента. 
Как это работает? 
Мы написали миксин `respond`, который принимает в себя одно из значений `$breakpoint`, которое мы в него вложим (разные медиазапросы под разные устройства). Оператор `@content` говорит, что при вводе данных в миксин, это будет контентом миксина (не какие-то фиксированные значения, а оставляем свои).

```SCSS
@mixin respond($breakpoint) {  
   @if $breakpoint == phone {  
      @media (max-width: 600px) {  
         @content;  
      }   
    }  
  
   @if $breakpoint == tab-port {  
      @media (max-width: 900px) {  
         @content;  
      }   
    }  
  
   @if $breakpoint == tab-land {  
      @media (max-width: 1200px) {  
         @content;  
      }   
    }  
  
   @if $breakpoint == big-screen {  
      @media (max-width: 1800px) {  
         @content;  
      }   
	}  
}
```

Вот пример использования:
Мы написали в качестве аргументов одно из значений `$breakpoint` и внутрь пишем просто свойства, которые мы описали как `@content`, которые будут являться нашим медиазапросом

```SCSS
html {  
   font-size: 62.5%; // 10px  
   @include respond(phone) {  
      font-size: 40%;  
   }  
}
```

Так же хочется отметить, что жёсткое задание ширины контейнеру может навредить адаптивной вёрстке

```SCSS
.container {  
   margin: 0 auto;  
   // width: 1440px;  // - стоит убрать, так как ломает адаптив
   background: #f7f7f7;  
  
   position: relative;  
   z-index: 0;  
}
```

![](_png/2b0ed05ef4808a72e0bb01729181adf1.png)