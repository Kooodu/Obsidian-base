#Patterns #SOLID 

### Введение

Паттерны, принципы, архитектура - это инструменты, которые позволяют разработчикам общаться на одном и том же языке. Определённая архитектура позволяет быстрее въехать разработчику в проект, так как она диктует общие принципы и правила, по которым мы пишем приложение. 
Все эти парадигмы позволяют нам строить системы примерно похоже. Очень многие ошибки начинают сходиться и повторяться, отчего их проще находить и исправлять

Мир без паттернов можно представить так: мы каждый раз выводим формулу для решения определённой задачи, вместо того, чтобы использовать определённый алгоритм решения собственно этой задачи

![](_png/7d5bfac1e4273280288c56b10efe9fe6.png)
![](_png/f7ccbb933ef42a42f5a531cfc0db9383.png)

Однако за нас эти формулы уже вывели и нам не нужно этого делать. Мы просто открываем формулы и используем их для решения задачи

![](_png/882d7a02f0597261c64b6dfb97038a1d.png)

Паттерны помогают нам творить хороший и чистый код

![](_png/10f6fa0f0c2e52a41b5fff525618a80e.png)

Принципы SOLID:

![](_png/dc59318868e5e14ad08673b6976c67d3.png)

### SRP (Single Resposibility Principle)

Это принцип, при котором мы назначаем одной сущности (классу, функции) ровно одну задачу 

![](_png/Pasted%20image%2020221011134959.png)

Представим, что у нас есть система, которая имеет свои данные и она должна уметь сохранять себя, отправлять свои данные, печатать их, логировать и так далее. Если писать всё в одном классе, то дополнять систему в будущем и править её не будет представляться возможным - система станет кашей, которую невозможно будет править и поддерживать, а нововведения от заказчика станут недобавляемы

![](_png/Pasted%20image%2020221011135901.png)

Поэтому нам нужно будет делить модель данных и поведение сущности

![](_png/Pasted%20image%2020221011135903.png)

И вот самый простой пример: в первом случае, весь функционал пользователя находится в нём самом, а во втором мы вынесли логику в другие классы

![|600](_png/Pasted%20image%2020221011140201.png)

![|600](_png/Pasted%20image%2020221011140204.png)

Либо вот пример с `DataFetcher`, который реализует в себе использование большого числа отдельных методов

![|600](_png/Pasted%20image%2020221011145613.png)

В идеальном варианте, стоит сделать отдельный класс, который будет выполнять всю избыточную логику класса

![|600](_png/Pasted%20image%2020221011145617.png)

###### Примеры на фронте

Мы имеем компонент, который отвечает за отрисовку формы отправки реквизитов

![](_png/Pasted%20image%2020230331120602.png)

Далее в него мы добавляем функционал по отправке реквизитов, обнулению формы и валидации данных.
Пока всё нормально, так как вся вложенная логика относится к одной форме

![](_png/Pasted%20image%2020230331120609.png)

И далее нам приходит задача обрабатывать одним способом русские реквизиты и иностранные, что требует от нас проверку компонента на разные локали

![](_png/Pasted%20image%2020230331120615.png)

Для более правильной реализации данной задачи нужно вынести логику функций в отдельные модули

![](_png/Pasted%20image%2020230331120625.png)

И уже из этих модулей вызывать нашу форму с подходящими функциями

Такой способ позволит сохранить подход единственной ответственности в приложении

![](_png/Pasted%20image%2020230331120632.png)

А сюда мы выносим отдельное создание реквизитов под разные локали

![](_png/Pasted%20image%2020230331121033.png)

> [!success] Преимущества подхода:
> - Избавление от антипаттерна GodObject
> - Приложение разбивается на отдельные модули (декомпозиция), что приводит к лучшей читабельности
> - Логика выполнения определённых операций инкапсулируется в определённых функциях, что так же упрощает написание тестов
> - Становится легче вносить изменения в проект

### OCP (Opened-Closed Principle)

Все программные сущности (классы, компоненты, модули, сущности) должны быть открыты для расширения, но закрыты для изменения

Мы должны добавлять новый функционал за счёт добавления новой сущности, которая будет посредством определённой логики связана с другой сущностью

![](_png/Pasted%20image%2020230331122448.png)



![](_png/Pasted%20image%2020230331123057.png)

![](_png/Pasted%20image%2020230331123054.png)

![](_png/Pasted%20image%2020230331123103.png)



![](_png/Pasted%20image%2020230331123211.png)

![](_png/Pasted%20image%2020230331123232.png)



![](_png/Pasted%20image%2020230331123310.png)


![](_png/Pasted%20image%2020230331123322.png)

![](_png/Pasted%20image%2020230331123326.png)

Теперь можно удалить выбор типа из конструктора

![](_png/Pasted%20image%2020230331123329.png)

И создаём новое оружие через отдельный класс 

![](_png/Pasted%20image%2020230331123332.png)




### LSP






### ISP






### DIP






### SOLID итоги



