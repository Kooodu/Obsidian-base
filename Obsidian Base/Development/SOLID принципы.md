#Patterns #SOLID 

### Введение

Паттерны, принципы, архитектура - это инструменты, которые позволяют разработчикам общаться на одном и том же языке. Определённая архитектура позволяет быстрее въехать разработчику в проект, так как она диктует общие принципы и правила, по которым мы пишем приложение. 
Все эти парадигмы позволяют нам строить системы примерно похоже. Очень многие ошибки начинают сходиться и повторяться, отчего их проще находить и исправлять

Мир без паттернов можно представить так: мы каждый раз выводим формулу для решения определённой задачи, вместо того, чтобы использовать определённый алгоритм решения собственно этой задачи

![](_png/7d5bfac1e4273280288c56b10efe9fe6.png)
![](_png/f7ccbb933ef42a42f5a531cfc0db9383.png)

Однако за нас эти формулы уже вывели и нам не нужно этого делать. Мы просто открываем формулы и используем их для решения задачи

![](_png/882d7a02f0597261c64b6dfb97038a1d.png)

Паттерны помогают нам творить хороший и чистый код

![](_png/10f6fa0f0c2e52a41b5fff525618a80e.png)

Принципы SOLID:

![](_png/dc59318868e5e14ad08673b6976c67d3.png)

### SRP (Single Resposibility Princip)

Это принцип, при котором мы назначаем одной сущности (классу, функции) ровно одну задачу 

![](_png/Pasted%20image%2020221011134959.png)

Представим, что у нас есть система, которая имеет свои данные и она должна уметь сохранять себя, отправлять свои данные, печатать их, логировать и так далее. Если писать всё в одном классе, то дополнять систему в будущем и править её не будет представляться возможным - система станет кашей, которую невозможно будет править и поддерживать, а нововведения от заказчика станут недобавляемы

![](_png/Pasted%20image%2020221011135901.png)

Поэтому нам нужно будет делить модель данных и поведение сущности

![](_png/Pasted%20image%2020221011135903.png)

И вот самый простой пример: в первом случае, весь функционал пользователя находится в нём самом, а во втором мы вынесли логику в другие классы

![|600](_png/Pasted%20image%2020221011140201.png)

![|600](_png/Pasted%20image%2020221011140204.png)

Либо вот пример с `DataFetcher`, который реализует в себе использование большого числа отдельных методов

![|600](_png/Pasted%20image%2020221011145613.png)

В идеальном варианте, стоит сделать отдельный класс, который будет выполнять всю избыточную логику класса

![|600](_png/Pasted%20image%2020221011145617.png)


12:11






### OCP

### LSP

### ISP

### DIP

### SOLID итоги