
## 03:15 ➝ Теория

Реакт - это библиотека для создания пользовательских интерфейсов. То есть это означает, что мы можем писать интерфейсы на нём не только для браузера, но и для мобилок, так как он использует свой виртуальный DOM. 

Мы имеем две основные концепции сайтов:
- MPA (Multi Page Application) - сайт состоит из нескольких страниц, при переходе на которые мы подгружаем их данные целиком
- SPA (Single Page Application) - весь сайт располагается на одной странице и при переходе на другую страницу в нём меняются только конкретные данные

![](_png/Pasted%20image%2020230209082823.png)

Реакт основан на компонентном подходе, когда страница строится из отдельных кирпичиков, которые мы можем повторно использовать. Так же он позволяет сосредоточиться на написании логики приложения без работы со слушателями событий, непосредственной работы с DOM (`querySelector` и подобные операции) - реакт берёт эту работу на себя.

![](_png/Pasted%20image%2020230209083336.png)

Во время своей работы реакт строит два своих дерева и переносят изменения на конечное третье:
- Первое - дерево элементов реакта - когда в нём происходят изменения, они попадают на второе дерево, между которыми происходит сравнение
- Второе - виртуальное дерево для сравнения
- Третье - это конечный DOM браузера, в которое и вносятся изменения после сравнения (фаза рендеринга, за которую отвечает React DOM или React Native)

Механизм согласования (Reconciliation) осуществляет сравнение элементов дерева реакта.
Так же реакт делит операции по приоритетности и более приоритеные задачи он выполняет быстрее.

![](_png/Pasted%20image%2020230209083806.png)

## 11:40 ➝ Начало разработки. Создание проекта



```bash
npx create-react-app .
```



```bash
npm start
```

## 16:10 ➝ Что такое JSX?

==JSX== - это препроцессор, который ==babel== переводит в обычный ==JS== 

![](_png/Pasted%20image%2020230209095251.png)

## 18:11 ➝ Компонент App. Работа с состоянием. UseState

Задача: нам нужно сделать счётчик, который при нажатии на кнопку будет увеличивать значение. 

В примере ниже Реакт не понимает, что нужно обновлять значение в определённом компоненте, так как мы подобной функцией отправляем изменение значения в JS (`clg` покажет, что значение меняется внутри JS), а не в дерево Реакта.

Нам нужно будет вызвать в реакте перерендер нужного нам значения на странице.

![](_png/Pasted%20image%2020230209100002.png)

Хук `useState()` возвращает значение с состоянием и функцию для его обновления.

Во время первоначального рендеринга возвращаемое состояние (`state`) совпадает со значением, переданным в качестве первого аргумента (`initialState`).

Функция `setState` используется для обновления состояния. Она принимает новое значение состояния и ставит в очередь повторный рендер компонента.

```TSX
export const State = (): JSX.Element => {
	let [counter, setCounter] = useState<number>(0);

	return (
		<div>
			<Link href={'/'}>
				<Button buttonType={'ghost'}>Обратно</Button>
			</Link>
			<div className={styles.wrapper}>
				<h2 className={styles.title}>Счётчик:</h2>
				<h1 className={styles.num}>{counter}</h1>
				<Button
					buttonType={'gray'}
					className={styles.reduce}
					onClick={() => setCounter(counter--)}
				>
					Уменьшить
				</Button>
				<Button
					buttonType={'purple'}
					className={styles.increase}
					onClick={() => setCounter(counter++)}
				>
					Увеличить
				</Button>
			</div>
		</div>
	);
};
```

При увеличении значения счётчика, число увеличивается, а при уменьшении - уменьшается.

![](_png/Pasted%20image%2020230209095936.png)

## 22:25 ➝ Управляемый инпут

Управляемый компонент - это компонент, значение которого мы можем изменить, изменив состояние

```TSX
export const ControlledInput = (): JSX.Element => {
	let [value, setValue] = useState<string>('Значение');

	return (
		<div>
			<Link href={'/'}>
				<Button buttonType={'ghost'}>Обратно</Button>
			</Link>
			<div className={styles.wrapper}>
				<h1>{value}</h1>
				<Input
					value={value}
					placeholder={'Пиши в меня:)'}
					onChange={e => setValue(e.target.value)}
				/>
			</div>
		</div>
	);
};
```

Мы связали состояние `<h1>` с тем, что находится в инпуте

![](_png/Pasted%20image%2020230209103422.png)

## 24:07 ➝ Первый функциональный компонент

- Компоненты мы создаём в папке `components`
- Файл компонента и функция компонента всегда именуются в ==PascalCase==
- Компоненты всегда должны возвращать `JSX.Element`

![](_png/Pasted%20image%2020230209103714.png)

И теперь данный функциональный компонент `<Button>` можно использовать в любом месте проекта. Этих компонентов можно навставлять сколько угодно и они будут независимыми друг от друга

```TSX
import { Button } from '@/components';  
  
function Home() {  
   return (  
      <div className={styles.wrapper}>  
         <h1>React фундаментальный</h1>  
         <div className={styles.links}>  
            <Link href={'fundamentals/state'}>  
               <Button buttonType={'purple'}>Состояния React</Button>  
            </Link>  
            <Link href={'fundamentals/controlledInput'}>  
	            <Button buttonType={'purple'}>Управляемый инпут</Button>  
				<Button buttonType={'purple'}>Управляемый инпут</Button>  
				<Button buttonType={'purple'}>Управляемый инпут</Button>  
				<Button buttonType={'purple'}>Управляемый инпут</Button>  
				<Button buttonType={'purple'}>Управляемый инпут</Button>
            </Link>  
         </div>  
      </div>  
   );  
}
```

![](_png/Pasted%20image%2020230209110019.png)

## 26:40 ➝ Первый классовый компонент







## 30:25 ➝ Что такое хуки? useState, useEffect







## 31:10 ➝ Стили. CSS. Классы







## 34:30 ➝ Props. Аргументы компонента. 







## 36:55 ➝ Работы со списками. Преобразование массива объектов в массив React элементов







## 41:50 ➝ Форма создания поста. Управляемые и неуправляемые компоненты







## 42:30 ➝ Создание UI библиотеки. Первые компоненты. CSS модули. Пропс children







## 50:00 ➝ Предотвращаем обновление страницы при submit формы







## 50:45 ➝ хук useRef. Доступ к DOM элементу. Неуправляемый компонент







## 57:35 ➝ React Devtools. Инструменты разработчика React







## 59:15 ➝ Обмен данными между компонентами. От родителя к ребенку. От ребенка к родителю.







## 01:04:20 ➝ Отрисовка по условию







## 01:05:30 ➝ Сортировка. Выпадающий список







## 01:12:00 ➝ Поиск. Фильтрация.







## 01:15:10 ➝ useMemo. Мемоизация. Кеширование







## 01:23:50 ➝ Модальное окно. Переиспользуемый UI компонент







## 01:30:23 ➝ Анимации. React transition group







## 01:33:40 ➝ Декомпозиция. Кастомные хуки







## 01:36:20 ➝ Работа с сервером. Axios







## 01:38:40 ➝ Жизненный цикл компонента. useEffect







## 01:43:08 ➝ API. PostService







## 01:44:45 ➝ Индикация загрузки данных с сервера







## 01:46:20 ➝ Компонент Loader. Анимации







## 01:49:25 ➝ Кастомный хук useFetching(). Обработка ошибок







## 01:54:15➝ Постраничный вывод. Пагинация (pagination)







## 02:06:20 ➝ Обьяснение механизма изменения состояния







## 02:12:00 ➝ React router. Постраничная навигация. BrowserRouter, Route, Switch, Redirect







## 02:22:00 ➝ Динамическая навигация. useHistory, useParams







## 02:29:30 ➝ Загрузка комментариев к посту







## 02:33:10 ➝ Улучшаем навигацию. Приватные и публичные маршруты







## 02:38:00 ➝ useContext. Глобальные данные. Авторизация пользователя







## 02:47:10 ➝ Бесконечная лента. Динамическая пагинация. useObserver








