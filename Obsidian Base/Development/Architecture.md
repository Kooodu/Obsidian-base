
# Проволочки при проектировании структуры React приложения

Для начала стоит сказать пару слов о том, зачем вообще нужны эти разделения, абстракции и почему нельзя просто описать все необходимое в одном модуле как подсказывает сердце.

Конечно, можно все приложение описать в одном файле. Но чем крупнее приложение, тем настойчивей оно требует принятия таких мер, как снижения сложности, и повторное использование компонентов для оптимизации скорости разработки и качества кода. Каждый уровень абстракции призван облегчить труд разработчика, а терминология предоставить высокий уровень взаимодействия, и разделения обязанностей внутри команды.

Есть множество возможных вариантов организации структуры для проектирования приложения на React и нету одной единственной, которую можно было бы назвать совершенной, потому как каждый приложение преследует свои цели.

Для одной страницы с текстовым резюме все React приложение можно описать в одном файле. Для портальных решений порой не хватает и целого репозитория.

Но существуют проверенные практики. И начиная разрабатывать приложение на React, стоит хотя бы с ними ознакомится, что спроектировать структуру, а не наращивать поступательно, по мере необходимости, что неизбежно приводит к [big ball of mud](https://en.wikipedia.org/wiki/Big_ball_of_mud), в большей или меньшей степени.

Если представить, что React приложение — это дом, тогда его модули — это его помещения. Всякий дом выполняет свою роль — от склада, до бизнес-центра. Да и сами дома бывают разных габаритов — от хижины в лесу, до Бурдж-Халифа. Проектировать небоскреб по шаблонам сарая нельзя, как и наоборот. Даже планировка типичного жилого дома может варьироваться в зависимости от окружающей среды, климатических, географических или ландшафтных условий, и наконец от предпочтений самих жильцов.

Но есть зарекомендовавшие себя стереотипы — некоторые постоянные, пригодные для всех типов проектов. Так, например, в любом доме всегда должна быть кухня, гостиная, уборная, прихожая и балкон. Вы можете совместить кухню с гостиной, а уборную с балконом (на свой страх и риск :)), но не можете совместить кухню с уборной — это анти-паттерн.

Так же и в React приложении существуют зарекомендовавшие себя категории компонентов, которые были есть и будут. Не зависимо от того как далеко шагнет ваша дизайнерская мысль, она будет делать этот шаг от этих знаний.

## Категории компонентов React приложения

Тут будут описаны основные категории компонентов, их назначении и их месте в файловой структуре. Данный подход может стать хорошим плацдармом для размышлений и формировании структуры приложения следующего поколения, и подспорьем того, что приложение останется прозрачным для анализа и дальнейшего масштабирования.

### Components (компоненты)

Первый тип компонента, с которым создается “Hello, World” или компонент-компонент. Презентационные или, как их еще называют, — глупые компоненты. Свое прозвище заслужили тем, что не содержат бизнес логики.

Концепция умный/глупый компонент [описана еще 2015 году](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0). С того момента предпринимались попытки и впихнуть в глупые компоненты бизнес логику, и вкладывать в них контейнеры. Но истинная суть неизменна — отделение представления от контролера. Поэтому глупые компоненты должны оставаться глупыми.

Бытует заблуждение, что Dumb component = [stateless component](https://medium.com/@joshblack/stateless-components-in-react-0-14-f9798f8b992d). Это не более чем суеверие. Глупый компонент не обязан представлять из себя куклу без сухожилий. Это может быть сложный виджет, например, — интерактивная карта или крутая таблица. Но вот связь с моделью у него должна оставаться слабая.

Кратко говоря,

> Глупые компоненты — это верстка + логика отображения

Пример:

```JSX
export default ({ children, onClick }) => (<button className="button" onClick={onClick}>  
  {children}  
</button>)
```

### Layouts (макеты)

Макеты — это композиция из глупых компонентов. Они описывают то, как компоненты расположены на странице (контейнере). Макеты не могут содержать бизнес-логики, но должны иметь I/O для ее подключения.

Макеты полезны при использовании подхода с единым UI Kit — когда формы собираются из “глупых кубиков”, а не представляют из себя монолитную разметку.

Единственным оправданием существования макетов — это возможность их повторного использования. **Если разметка используется в приложении только один раз, то эта разметка должна описываться в контейнерах**.

Есть заблуждение, что Layouts — это тот самый компонент, который передается в prop _Route component_. Это не так. Макеты глупы и не могут работать как самостоятельные точки входа, для этого им не хватает бизнес логики, которой они сами обладать, по определению, не могут.

Кратко говоря,

> макеты — это композиция из компонентов

Пример:

```JSX
export default ({ onSubmit }) => (<FieldSet>  
  <Form onSubmit={onSubmit}>  
    <Row>  
      <Col>  
       <Label>E-mail</Label>  
       <Input />  
      </Col>  
    </Row>  
    <Row>  
      <Col>  
       <Button>Submit</Button>  
      </Col>  
    </Row>  
  </Form>  
</FieldSet>)
```

### Containers (контейнеры)

Контейнеры — это компоненты, содержащие представление, обернутое в бизнес логику. Контейнеры не должны содержать стилей и их представление должно быть составлено из глупых компонентов или макетов.

Именно **контейнеры передаются в prop _component Route_**_._ В них осуществляется связь между бизнес логикой и представлением.

Иногда контейнеры могут содержать роутинг. Особенно этого стало актуально с выходом [react-route 4](https://reacttraining.com/react-router/web/guides/quick-start). Но такой подход сомнителен, поскольку в таком случае возникают сомнения остается ли при этом контейнер контейнером.

Причинами, оправдывающими существование контейнеров, является их повторное использование и декомпозиция сложных форм. Иными словами, **создавайте контейнеры, если это обусловлено декомпозицией или их множественным применением — в остальных случаях контейнеры должны описываться в роутах**.

Частым случаем является описание глупых компонентов в контейнерах, в случаях если эти компоненты используются только в данном контейнере.

**Концептуальные границы контейнера очень не устойчивы.** _При достаточно высоком уровне сложности приходит понимание, что контейнер, по сути, превращается в микро-приложение. В таком случае стоит задуматься остается ли он при этом контейнером и может стоит подобрать другую категорию компонента._

Кратко говоря,

> контейнеры _— это layouts + enhancers._

Пример:

```JSX
export default connect(mapStateToProps)(Layout);
```

### Enhancers (усилители)

Это Хоки, замыкающих переданный им презентационный компонент на конкретной бизнес логике. Есть множество способов создать усилитель, самые популярные из них — [connect](https://github.com/reactjs/react-redux) и [recompose](https://github.com/acdlite/recompose).

Усилители служат лишь для описания логики форм, а сама модель может быть описана за его пределами.

Принцип YAGNI действует и здесь. **Если функционал, создаваемый усилителем, используется только один раз, этот усилитель должен быть описан в контейнере**.

Кратко говоря,

> усилители — это логика форм + модель

Пример:

```JSX
export default connect(mapStateToProps);
```

### Models (модель)

Модели — это конфигурация и механика бизнес логики. Это схемы, функции, классы, константы, селекторы и промежуточные слои, описывающие конкретную часть предметной области. Помимо этого, модель может содержать ХОКи и фабрики.

Содержимое модели напрямую зависит от выбранной архитектуры. Например, для [Redux](https://github.com/reactjs/react-redux) приложения — это, как правило, такие модули как: _actionNames, actionCreators, reducer, middlewares, selectors_.

Модель ничего не должна знать о компонентах, контейнерах, макетах и усилителях, она должна быть полностью изолирована от логики форм. Модель — это бизнес логика в чистом виде.

Кратко говоря,

> модель = бизнес логика + механика приложения

Пример:

```JSX
export {  
  actionNames,  
  actionCreators,  
  reducer,  
  middlewares,  
  selectors,  
}
```

### **Routes (Роуты)**

Являются точкой входа в приложение. Связывает состояние окна браузера с контейнером.

Роуты прямо указывают на конкретные формы. В зависимости от того, несколько роутинг тесно связан с бизнес логикой в вашем приложении, связь с формами может быть как одностороння, так и двустороння. То есть роут может ссылаться на контейнер, а контейнер содержать другой роут.

По этой причине роуты довольно часто превалируют перед контейнерами и вообще грань между ними стирается.

Роуты могут иметь фрактальную структуру, даже на уровне самого приложения, то есть — содержать другие роуты, компоненты и контейнеры. Это допустимо, если при этом не нарушается принцип DRY и структурная прозрачность приложения.

Пример:

```JSX
const Main = () => (  
  <main>  
    <Switch>  
      <Route exact path='/' component={Index}/>  
      <Route path='/products' component={Products}/>  
      <Route path='/services' component={Services}/>  
    </Switch>  
  </main>  
)
```

Кратко говоря,

> роуты = связь url -> контейнер

## Файловая структура

Теперь, разобравшись с основными категориями компонентов React приложения, можно посмотреть как будет выглядеть дерево каталогов такого приложения.

```
src/  
  components/ - Глупые компоненты  
  layouts/ - Разметка  
  containers/ - Контейнеры  
  enhancers/ - Усилители  
  models/ - Модели  
  routes/ - Роуты  
```

**И зависимости между этими компонентами:**

![](_png/Pasted%20image%2020230530142949.png)
![](https://miro.medium.com/v2/resize:fit:415/1*1IwLALm9hmAeJrL4ThnSGQ.png)

Реактивного вам проектирования.

---
# Архитектуры на фронт

Все мы знаем или слышали про практики и паттерны проектирования **_SOLID, GRASP, MVC, MV**_ и даже применяем их с переменным успехом, стараясь нащупать эффективный подход к построению приложений. Но это лишь приводит к разнообразию реализаций наших приложений и частей функционала.

И поэтому я уже долгое время пытаюсь понять по каким правилам должно строиться фронтенд приложение чтобы оно удовлетворяло следующим критериям:

- легкое расширение функционала приложения;
- безболезненное внесение изменений в существующий функционал;
- унифицированная структура приложения;
- быстрый onboarding новых разработчиков на проект;
- понятный и прозрачный код;
- всегда понятно где в структуре файлов расположить ту или иную функциональность. 
---

## «Организация файловой структуры это все что нам нужно»

Каждый лид или сеньор сами для себя выбирают варианты компоновки структуры приложения и выделения сущностей приложения. По итогу каждая система становится уникальной и неповторимой. И для того, чтобы разобраться в ней, нужны время и усилия, которые нужно будет тратить каждый раз при смене проекта. Плюс никто не отменял "[бас фактор](https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%BA%D1%82%D0%BE%D1%80_%D0%B0%D0%B2%D1%82%D0%BE%D0%B1%D1%83%D1%81%D0%B0#:~:text=bus%20factor%2C%20%D0%BB%D0%B8%D0%B1%D0%BE%20truck%20factor,%D1%83%20%D0%BD%D0%B8%D1%85%20%D1%80%D0%B5%D0%B1%D1%91%D0%BD%D0%BA%D0%B0%2C%20%D0%BD%D0%B0%D1%81%D1%82%D1%83%D0%BF%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%BD%D0%B5%D1%81%D1%87%D0%B0%D1%81%D1%82%D0%BD%D0%BE%D0%B3%D0%BE)".

Существует большое кол-во статей, описывающих «оптимальные», по мению авторов, варианты таких подходов. [Пример](https://clck.ru/hnGZh).

Но это, в основном, про структуру файлов и частные случаи использования какого-то функционала. Такой подход только частично унифицирует структуру приложения, но этого мало для того, чтобы называться архитектурой. Может есть что-то лучше?

## Domain Driven Design

![](_png/Pasted%20image%2020230530135843.png)

Много умных дядек, таких как Мартин Фаулер и дядюшка Боб, написали много статей про него. На бэкенде в больших и сложных проектах он неплохо себя зарекомендовал. Но есть и много изъянов: туча абстракций, для простых действий нужно писать много кода, ну и разобраться, как готовить DDD та еще задача. 

[Есть примеры](https://habr.com/ru/post/654629) как готовить это на фронте, но, как видно, проблемы никуда не уходят и кол-во абстракций удручают. Простой onboarding тут невозможен, без прочтения "[The Big Blue Book](https://www.domainlanguage.com/ddd/blue-book/)" и пары недель общения с ментором.

Есть переосмысленные подходы к архитектуре, которые больше похожи на правду и наверняка могут где-то успешно применены. 

[Основательная статья от Кхалила Стеммлера](https://khalilstemmler.com/articles/client-side-architecture/introduction/) о возможной архитектуре клиентских приложений частично полагается на DDD подход, но при этом сильно его упрощает, освобождая нас от ненужных абстракций и смещая понятия в сторону фронт приложений.

![](_png/Pasted%20image%2020230530135854.png)

Но бизнес логика в таких приложениях немного размывается и подход больше сфокусирован на функциональных слоях приложения, что отдаляет нас от требования к прозрачному коду и явной бизнес логики.

Джимми Богарт [в своей статье](https://jimmybogard.com/vertical-slice-architecture/) пишет что DDD подход не совершенен и избыточен, и, как следствие, он предлагает переработанный подход **vertical slices**. И это отличный подход, о котором стоит почитать отдельно. Эта идея довольно простая и мы можем адаптировать ее к фронтенд приложениям. 

![](_png/Pasted%20image%2020230530135908.png)

Если DDD не удалось применить для наших нужд, то можно попробовать построить его на более общих правилах, которые предоставляет нам "Clear architecture", ведь DDD основывается именно на них.

## Clear architecture

![](_png/Pasted%20image%2020230530140004.png)

Также есть попытки следовать всем постулатам чистой архитектуры и абстрагироваться от представления совсем. В этом случае мы сможем подменять view на любой фреймворк или вообще отказаться от его использования. Интересный подход и в некоторых случаях вполне обоснован и может оказаться отличным решением. Самый частый кейс, это использование одной и той же логики в браузере и на мобильном приложении.  
Подробнее об этом можно [почитать тут](https://dev.to/xurxodev/moving-away-from-reactjs-and-vuejs-on-front-end-using-clean-architecture-3olk).

![](_png/Pasted%20image%2020230530140014.png)

Разработчики Flutter тоже столкнулись с проблемой сложности переиспользования логики между различными представлениями, и предложили подход - [Business Logic Component (BLoC)](https://pub.dev/packages/flutter_bloc). Он позволяет снизить нагрузку на компоненты пользовательского интерфейса, отделив от них бизнес-логику.

[Тут пример одной из реализаций BLoC в React](https://blog.bitsrc.io/using-bloc-pattern-with-react-cb6fdcfa623b).  
  
Вроде неплохо, но все же есть много вопросов. И почти нет сообщества, которое бы могло помочь с возникающими вопросами.

## FSD - Feature Sliced Design

И недавно для меня стало открытием методология FSD - Feature Sliced Design. На мой взгляд лучшем решением будет обратить внимание именно на эту методологию. 

![](_png/Pasted%20image%2020230530140024.png)

[Ссылка на офф сайт](https://feature-sliced.design/).

Методология не привязана к конкретному стеку технологий и применима к большинству frontend-приложений. Документация содержит примеры реализации на JavaScript + React, но FSD успешно адаптируется и к другим комбинациям инструментов.

Для проектирования архитектуры методология предлагает следующие архитектурные абстракциями на основе которых строится наше приложение.  

![](_png/Pasted%20image%2020230530140031.png)

#### Ниже приведу описание терминов из документации:Layers​

Первый уровень абстрагирования - **согласно скоупу влияния.**

- `app` - инициализация приложения _(init, styles, providers, ...);_
- `processes` - бизнес-процессы приложения управляющие страницами _(payment, auth, ...);_
- `pages` - страницы приложения _(user-page, ...);_
- `features` - части функциональности приложения _(auth-by-oauth, ...);_
- `entities` - бизнес-сущности _(viewer, order, ...);_
- `shared` - переиспользуемый инфраструктурный код _(UIKit, libs, API, ...)._

#### Slices​

Второй уровень абстрагирования - **согласно бизнес-домену.**

Правила, по которым код разделяется на слайсы, _зависят от конкретного проекта и его бизнес-правил_ и не определяются методологией

#### Segments​

Третий уровень абстрагирования - **согласно назначению в реализации.**

- `ui` - UI-представление модуля _(components, widgets, canvas, ...);_
- `model` - бизнес-логика модуля _(store, effects/actions, hooks/contracts, ...);_
- `lib` - вспомогательные библиотеки;
- `api` - логика взаимодействия с API;
- `config` - модуль конфигурации приложения и его окружения.

Ниже приведу пример описания фичи авторизации.

```
# Сегменты могут быть как файлами, так и директориями
|
├── features/auth                # Layer: Бизнес-фичи
|        |                       #    Slice Group: Структурная группа "Авторизация пользователя"
|        ├── by-phone/           #      Slice: Фича "Авторизация по телефону"
|        |     ├── ui/           #         Segment: UI-логика (компоненты)
|        |     ├── lib/          #         Segment: Инфраструктурная-логика (helpers/utils)
|        |     ├── model/        #         Segment: Бизнес-логика
|        |     └── index.ts      #         [Декларация Public API]
|        |
|        ├── by-oauth/           #      Slice: Фича "Авторизация по внешнему ресурсу"
|   ...           
```

Помимо унификации структуры, мы получаем наглядную бизнес логику, отличное описание слоев приложения с примерами на популярных ЯП. Также есть ответы на вопросы о расположении функционала и понятные правила уменьшения зависимостей в коде.  
  
Эта методология только развивается и есть хорошее комьюнити, которое так же как и мы задается вопросами архитектуры фронтенда.

## Заключение

У каждого из подходов есть свои плюсы и минусы. Учитывая что каждый проект имеет разный размер, сложность и специфику и цели, то что подойдет многим не факт что подойдет вам. Надеюсь что после прочтения статьи вы откроете для себя что то новое и сможете улучшить ваши собственные проекты.

--- 

# FSD - Feature Sliced Design 

[Официальный сайт](https://feature-sliced.design/ru/docs/get-started/overview)

Сегодня никого не удивишь тем, что бизнес-требования и приоритеты в развитии проектов постоянно меняются. Поэтому важно спроектировать такую архитектуру, которая будет гибкой, легко масштабируемой и поддерживаемой, а также иметь единую терминологию. Это позволит онбордить новых сотрудников на проекте быстро и эффективно.

Мы используем preact/compat — с его помощью получаем доступ к множеству библиотек экосистемы React, что делает разработку более гибкой, и при этом можем использовать Preact. Но эти же плюсы зачастую оборачиваются в обратную сторону: например, нет единой методологии по проектированию приложений, как, например, в Angular. Кроме того, многообразие библиотек усложняет погружение в проект, а свобода в реализации и проектировании может обернуться захламлением кодовой базы, что пугает разработчиков, особенно новичков. 

Я встречал проекты, в которых раскиданы несколько одинаковых по функционалу компонентов. Например, пять вариаций одной кнопки, а чистые UI-компоненты находились рядом с компонентами, напрямую связанными с доменной областью приложения.

Для нашей команды эти проблемы также актуальны. Чтобы их решить раз и навсегда, мы обратились к активно развивающейся методологии [Feature-Sliced Design (FSD)](https://feature-sliced.design/ru/). Ниже я познакомлю с ее главными принципами и с нашим опытом ее использования. Забыл представиться — я Женя, фронтенд-разработчик в команде Quick Experiments inDrive. Расскажу, как мы занимаемся разработкой внутренних стартапов на основе бизнес-гипотез с помощью FSD.

![](_png/Pasted%20image%2020230530141042.png)

## Уровни абстракции в FSD

В методологии FSD используются три уровня абстракции:

1. Cлои. Этот уровень определяет скоуп ответственности слоя, а также уровень опасности изменений. Чем выше расположен слой, тем выше уровень его ответственности и знаний о других слоях. Чем ниже расположен слой, тем он более абстрактный и больше используется в верхних слоях, а значит больше опасности вносить в него изменения.
2. Cлайсы. Они отображают конкретную функциональность бизнес-логики. Методология почти не влияет на этот уровень, многое зависит от конкретного проекта. По факту это папки, которые группируют файлы, реализующие тот или иной модуль.
3. Сегменты. Распределяются по назначению модуля в коде и реализации. По методологии каждый сегмент отвечает за свою часть технической реализации модуля:

- `api/` — работа с API. Авторы методологии советуют класть API-логику в `shared`, чтобы она не распылялась по проекту.
- `config/` — конфигурация модуля.
- `lib/` — различные утилитарные функции и вспомогательные библиотеки. 
- `model/` — бизнес-логика: store, actions, effects, reducers и так далее.
- `ui/` — отвечает за отображение.

![](_png/Pasted%20image%2020230530141052.png)

Графическое представление методологии FSD

Наша команда практически не использует третий уровень из-за того, что он усложняет структуру приложения. Было решено применять сегменты только в случае, если модуль будет достаточно большим и двух уровней декомпозиции не хватит для корректного абстрагирования логики.

Важное правило архитектуры FSD, о котором я не могу не упомянуть:

> Один модуль не должен использовать другой модуль, расположенный на том же слое или на слоях выше. Например, фича А не должна импортировать фичу B. В противном случае модули перестают быть изолированными друг от друга и теряют устойчивость к новыми требованиям. 
> 
> Когда мы модифицируем фичу B, мы неявно изменяем и фичу A. В небольшом приложении, возможно, это не так критично. Но чем больше людей работает над проектом и чем объемнее кодовая база, тем сложнее держать в голове все связи между модулями. Данное правило позволяет стандартизировать этот процесс, упрощает рефакторинг и модификацию модулей.

Перед тем, как рассмотрим каждый слой отдельно, несколько общих советов по внедрению FSD:

1. Понимание методологии должно быть у всех разработчиков в команде. Новые разработчики должны в обязательном порядке прочитать документацию о FSD. В противном случае пользы от внедрения методологии точно не будет.
2. Глобальные изменения в архитектуре необходимо обсуждать всей командой. Важно периодически проводить анализ архитектуры на наличие кросс-импортов и «болей» в кодовой базе. В целом, совет актуален и для архитектур других видов. 
3. Необязательно использовать FSD на «полную мощь» со всеми уровнями абстракции и видами слоев. Проекты могут существенно отличаться, опыт разработчиков тоже разный, поэтому лучше, чтобы команда сама договорилась о нужном уровне декомпозиции. В процессе разработки этот параметр всегда можно подстроить, чтобы найти свой оптимальный баланс между легкостью внедрения и преимуществами методологии.

## Слои FSD

Рассмотрим каждый слой подробно — от самого нижнего до самого верхнего.

1. `Shared` — самый абстрактный слой приложения, который содержит переиспользуемые модули, не связанные с бизнес-логикой. Этот слой хорошо подходит для начала применения FSD. В наших проектах эта директория делится на несколько сегментов, некоторых из которых нет в FSD:

- `shared/api` — работа с API.
- `shared/config` — модуль конфигурации приложения и его окружения. 
- `shared/hooks` — кастомные хуки.
- `shared/lib` — различные утилитарные функции и вспомогательные библиотеки.
- `shared/themes` — список цветов и тем приложения.
- `shared/ui` — UI-компоненты: `Input`, `Select`, `Table` и другие. 

Самое главное — не путать абстрактные UI-компоненты с компонентами, реализующими конкретные бизнес-сущности или фичи. К примеру, Select — это Shared/UI-компонент, а CitySelect — уже фича. При создании того или иного модуля нужно оценить, будут ли использоваться бизнес-сущности в компоненте. Если нет — модуль необходимо назвать максимально абстрактно и поместить в Shared. В противном случае, желательно указать в названии бизнес-сущность или фичу, которую модуль реализует, и поместить в слой Entities или Features. От грамотного нейминга в этой методологии зависит очень многое. 

2. `Entities` — это компоненты, связанные с представлением бизнес-сущностей, «кирпичики», с помощью которых происходит построение бизнес-логики. Этот слой стоит внедрять желательно вместе со слоем Features, о котором расскажу ниже.
3. `Features` — части функциональности приложения. Пожалуй, самый сложный для понимания и определения слой в методологии, так как само определение «фичи» зависит от конкретной прикладной области и бизнес-требований. Поэтому при переходе на FSD нужно внедрять «фичи»  только при полной уверенности, что это не внесет дополнительную сложность для разработчиков.

Изначально в нашей команде было проблемно определить разницу между Features и Entities. После нескольких обсуждений мы договорились, что фича — это полезная и, желательно, одна функциональность для пользователя, а сущность — то, с помощью чего реализуется эта функциональность. Например, City, Product — сущности, а SearchByCity, BuyProduct — фичи.

4. `Widgets` — самостоятельные и полноценные блоки страниц с конкретными действиями. Слой также хорошо подходит для начала применения FSD: в разных страницах одного приложения многие части часто повторяются. Чтобы не дублировать их реализацию, части можно выносить в виджеты. 
5. Со слоем `Pages`, я думаю, все просто и понятно — это страницы нашего приложения. Методология советует, чтобы каждая страница имела максимально простую структуру, а бизнес-логику переносить на более низкие слои. Поэтому страница — это композиция из виджетов и/или фич, которая отображает взаимодействие между нижележащими слоями. 
6. Следующего слоя в FSD нет, но наша команда решила вынести логику работы с ==роутами== в отдельный слой, чтобы не перегружать слой App или Pages. Если разработчик захочет, например, добавить новый роут или изменить адрес существующего, он точно будет знать, в каком месте вносить правки, а не искать среди большого количества оберток.
7. В папке `Processes` находится логика, которая затрагивает несколько страниц или все приложение. В нашем проекте мы вынесли в этот слой аутентификацию, так как она влияет на работу всего приложения inDrive.
8. В `App` находится общая инициализирующая логика приложения — различные обертки, глобальные сторы и стили. В общем, все то, что влияет на работу всего приложения.

Основная сложность FSD заключается в более высоком пороге входа по сравнению с другими распространенными подходами. Разработчику приходится учиться понимать потребности пользователя и цели бизнеса. 

Если проект начат с нуля по FSD, то первоначально все концепции, описанные выше, кажутся ненужными и переусложненными. Я за то, чтобы внедрять новые слои и уровни декомпозиции только в тот момент, когда команда действительно осознает, что они ей нужны. Иначе большое количество слоев может навредить и запутать разработчиков. Да и сама методология, как я писал выше, не обязывает использовать все подходы. 

Эти сложности в полной мере компенсируется преимуществами в виде упрощения онбординга, командного взаимодействия и единой терминологии. Методология подталкивает разработчиков сфокусироваться на задачах бизнеса и отражать их в коде. Тогда (в идеале, конечно) никому не придется объяснять, ради чего создавался тот или иной модуль.