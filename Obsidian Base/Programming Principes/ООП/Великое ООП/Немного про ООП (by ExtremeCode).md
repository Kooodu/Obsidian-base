# Немного про ООП
#OOP #CSharp

### **Инкапсуляция**

- Инкапсуляция обеспечивает объединение данных и функции и в некоторых случая позволяет ограничить доступ одних объектов к другим.

Инкапсуляция обеспечивает сокрытие данных, но не является самим сокрытием данных. Она не всегда даёт такую возможность, так как некоторые языки представляют механизм рефлексии, который позволяет менять приватные данные
![](_png/Pasted%20image%2020220907172725.png)![](_png/Pasted%20image%2020220907172737.png)
- Инкапсуляция по Герберту Шилдту
![](_png/Pasted%20image%2020220907172743.png)
### **Наследование**

- Механизмы наследования можно заменить с помощью агрегации и композиции, однако эта парадигма нужна для формирования иерархии родственных объектов и создавать более благоприятные условия для реализации полиморфизма.

Однако тут стоит упомянуть, что наследование может быть даже вредно в реальных проектах, ведь можно поломать весь код из одного места и когда у родителя огромное множество наследников – вносить правки становится крайне сложно
![](_png/Pasted%20image%2020220907172804.png)![](_png/Pasted%20image%2020220907172811.png)
- Идеальный пример наследования можно увидеть в прототипировании JS. Тут в качестве родителя выступает конкретно сформированный объект и объекты можно сотворять на ходу
![](_png/Pasted%20image%2020220907172819.png)
### **Полиморфизм**

- Ad Hoc полиморфизм – который представлен перегрузкой методов
![](_png/Pasted%20image%2020220907172829.png)
- Параметрический полиморфизм – который представлен в C# через Generics

- И полиморфизм подтипов, который мы достигаем через наследование и апкаст. Легче всего его понять, используя паттерн «Стратегия»
![](_png/Pasted%20image%2020220907172837.png)
- Ещё один пример полиморфизма в логировании
![](_png/Pasted%20image%2020220907172846.png)
- А таким образом можно показать полиморфизм в JS
![](_png/Pasted%20image%2020220907172853.png)
- А тут пример, когда полиморфизм обеспечивает сокрытие. Тут представлен публичный метод Test, который при вызове в классе Program не позволит скомпилировать программу, так как теперь к нему нет доступа (он стал приватным и вызывается через метод Test2)
![](_png/Pasted%20image%2020220907172900.png)
### **Абстракция**

- Инкапсуляция влияет на формирование интерфейса нашего будущего типа
![](_png/Pasted%20image%2020220907172908.png)
### **Посылка сообщения**

- Объект вызывает метод у другого объекта
![](_png/Pasted%20image%2020220907172915.png)
- Если в C такая парадигма может сработать, то уже в C# компилятор за такой подход надаёт по рукам
![](_png/Pasted%20image%2020220907172923.png)
### **Повторное использование**

- Парадиигма, которая определяет повторное использование кода в проектах. Обычно и эту парадигму опускают в описании