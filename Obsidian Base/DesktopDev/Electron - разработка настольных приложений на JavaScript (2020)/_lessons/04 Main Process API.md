## 010 Модуль [app](https://www.electronjs.org/docs/latest/api/app)

Модуль `app` это уже готовый объект со своими методами, к которому мы можем подключаться  

С помощью метода `on` электрон подписывает основной процесс на определённые события 

`src > main > index.js`
```JS
import { app } from "electron";

// это ивент, который срабатывает на macOS при загрузке приложения
app.on("will-finish-launching", () => {
	console.log("will-finish-launching");
});

// Это ивент, который срабатывает при загрузке приложения
app.on("ready", () => {
	console.log("ready");
});
```
![](_png/Pasted%20image%2020221112170925.png)

Так же мы можем воспользоваться вполне конкретным промисом, который будет срабатывать при загрузке программы 

```JS
import { app } from "electron";
app.whenReady().then(() => console.log("App is ready"));
```
![](_png/Pasted%20image%2020221112171225.png)

Так же у нас есть ивенты на выход:
- `before-quit` до закрытия всех окон приложения
- `will-quit` после закрытия всех окон приложения
- `quit` срабатывание при выходе из приложения

От смены порядка их выхода ничего не поменяется - они всегда имеют своё собственное время вызова 

```JS
import { app } from "electron";

app.on("before-quit", () => console.log("before quit"));
app.on("will-quit", () => console.log("will quit"));
app.on("quit", () => console.log("quit"));

app.whenReady().then(() => {
	// функция quit выключит приложение
	setTimeout(() => app.quit(), 3000);
});
```
![](_png/Pasted%20image%2020221112172049.png)

Так же мы имеем два метода выхода из приложения:
- `quit()` - выполняет ивенты `quit`. Обычный выход.
- `exit()` - выходит, выполняя только ивент `quit` и без спрашивания пользователей. Выход, который стоит использовать при ошибке

Методы `getAppPath()` (получить путь до программы) и  `getPath()` (получить любой путь) позволяют получить доступ к пути на компьютере.

Конкретно тут при запуске дебаггера мы один раз тыкаем по выполнению и переходим к точке останова до того момента, где мы сгенерировали переменную `application`.
```JS
import { app } from "electron";

app.whenReady().then(() => {
	let application = app;
	debugger;
});
```

![](_png/Pasted%20image%2020221112181551.png)
А тут уже мы можем получить путь до приложения
![](_png/Pasted%20image%2020221112181554.png)

Дальше идёт функция `getPath()`, через которую мы можем получить важные пути:
- `temp` - временные данные
- `userData` - все данные связанные с пользователем
- `logs` - папка с логами программы
- `exe` - папка программы

![](_png/Pasted%20image%2020221112182414.png)

>[!note] ##### Все имена, которые мы можем вложить в `getPath()`
> - `name` string - You can request the following paths by the name:
    >-   `home` User's home directory.
    >-   `appData` Per-user application data directory, which by default points to:
    >    -   `%APPDATA%` on Windows
    >    -   `$XDG_CONFIG_HOME` or `~/.config` on Linux
    >    -   `~/Library/Application Support` on macOS
    >-   `userData` The directory for storing your app's configuration files, which by default is the `appData` directory appended with your app's name. By convention files storing user data should be written to this directory, and it is not recommended to write large files here because some environments may backup this directory to cloud storage.
    >-   `sessionData` The directory for storing data generated by `Session`, such as localStorage, cookies, disk cache, downloaded dictionaries, network state, devtools files. By default this points to `userData`. Chromium may write very large disk cache here, so if your app does not rely on browser storage like localStorage or cookies to save user data, it is recommended to set this directory to other locations to avoid polluting the `userData` directory.
    >-   `temp` Temporary directory.
    >-   `exe` The current executable file.
    >-   `module` The `libchromiumcontent` library.
    >-   `desktop` The current user's Desktop directory.
    >-   `documents` Directory for a user's "My Documents".
    >-   `downloads` Directory for a user's downloads.
    >-   `music` Directory for a user's music.
    >-   `pictures` Directory for a user's pictures.
    >-   `videos` Directory for a user's videos.
    >-   `recent` Directory for the user's recent files (Windows only).
    >-   `logs` Directory for your app's log folder.
    > -   `crashDumps` Directory where crash dumps are stored.

Так же у нас может быть только один запущенный экземпляр `app`. Дело в том, что если бы у нас было несколько запущенных основных процессов, то все бы они отправляли запросы на один API и это вызвало бы различные конфликты. 

Чтобы решить проблему, пользователю дали возможность запускать несколько окон в приложении вместо запуска одного и того же приложения несколько раз

Однако нужно упомянуть, что мы можем запустить второй экземпляр программы через консоль, что может привести к неприятным последствиям. Для решения этой проблемы, можно написать:

```JS
// получаем экземпляр блокировки данного приложения
const lock = app.releaseSingleInstanceLock();

// если мы не получили блокировку, то значит, что может быть запущено второе приложение, поэтому
if (!lock) {
	// выход из приложения
	app.quit();
} else {
	// если пытаемся создать второй инстанс, то
	app.on("second-instance", () => {
		// создаёт фокус на включённом приложении
		app.focus();
		// выполнит лог при попытке запуска второго проекта
		console.log("App is alredy running");
	})
}
```

Обычно паттерн, представленный ниже используют в каждом приложении:

```JS
const lock = app.releaseSingleInstanceLock();

if (!lock) {
	app.quit();
} else {
	app.on("second-instance", () => {
		if (win) {
			win.focus();
		}
	})
}
```

Функция `showAboutPanel()` покажет панель о нашей программе. Однако без инстанса нашего окна, у нас выйдет окно о версии электрона

```JS
import { app } from "electron";

const lock = app.releaseSingleInstanceLock();

if (!lock) {
	app.quit();
} else {
	app.on("second-instance", () => {
		if (win) {
			win.focus();
		}
	})
}

app.whenReady().then(() => {
	// покажет панель о программе
	app.showAboutPanel();
});

```
![](_png/Pasted%20image%2020221112194044.png)

## 011 Модуль BrowserWindow

Модуль `BrowserWindow` хранит в себе класс, который позволяет отображать окно

```JS
import { app, BrowserWindow } from "electron";

app.on("ready", () => {
	let window = new BrowserWindow({
		width: 1280,
		height: 720,
	});

	window.loadURL("https://google.com");
});
```
![](_png/Pasted%20image%2020221112205758.png)




## 012 Модуль Menu



## 013 Модуль Tray







