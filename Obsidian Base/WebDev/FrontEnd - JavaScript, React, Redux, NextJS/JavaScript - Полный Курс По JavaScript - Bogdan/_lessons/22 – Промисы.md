## **22 – Промисы**

### **001 Введение в промисы**

- Промисы позволяют выполнять задачи, на которые ещё сервер не успел дать ответ. JS код сможет выполнять определённые действия, пока выполняется другая задача
![](../_png/Pasted%20image%2020220908193835.png)![](../_png/Pasted%20image%2020220908193839.png)
![](../_png/Pasted%20image%2020220908193845.png)
- Так же у промиса есть три состояния:

1) Ожидание выполнения (промис создан)

2) Промис исполнен (вернул результат)

3) Отклонён (вернул ошибку)
![](../_png/Pasted%20image%2020220908193856.png)
### **002 Создание и использование промисов**

- При создании промиса, он находится в режиме pending (ожидание). В сам промис мы передали в виде аргументов две функции, одну из которых нужно вызвать в самом промисе (resolve – задача решена, reject – вышла ошибка)
![](../_png/Pasted%20image%2020220908193901.png)
- Получить значение из промиса можно через методы «.then().catch()». Первый возвращает значение в результате успешного выполнения, второй выполняется результате ошибки. Внутрь данных методов мы вкладываем колбэк функции. В качестве аргумента функции (then()) выступает значение resolve, которое было вложено в сам промис
![](../_png/Pasted%20image%2020220908193909.png)
### **003 Использование промисов в fetch**

- Когда мы посылаем запрос через fetch, то пока мы не получим ответ от сервера, промис будет оставаться в режиме pending. После получения ответа у нас срабатывает один из методов, которые мы подцепили к фетчу. Они выполняются по цепочке: выполняется сначала первый then(), а затем уже второй (тут возвращается JSON и второй метод выводит данный формат)

Так же метод json возвращает промис, так как компьютеру нужно время, чтобы распарсить полученные значения от сервера
![](../_png/Pasted%20image%2020220908193943.png)
- Так же есть сайт, который позволяет получить JSON-данные
![](../_png/Pasted%20image%2020220908193947.png)![](../_png/Pasted%20image%2020220908193951.png)
### **004 Практика по использованию промисов и fetch**

- Сама по себе функция fetch() возвращает промис, а не результат, поэтому требуется использовать для получения результата then()
![](../_png/Pasted%20image%2020220908193956.png)
- Так же если мы будем выполнять инструкции, то нам понадобится вписывать в стрелочную функцию ещё и «{}», что потребует от нас _явного возвращения результата_

Так же нужно упомянуть, что в node нет функции fetch (там для такого же функционала используются другие функции и npm-пакеты)
![](../_png/Pasted%20image%2020220908194002.png)
### **005 Практика с отклонением промисов**

- Тут можно имитировать отключение интернета
![](../_png/Pasted%20image%2020220908194006.png)
- И вот мы видим ошибку от нашего промиса (нет возможности отправить запрос браузеру)
![](../_png/Pasted%20image%2020220908194011.png)
### **006 Вызов fetch внутри промиса**

- Уже тут пошёл пример создания своего промиса, который упростит работу с фетчем. Тут мы сделали стрелочную функцию, которая неявно будет возвращать созданный внутри промис, который внутри имеет фетч, который в свою очередь будет получать данные от сервера (сложно). И далее в любом месте программы можем вызвать данную функцию
![](../_png/Pasted%20image%2020220908194017.png)