#React

## Таймкоды

[00:00](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=0s) ➝ Введение [03:15](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=195s) ➝ Теория [11:40](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=700s) ➝ Начало разработки. Создание проекта [16:10](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=970s) ➝ Что такое JSX? [18:11](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=1091s) ➝ Компонент App. Работа с состоянием. UseState [22:25](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=1345s) ➝ Управляемый инпут [24:07](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=1447s) ➝ Первый функциональный компонент [26:40](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=1600s) ➝ Первый классовый компонент [30:25](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=1825s) ➝ Что такое хуки? useState, useEffect [31:10](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=1870s) ➝ Стили. CSS. Классы [34:30](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=2070s) ➝ Props. Аргументы компонента. [36:55](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=2215s) ➝ Работы со списками. Преобразование массива объектов в массив React элементов [41:50](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=2510s) ➝ Форма создания поста. Управляемые и неуправляемые компоненты [42:30](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=2550s) ➝ Создание UI библиотеки. Первые компоненты. CSS модули. Пропс children [50:00](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=3000s) ➝ Предотвращаем обновление страницы при submit формы [50:45](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=3045s) ➝ хук useRef. Доступ к DOM элементу. Неуправляемый компонент [57:35](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=3455s) ➝ React Devtools. Инструменты разработчика React [59:15](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=3555s) ➝ Обмен данными между компонентами. От родителя к ребенку. От ребенка к родителю. [01:04:20](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=3860s) ➝ Отрисовка по условию [01:05:30](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=3930s) ➝ Сортировка. Выпадающий список [01:12:00](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=4320s) ➝ Поиск. Фильтрация. [01:15:10](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=4510s) ➝ useMemo. Мемоизация. Кеширование [01:23:50](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=5030s) ➝ Модальное окно. Переиспользуемый UI компонент [01:30:23](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=5423s) ➝ Анимации. React transition group [01:33:40](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=5620s) ➝ Декомпозиция. Кастомные хуки [01:36:20](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=5780s) ➝ Работа с сервером. Axios [01:38:40](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=5920s) ➝ Жизненный цикл компонента. useEffect [01:43:08](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=6188s) ➝ API. PostService [01:44:45](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=6285s) ➝ Индикация загрузки данных с сервера [01:46:20](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=6380s) ➝ Компонент Loader. Анимации [01:49:25](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=6565s) ➝ Кастомный хук useFetching(). Обработка ошибок [01:54:15](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=6855s)➝ Постраничный вывод. Пагинация (pagination) [02:06:20](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=7580s) ➝ Обьяснение механизма изменения состояния [02:12:00](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=7920s) ➝ React router. Постраничная навигация. BrowserRouter, Route, Switch, Redirect [02:22:00](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=8520s) ➝ Динамическая навигация. useHistory, useParams [02:29:30](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=8970s) ➝ Загрузка комментариев к посту [02:33:10](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=9190s) ➝ Улучшаем навигацию. Приватные и публичные маршруты [02:38:00](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=9480s) ➝ useContext. Глобальные данные. Авторизация пользователя [02:47:10](https://www.youtube.com/watch?v=GNrdg3PzpJQ&t=10030s) ➝ Бесконечная лента. Динамическая пагинация. useObserver

## Введение

Что будет в курсе:
- Основные концепции
- Управление состояниями + жизненный цикл компонента
- Библиотека UI компонентов
- Реализация постраничной навигации
- Сортировка и поиск
- Работа с сервером
- Модальные окна
- Постраничный вывод
- Бесконечная лента (динамическая пагинация)
- Кастомные хуки, переиспользуемый функционал


## Теория 

==React== - это библиотека по отрисовке пользовательских интерфейсов. 
В браузере отрисовкой занимается ==ReactDOM==, а на приложениях для мобильных устройств отрисовка происходит за счёт ==React Native==.
В первую очередь, React позволяет нам создать ==SPA==.

Обычный подход - это создание ==MPA== (многостраничного приложения), когда у нас создаются отдельные HTML-документы под каждую страницу. 
Основным минусом такого подхода является то, что страницы каждый раз грузятся заново.

![](_png/Pasted%20image%2020221029190138.png)

Современный подход - это создание SPA, которое представляет из себя приложение в браузере. Мы подгружаем не вёрстку, а JS-код, который и генерирует нам страницу в браузере. 
При таком подходе вес первой страницы будет больше, зато сайт будет работать куда быстрее.

![](_png/Pasted%20image%2020221029190529.png)

Реакт использует в своей основе компонентный подход в реализации продукта - внутрь одного компонента мы вкладываем другие компоненты интерфейсов

![](_png/Pasted%20image%2020221029190817.png)

При обычной работе с ДОМ-деревом нам нужно следить за большим количеством элементов. Реакт же в свою очередь сам следить за обновлениями интерфеса в зависимости от того, что мы и куда задали в этих компонентах. То есть разработчик больше времени тратит на проработку логики и распределение данных в приложении.
Мы изменяем данные - интерфейс подстраивается под эти данные.

![](_png/Pasted%20image%2020221029191000.png)

Реакт строит внутри себя ==Дерево React-элементов== (которое обычно называют VirtualDOM, что не есть правильное определение, так как такое же дерево строится и для мобильных устройств). В браузере это дерево элементов представляет из себя облегчённую копию DOM-дерева. 

При каких-либо изменениях, которые должны попасть на дерево элементов, реакт строит второе дерево реакт-элементов, которое и принимает в себя все внесённые нами изменения. Затем происходит сравнение нынешнего дерева реакт-элементов с предыдущим. А уже только потом реакт переносит эти изменения на основное дерево элементов - DOM-дерево (то есть перерендеривает новый интерфейс).
Весь вышеописанный алгоритм называется ==Алгоритмом сравнения== (Reconciliation Algorithm)

Реакт выставляет внутри себя приоритетность рендера разных элементов на странице (более приоритетные - быстрее, менее приоритетные - медленнее), чем позволяет плавно рендерить их пользователю.

За отрисовку в браузере отвечает ReactDOM, за отрисовку на мобильных устройствах React Native.

![](_png/Pasted%20image%2020221029191450.png)

## Начало разработки. Создание проекта 

Создание проекта в данной папке 

```bash
npx create-react-app . // создание реакт приложения
npm start // запуск devServer
```

Далее можем удалить все ненужные компоненты приложения и почистить его

![](_png/Pasted%20image%2020221030134636.png)

Так выглядит почищенный минимальный код для работы React 18:

`public` > `index.html`
```HTML
<!DOCTYPE html>  
<html lang="en">  
   <head>  
      <meta charset="UTF-8" />  
      <meta  
         name="viewport"  
         content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"  
      />  
      <meta http-equiv="X-UA-Compatible" content="ie=edge" />  
      <title>Document</title>  
   </head>  
   <body>  
      <noscript>   
Включите JavaScript в браузере, чтобы приложение  
         заработало  
      </noscript>  
      <div id="root">  
         <!-- Сюда будет монтироваться всё реакт-приложение  -->  
      </div>  
   </body>  
</html>
```

`src` > `App.js`
```JSX
import React from 'react';  
  
function App() {  
   return (  
      <div className='App'>  
         <h1>Привет</h1>  
      </div>  
   );  
}  
  
export default App;
```
`src`  > `index.js`
```JSX
import React from 'react';  
import ReactDOM from 'react-dom/client';  
import App from './App';  
  
const root = ReactDOM.createRoot(document.getElementById('root'));  
root.render(<App />);
```


## Что такое JSX? 

Для написания кода в React используется препроцессор JSX, который позволяет писать HTML-подобную вёрстку внутри его функций. Справа показан пример создания элементов React через его внутренний синтаксис.

![](_png/Pasted%20image%2020221030133539.png)

Весь код, который мы пишем внутри `render` должен содержаться внутри одного `div`. Так выглядит подключение в рендер компонента и созданных элементов 

```JSX
root.render(  
   <div>  
      <h1>Это чистый код</h1>  
      <button>Кнопка</button>  
      <App />   
	</div>,  
);
```
![](_png/Pasted%20image%2020221030134841.png)

И вот так записываются элементы в классическом виде: длинными вложениями друг в друга

```JSX
const root = ReactDOM.createRoot(document.getElementById('root'));  
root.render(  
   React.createElement('div', {},  
      React.createElement(  
         'button',  
         {  
            disabled: true,  
         },  
         'Нажми на меня',  
      ),  
   ),  
);
```
![](_png/Pasted%20image%2020221030135401.png)



![](_png/Pasted%20image%2020221030135625.png)












## Компонент App. Работа с состоянием. UseState 




## Управляемый инпут 




## Первый функциональный компонент 




## Первый классовый компонент 




## Что такое хуки? useState, useEffect 




## Стили. CSS. Классы 




## Props. Аргументы компонента. 




## Работы со списками. Преобразование массива объектов в массив React элементов 




## Форма создания поста. Управляемые и неуправляемые компоненты 




## Создание UI библиотеки. Первые компоненты. CSS модули. Пропс children 




## Предотвращаем обновление страницы при submit формы 




## хук useRef. Доступ к DOM элементу. Неуправляемый компонент 




## React Devtools. Инструменты разработчика React 




## Обмен данными между компонентами. От родителя к ребенку. От ребенка к родителю. 




## Отрисовка по условию 




## Сортировка. Выпадающий список 




## Поиск. Фильтрация. 




## useMemo. Мемоизация. Кеширование 




## Модальное окно. Переиспользуемый UI компонент 




## Анимации. React transition group 




## Декомпозиция. Кастомные хуки 




## Работа с сервером. Axios 




## Жизненный цикл компонента. useEffect 




## API. PostService 




## Индикация загрузки данных с сервера




## Компонент Loader. Анимации 




## Кастомный хук useFetching(). Обработка ошибок 




## Постраничный вывод. Пагинация (pagination) 




## Обьяснение механизма изменения состояния 




## React router. Постраничная навигация. BrowserRouter, Route, Switch, Redirect 




## Динамическая навигация. useHistory, useParams 




## Загрузка комментариев к посту  




## Улучшаем навигацию. Приватные и публичные маршруты 




## useContext. Глобальные данные. Авторизация пользователя 




## Бесконечная лента. Динамическая пагинация. useObserver