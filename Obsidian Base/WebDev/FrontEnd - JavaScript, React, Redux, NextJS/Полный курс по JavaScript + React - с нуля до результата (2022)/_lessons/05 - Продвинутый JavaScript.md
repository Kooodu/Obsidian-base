## **05 - Продвинутый JavaScript**

### **001 Локальные сервера**

- Сервер

- HTTP-запросы: **post****-** (отправить данные на сервер – отправка введённых данных в форму) и **get****-запросы** (получить из google ответ по запросу)

- Самыми популярными запросами являются пост-запросы. И зачастую с ними и придётся работать в вебе, так как нам нужно обрабатывать получаемую от пользователя информацию.

Однако тут мы предстаём перед другой проблемой – маленькие локальные сервера (live server, prepros, встроенные мелкие сервера в IDE) не могут обрабатывать запросы, которые мы на них отправляем.

- Чтобы работать с запросами с сайта, нам нужно воспользоваться более полноценными локальными серверами. Например, можно скачать Open Server

### **002 JSON формат передачи данных, глубокое клонирование объектов**

- JSON – более современный формат обмена данными между сервером и клиентом. Он пришёл на смену XML, который был куда более тяжёловесным.

Мы имеем два основных метода. JSON.parse() переводит объект в JSON, JSON.stringify() возвращает из JSON нужный нам объект

Так же такой подход позволяет сделать глубокое копирование объектов (когда копируются объекты полностью любой вложенности), как тут показано на примере, когда мы меняем значения вложенных объектов
![](../_png/Pasted%20image%2020220909180328.png)

### **003 AJAX и общение с сервером**

Технология AJAX (Async JS and XML) используется для динамической генерации контента на странице. Она позволяет интерактивно менять контент, что выглядит красиво и позволяет не перезагружать страницу для изменения контента. Это снижает количество потребляемого трафика (так как грузится только часть страницы, а не вся страница) и снижает нагрузку на сервер

![](../_png/Pasted%20image%2020220909180338.png)
- Тут представлен код HTML и слева код – данные с сервера
![](../_png/Pasted%20image%2020220909180345.png)
- Получаем инпуты
![](../_png/Pasted%20image%2020220909180349.png)
- Два ивента для инпутов:
![](../_png/Pasted%20image%2020220909180352.png)
- Три основных метода запросов на сервер

**Open**(**метод**(пост- или гет-запрос), **ссылка на файл запроса**, **асинхронность** (true/false – изначально стоит в true, так как выполняется запрос к серверу и работа страницы асинхронно и это нормально), **логин**, **пароль**)

Гет-запросы можно реализовать даже на простом сервере (тот же Live Server)

**setRequestHeader** – отправляет сам json-файл. В него мы вставляем заголовок типа и сам тип

**send** – в данном случае отправляет пустой запрос на получение данных. Однако, если мы будем использовать пост-запрос, то нужно будет в сенд передать отправляемые данные
![](../_png/Pasted%20image%2020220909180359.png)
- Так же у нас есть определённые свойства, которые хранит наш реквест:

status - Содержит статус нашего запроса (404 и тд) - [https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP)

statusText - текстовое описание ответа от сервера (OK(200), Not Found(404))  
response - ответ от сервера (задаёт бэк-энд разработчик)  
readyState - текущее состояние запроса (таблица)
![](../_png/Pasted%20image%2020220909180405.png)
- Тут представлен код, который выполняет запрос на сервер, получает данные и обрабатывает их, чтобы вывести данные в инпут
![](../_png/Pasted%20image%2020220909180410.png)
- Данный ивент срабатывает при выполнении запроса. Однако выполниться запрос может и с ошибкой, поэтому полностью условие убрать на проверку правильности – не получится. В остальном код работает ровно так же, только уже можно не проверять на полное выполнение запроса
![](../_png/Pasted%20image%2020220909180416.png)
- И так выглядит итог
![](../_png/Pasted%20image%2020220909180420.png)
- Полный код:
![](../_png/Pasted%20image%2020220909180425.png)
Первый вариант
![](../_png/Pasted%20image%2020220909180430.png)
Второй вариант
![](../_png/Pasted%20image%2020220909180433.png)
### **004 Реализация скрипта отправки данных на сервер**

- Сейчас нужно будет реализовать ПОСТ-запрос отправку данных на сервер и ответ пользователю

PHP файл будет возвращать данные, которые мы отправляем на сервер (принимает данные с клиента, превратит в строку и вернёт обратно) – это response от сервера
![](../_png/Pasted%20image%2020220909180440.png)
![](../_png/Pasted%20image%2020220909180444.png)
![](../_png/Pasted%20image%2020220909180449.png)
- В классической работе браузера (без модификаций через JS) при отправке данных – они перезагружают страницу и показывают отправленные данные в url

Если инпут создан через тег баттон, то у него тег type автоматически будет иметь submit
![](../_png/Pasted%20image%2020220909180453.png)
- Самым первым делом мы получим все формы на нашей странице и заранее подготовим ответы пользователю по статусу отправки данных
![](../_png/Pasted%20image%2020220909180457.png)
- И дальше нам нужно будет создать фунцию, которая будет отправку наших данных на удалённый сервер. Внутри функции будет располагаться ивент, который будет срабатывать на инпутах формы при сабмите (баттоны изначально имеют в себе такой вшитый атрибут). Обязательно в начале нужно сбросить обычное поведение объекта при срабатывании (чтобы страница не перезагружалась)
![](../_png/Pasted%20image%2020220909180502.png)
- Так же отдельно хочется выделить данный функционал. Он позволяет не брать отдельно каждую форму и не перебирать отдельно значения. Данный конструктор позволяет собрать автоматически все данные с формы, которую в него пихнули
![](../_png/Pasted%20image%2020220909180509.png)
Однако **ОБЯЗАТЕЛЬНО**, чтобы сработал формДата, нужно чтобы в инпутах внутри формы были прописаны атрибуты **name=”имя_формы”**
![](../_png/Pasted%20image%2020220909180517.png)
- И дальше нам нужно создать ивент листенер внутри функции, который при полной загрузке запроса будет выводить в консоль сам отправленный запрос (для нас), показывать статус отправки для пользователя и очищать формы.

**reset** – сбросит форму

**remove** – удаляет объект со страницы
![](../_png/Pasted%20image%2020220909180524.png)
- И в конечном итоге нам нужно применить нашу созданную функцию на все формы (через функцию мы накидываем ивент-листенеры на формы и формируем из них данные)
![](../_png/Pasted%20image%2020220909180553.png)
- И сразу при запуске мы встречаемся с непонятной ошибкой, которая нам говорит, что наши данные анонимны и не могут быть обработаны сервером
![](../_png/Pasted%20image%2020220909180601.png)
![](../_png/Pasted%20image%2020220909180605.png)
- И тут уже кроется очень важная особенность работы с ПОСТ-запросами. Если мы используем **XMLHttpRequest**, **ПОСТ-запрос** и передаём данные через **FormData**, то **указывать хедер нам нелья**, так как вылезет ошибка
![](../_png/Pasted%20image%2020220909180613.png)
![](../_png/Pasted%20image%2020220909180618.png)
И так же теперь в консоли мы можем увидеть данные
![](../_png/Pasted%20image%2020220909180623.png)
- Ну и так же в нетворке можно просмотреть и данные, которые были отправлены на сервер
![](../_png/Pasted%20image%2020220909180628.png)
- И так же можно переписать немного код для работы с JSON-данными, а не отправлять через FormatData. Тут уже хедер нам нужно использовать

Так же нужно упомянуть, что PHP не умеет нативно работать с JSON
![](../_png/Pasted%20image%2020220909180644.png)
Вот php-код, который обработает JSON-данные с сервера
![](../_png/Pasted%20image%2020220909180648.png)
- И код работает нормально и ровно так же, как и раньше
![](../_png/Pasted%20image%2020220909180654.png)
- Полный код:
![](../_png/Pasted%20image%2020220909180659.png)
![](../_png/Pasted%20image%2020220909180710.png)
![](../_png/Pasted%20image%2020220909180716.png)
### **005 Красивое оповещение пользователя**

- На сегодня нам нужно сделать красивое оповещение пользователя о загрузке (если она будет долгой).

Первым делом – уберём код с нашего крестика для закрывания модального окна. Мы можем вызвать закрывание прямо внутри условия определения закрытия модального окна (обратиться к крестику через его персональный атрибут data-close)
![](../_png/Pasted%20image%2020220909180724.png)
- Дальше мы должны превести наше модальное окно в генеративный вариант. То есть мы его должны возвращать с помощью JS. Сохраним оригинал в виде prevModal и скроем его. Дальше уже реализуем саму генерацию этого окна и будем сгенерированное окно вставлять в сам блок кода с модальным окном
![](../_png/Pasted%20image%2020220909180730.png)
![](../_png/Pasted%20image%2020220909180734.png)
- И далее применяем нашу функцию
![](../_png/Pasted%20image%2020220909180739.png)
- И теперь обе модалки какое-то небольшое время показывают окно диалога
![](../_png/Pasted%20image%2020220909180744.png)
![](../_png/Pasted%20image%2020220909180747.png)
![](../_png/Pasted%20image%2020220909180753.png)
- Дальше добавляем наш загрузочный спиннер (это свг-анимация, которую можно добавить как картинку)
![](../_png/Pasted%20image%2020220909180800.png)
- И такой код позволит вставить нашу СВГшку после блока форм снизу (чтобы не ломать вёрстку)
![](../_png/Pasted%20image%2020220909180805.png)
### **006 Promise (ES6)**

- Promise (обещание) – это блок кода, который будет выполняться асинхронно относительно другого кода. Промис позволяет избежать «**collback****-****hell**» ситуации, когда у нас огромное количество таймаутов и вложенных функций

- Это код через сетТаймауты, который не гарантирует нам 100% на выполнение кода и может выдать ошибку
![](../_png/Pasted%20image%2020220909180841.png)
- И коротко о том, что такое промисы. Они позволяют реализовать код, который обещают выполнить асинхронно относительно остального кода – они не останавливают выполнение основного потока кода и выполняются параллельно

Промисы создаются через конструктор. Внутрь промиса вкладывается функция, которая принимает в себя два аргумента – resolve и reject, которые тоже являются функциями. Обе вложенные функции отвечают за возврат значения в разных ситуациях.

resolve – возвращает значение, когда функция выполнилась успешно  

reject – возвращает значение, когда функция выполнилась с ошибкой

Дальше идёт уже чейновая природа обработки промиса. Мы пишем имя промиса и **then**().(много then).**catch**().(много catch).**finally**(). Каждый чейн выполняет свою работу, которую мы для него пропишем. **then** срабатывает, когда промис завершается резолвом и так же резолв передаёт своё значение в этот then. **catch** срабатывает, когда промис завершается реджектом и реджект так же передаёт вписанное в него значения в этот кэтч
![](../_png/Pasted%20image%2020220909180849.png)
- И опять же про природу чейнов. Мы могли бы полностью прописывать промисы внутри thenов и создавать всё новые и новые промисы. Однако из thenов мы можем возвращать промисы (будет возвращаться значение внутри резолва или реджекта) и данные будут передаваться дальше по цепочке (выполнилось – передалось дальше и так бесконечно)
![](../_png/Pasted%20image%2020220909180859.png)
![](../_png/Pasted%20image%2020220909180908.png)
- И основной мем, из-за которого мы используем промисы – это их чейновое выполнение. Конкретно тут выполняется сначала первый промис, потом резолв возвращает в then объект. Внутри первого чейна создаём новый промис, который у нас возвращается через ретёрн (возвращается то, что передаёт резолв при выполнении промиса). Дальше у нас идут ещё два чейна, которые выполняют действия последовательно друг за другом
![](../_png/Pasted%20image%2020220909180913.png)
- И если у нас выполняется в конце промиса **reject**, то блок кода чейнится в **catch** (вместо then)
![](../_png/Pasted%20image%2020220909180921.png)
- Чейн **finally** срабатывает при любом исходе промиса (реджект/резолв) и всегда добавляется в конец
![](../_png/Pasted%20image%2020220909180926.png)
- Тут пример небольшого промиса для следующих двух методов
![](../_png/Pasted%20image%2020220909180931.png)
- И далее идёт так же важная команда, которая позволяет реализовать выполнение кода при выполнении сразу нескольких промисов. Например, мы отправили запрос на несколько разных серверов и нам обязательно нужно, чтобы выполнились сразу все нужные запросы (ну будем использовать сразу несколько картинок для иллюстрации чего-то)

Promise.all
![](../_png/Pasted%20image%2020220909180940.png)
- И так же есть метод, который выполняется сразу при выполнении первого промиса – Promise.race()
![](../_png/Pasted%20image%2020220909180951.png)
### **007** **Fetch** **API**

- **fetch** – это конструкция с GET-запросом, которая внутри представляет из себя промис (то есть чейны работают так же как и в промисах)

Стандартно фетч возвращает промис, который выполняется в любом случае (кроме отсутствия интернета)
![](../_png/Pasted%20image%2020220909181020.png)
- Чтобы отправить данные на сервер, нужно уже будет немного модифицировать фетч-запрос

Вторым аргументов в фетч передаётся объект с настройками, который заменяет сразу три метода стандартного реквеста. Мы прописываем тип запроса, бади с отправляемыми данными на сервер (например, отправим данные из формы) и тип заголовков (если отправляем JSON)
![](../_png/Pasted%20image%2020220909181024.png)
- И сейчас на сайте с едой можно будет заменить все наши XMLHTTPRequests на короткий и понятный fetch, который в себе содержит все нужные нам реквесты, да ещё и исполняется асинхронно
![](../_png/Pasted%20image%2020220909181030.png)
- И как итог мы заменили огромное количество кода с реквестами и данной проверкой
![](../_png/Pasted%20image%2020220909181035.png)
На данную короткую запись
![](../_png/Pasted%20image%2020220909181040.png)
- Так же если мы допишем этот короткий участок кода, то мы сможем увидеть текст нашего запроса
![](../_png/Pasted%20image%2020220909181045.png)
- Теперь так же можно удалить парсинг объекта и перенести его прямо в фетч
![](../_png/Pasted%20image%2020220909181050.png)
![](../_png/Pasted%20image%2020220909181055.png)
Ну и примерно так выглядит ответ от серера
![](../_png/Pasted%20image%2020220909181100.png)
- Ну и так же нужно работать с особенностями фетча. Дело в том, что он не вернёт реджект, даже если у нас проблемы при связи с сервером. Единственное что, так это статус фетча поменяется с ОК на false.

Реджект сработает только при сбое сети / отсутствии интернета
![](../_png/Pasted%20image%2020220909181105.png)
![](../_png/Pasted%20image%2020220909181110.png)

### **008 Методы перебора массивов**

- И у нас есть основные методы массивов, которые мы можем использовать на постоянной основе

Метод forEach – просто выполняет какую-то операцию над каждым объектом в массиве. Сам массив он никак не изменяет

filter – позволяет отфильтровать массив по определённому критерию

map – перерабатывает массив нужным нам образом и записывает значения в новый массив. Можно записать значения в тот же самый массив, но это уже будет неправильно
![](../_png/Pasted%20image%2020220909181134.png)
- reduce – самый необычный метод для перебора массива. Через него так же можно создать новый массив. Основная особенность данного метода заключается в том, что в качестве аргумента в него передаётся аккумулятор (переменная, которая сохраняет своё значение на каждую итерацию) и новый элемент массива.

В первом случае мы подсчитали сумму массива. Во втором сумму с начальным элементом для аккумулятора (задаётся через запятую – тут 3). В третьем методе подсчитали зарплату работников. В четвёртом вывели строку с именами сотрудников (тут показана особенность, что выведется строка без запятой сначала, так как метод выполняет сразу вторую итерацию)
![](../_png/Pasted%20image%2020220909181144.png)
- И дальше у нас идут булевые методы, которые позволяют быстро проверить наличие определённого элемента в массиве.

every – проверяет, чтобы каждый элемент выполнял определённое условие (все работники с зп больше 100$)

some – проверяет наличие хотя бы одного элемента, который удовлетворяет условию (хотя бы один работник с зп больше 1000$)
![](../_png/Pasted%20image%2020220909181209.png)
- И далее у нас идёт пример: пришёл ответ от сервера и нам нужно отсортировать ответ так, чтобы остались только люди

Первым делом можно перевести объект в массив массивов (чтобы была возможность сортировки)
![](../_png/Pasted%20image%2020220909181235.png)
Дальше фильтруем массив и оставляем только персон
![](../_png/Pasted%20image%2020220909181241.png)
И уже в конце трансформируем массив так, чтобы в нём остались только люди (под нулевым индексом)
![](../_png/Pasted%20image%2020220909181245.png)
### **009 Подробно про npm и проект. JSON-server**

- Для использования npm в проекте, сначала нужно инициализировать этот проект

**npm init**

**npm i json-server --save-dev**
![](../_png/Pasted%20image%2020220909181310.png)
- Чтобы не загружать на облако папку с модулями, можно её добавить в гитигнор
![](../_png/Pasted%20image%2020220909181314.png)
- Так же если перед нами встанет такая ситуация, когда нам нужно будет установить нод-модули для проекта, у которого есть только json с зависимостями, то нужно прописать

**npm i**
![](../_png/Pasted%20image%2020220909181321.png)
- Если мы напишем запрос именно к нашей базе данных, то мы будем получать все данные со страницы сразу, но в реквестах ничего не будет (так как там отображаются пост-запросы)
![](../_png/Pasted%20image%2020220909181329.png)
![](../_png/Pasted%20image%2020220909181333.png)
- Чтобы активировать установленный json-server на ПК, нужно прописать

**json****-****server** **ссылка_на_датабазу**

И дальше вставить одну из ссылок на ресурсы (нам расширение сразу выдаёт ссылки на данные)
![](../_png/Pasted%20image%2020220909181342.png)
- Ну и так же в расширении будет прописываться скорость выполнения запроса и сам запрос. Уже в браузере будет возвращаться не огромный объект, а конкретный массив
![](../_png/Pasted%20image%2020220909181347.png)
![](../_png/Pasted%20image%2020220909181352.png)
### **010 Получение данных с сервера. AsyncAwait (ES8)**

- В данном уроке нужно заменить отображение карточек на сайте с самостоятельного их создания через свои аргументы на создание по аргументам, полученным с сервера (а именно с нашей базы данных)
![](../_png/Pasted%20image%2020220909181359.png)
![](../_png/Pasted%20image%2020220909181406.png)
- Ну и далее нашу датабазу нужно поместить в корень проекта и отдельно запустить json-server, чтобы работать с этой датабазой
![](../_png/Pasted%20image%2020220909181410.png)
![](../_png/Pasted%20image%2020220909181425.png)
- И дальше нам нужно заменить фетч-запрос в нашем postData, чтобы мы могли запрашивать разыне данные по определённым параметрам.

Для этого сначала переименуем нашу основную функцию и сам пост данных забьём в отдельную функцию, внутри которой и будем вызывать фетч. Результат фетча (это промис) будем сразу переводить в JSON
![](../_png/Pasted%20image%2020220909181431.png)
![](../_png/Pasted%20image%2020220909181435.png)
- И дальше мы встречаемся с проблемой. Промисы – это асинхронный код, который выполняется вне основного потока функции. Поэтому на момент возвращения результата мы получим ошибку, так как res будет равен undefined. Чтобы решить проблему, нужно превратить код в синхронный, чтобы ретёрн дождался выполнения промиса
![](../_png/Pasted%20image%2020220909181441.png)
- И далее нам приходит на помощь конструкция async/await. Она работает примерно по такому принципу:

Async говорит, что в функции есть асинхронные функции (промисы), а уже сам await говорит этой функции, что это и есть асинхронная функция и что её результата выполнения нужно дождаться, прежде чем выполнять код дальше. То есть выполнение кода остановится до получения любого результата этой функции

Так же авейт можно накинуть и на метод, который переводит промис в json (так как неизвестно насколько большой ответ от сервера придёт)
![](../_png/Pasted%20image%2020220909181448.png)
- Примерно так выглядит итоговый запрос. Ссылка взята из джсон-сервера и перевод данных в текст убран (самый первый чейн)
![](../_png/Pasted%20image%2020220909181453.png)
- И такой ответ от сервера мы получаем
![](../_png/Pasted%20image%2020220909181457.png)
- И самая прикольная вещь тут – это наш первый постинг данных на сервер с записью ответа в датабазу
![](../_png/Pasted%20image%2020220909181503.png)
- Ну и далее мы можем немного заменить такой формат записи данных из формдаты в объект
![](../_png/Pasted%20image%2020220909181508.png)
- Мы можем это реализовать через метод entries, который переводит свойства объекта в массивы
![](../_png/Pasted%20image%2020220909181513.png)
- И поэтому мы сейчас выполним такую комбинацию:

1) Сначала **formData** переведём в массив массивов (можно записать и **Object****.****entires****(****formData****)**)

2) Потом переведём через **Object****.****fromEntires** этот массив массивов в обычный объект

3) Потом через стригифай переведём объект в джсон-формат данных

4) Передадим переменную с джсоном в постДату
![](../_png/Pasted%20image%2020220909181518.png)
- Дальше переходим ко второй части, где мы должны заменить генерацию наших карточек из собственных запросов и генераций.

Тут нам нужны простые гет-запросы, поэтому оставляем только ссылку.

Дальше нам нужно решить проблему с тем, что фетч может вернуть ошибку. Кэтч нам недоступен, так как он вызывается только при отсутствии интернета. Делается это просто. У фетча есть свойство «ok» и нам нужно проверить, что если он отрицательный, то нам нужно будет выдать ошибку. В ошибке можно указать ещё и свойство статуса фетча
![](../_png/Pasted%20image%2020220909181525.png)
- И дальше нам нужно выполнить наш запрос. При отправке запроса на сервер, мы получаем всю нашу дадабазу.

Затем в then обрабатываем наш запрос. Все данные (само меню) хранятся в массиве (массив объектов, где объект - менюшка), поэтому нужно будет перебрать полученную дату через форич.

В переборе мы не передаём item, а сразу можем деструктуризировать полученный элемент на отдельные свойства, чтобы было проще (чтобы не обращаться постоянно item.img, item.altimg и так далее)
![](../_png/Pasted%20image%2020220909181532.png)
![](../_png/Pasted%20image%2020220909181538.png)
- Так же можно таким способом реализовать рендер элементов на странице – не через наш созданный класс, а через функцию, которая принимает в себя массив карточек
![](../_png/Pasted%20image%2020220909181544.png)
### **011 Дополнительно Что такое библиотеки. Библиотека axios**

- Часть про библиотеки: вставляем все библиотеки над нашим скриптом, чтобы при выполнении логики основного файла, он смог ссылаться на эту библиотеку
![](../_png/Pasted%20image%2020220909181551.png)
- А сейчас про библиотеку Axios: [https://github.com/axios/axios](https://github.com/axios/axios). Это библиотека, основанная на промисах и позволяющая быстро писать пост- и гет-запросы на сервер

- Сразу нужно сказать, что если мы вставили аксиос ссылкой в HTML, то импортить его не нужно – это и будет ошибкой
![](../_png/Pasted%20image%2020220909181555.png)
- Пишем данный коротенький запрос и получаем на выходе конечный объект, конвертация в нужный тип, расширенные свойства и проверка на ошибки – из коробки

Все полученные данные хранятся в **data****!**
![](../_png/Pasted%20image%2020220909181559.png)
![](../_png/Pasted%20image%2020220909181604.png)
- И вот такой код заменит нам то, что мы делали в прошлом уроке. Тут мы получили сразу нужные данные и сразу же их и вывели
![](../_png/Pasted%20image%2020220909181609.png)
![](../_png/Pasted%20image%2020220909181613.png)
### **012 Создаем слайдер на сайте. Вариант 1 - простой**

Простой вариант создания слайдера:

```JS
// Получаем массив слайдеров и стрелочки
const slides = document.querySelectorAll(".offer__slide"),  
      prev = document.querySelector(".offer__slider-prev"),  
      next = document.querySelector(".offer__slider-next");  
// Получаем доступ к номерам слайдеров
const currentSlide = document.querySelector("#current"),  
      totalSlides = document.querySelector("#total");  
// Будем менять индекс выводимых слайдеров
let slideIndex = 1;  

// Выводим первый слайд
showSlides(slideIndex);  

// Будем менять номер слайдера по идентификатору
function showSlideIndex(slideIdentifier, slideDependency) {  
    if (slides.length < 10) {  
        slideIdentifier.textContent = `0${slideDependency}`;  
    } else {  
        slideIdentifier.textContent = slideDependency;  
    }
}  

// Выводим общее количество слайдеров
showSlideIndex(totalSlides, slides.length);  

// Тут уже реализовано отображение слайдов
function showSlides(n) {  
    // Проверяем границы значений слайдов  
    if (n > slides.length) {  // После последнего слайда выводим первый
        slideIndex = 1;  
    }  
    if (n < 1) {  // Если тыкнем меньше первого слайда, то выведем последний слайд
        slideIndex = slides.length;  
    }  
    
    // Скрываем все слайды  
    slides.forEach(item => item.style.display = 'none');  

	// Отображаем слайдер по индексу
    slides[slideIndex - 1].style.display = 'block'; // так же можем поставить ""  

	// Отображаем номер текущего слайда 
    showSlideIndex(currentSlide, slideIndex);  
}  

// Тут мы будем менять отображаемый слайдер через вызов показа слайдов и изменение самого индекса
function changeSlides(n) {  
    showSlides(slideIndex += n);  
}  

// Триггер для показа предыдущего слайда
prev.addEventListener("click", () => {  
    changeSlides(-1)  
});  

// Триггер для следующего слайда
next.addEventListener("click", () => {  
    changeSlides(1);  
})
```
![](_png/Pasted%20image%2020220918103332.png)

### **013 Создаем слайдер на сайте. Вариант 2 - более сложный**

Опишем немного логику нашего слайдера. Самый внешний слайдер теперь будет не просто оболочной для наших слайдов - он будет просто окошком для просмотра слайдов. Ему мы зададим `overflow:hidden`. Дальше у нас идёт inner оболочка, которая будет в ширину равняться сразу всем слайдерам и будет занимать 400% от слайда на странице (400%, так как слайдов 4 штуки)

```HTML
<div class="offer__slider-wrapper">  // Окошко
    <div class="offer__slider-inner">  // Добавили обёртку
        <div class="offer__slide">  
            <img src="img/slider/pepper.jpg" alt="pepper">  
        </div>  
        <div class="offer__slide">  
            <img src="img/slider/food-12.jpg" alt="food">  
        </div>  
        <div class="offer__slide">  
            <img src="img/slider/olive-oil.jpg" alt="oil">  
        </div>  
        <div class="offer__slide">  
            <img src="img/slider/paprika.jpg" alt="paprika">  
        </div>  
    </div>  
</div>
```

```JS
const slides = document.querySelectorAll(".offer__slide"),  
      prev = document.querySelector(".offer__slider-prev"),  
      next = document.querySelector(".offer__slider-next"),  
      total = document.querySelector("#total"),  
      current = document.querySelector("#current"),  
      slidesWrapper = document.querySelector(".offer__slider-wrapper"),  
      slidesField = document.queryав
// Через регулярные выражения получаем ширину слайда  
const width = +sourceWidth.match(/\d/g).reduce((acc, val) => {  
    return acc += val; // собираем все значения массива в один  
});  
  
let slideIndex = 1;  
let offset = 0; // Определяет длину прокрутки внутри slidesField  
  
// Выводим общее количество слайдов
if (slides.length < 10) {  
    total.textContent = `0${slides.length}`;  
    current.textContent = `0${slideIndex}`;  
} else {  
    total.textContent = slides.length;  
    current.textContent = slideIndex;  
}  
  
slidesField.style.width = 100 * slides.length + "%";// Зададим карусельному блоку ширину во все слайды  
slidesField.style.display = "flex"; // Расположим слайды вдоль
slidesField.style.transition = "all .5s"; // Настроим анимацию для всех трансформаций внутри блока (тут - перемещение слайда)  
  
slidesWrapper.style.overflow = "hidden"; // Скрывает все слайды за границами окошка
  
// Задаём всем слайдам одну ширину  
slides.forEach(slide => {  
    slide.style.width = width;  
})  
  
next.addEventListener("click", () => {  
    // Перемещение слайда вперёд
    if (offset === width * (slides.length - 1)) {  
        offset = 0;  
    } else {  
        offset += width;  
    }  
    slidesField.style.transform = `translateX(-${offset}px)`;  

	// Выводим номер слайда
    if (slideIndex === slides.length) {  
        slideIndex = 1;  
    } else {  
       slideIndex++;  
    }  
    if (slides.length < 10) {  
        current.textContent = `0${slideIndex}`;  
    } else {  
        current.textContent = slideIndex;  
    }
});  
  
prev.addEventListener("click", () => {  
    // Перемещение слайда назад
    if (offset === 0) {  
        offset = width * (slides.length - 1);  
    } else {  
        offset -= width;  
    }  
    slidesField.style.transform = `translateX(-${offset}px)`;  

	// Выводим номер слайда
    if (slideIndex === 1) {  
        slideIndex = slides.length;  
    } else {  
        slideIndex--;  
    }  
    if (slides.length < 10) {  
        current.textContent = `0${slideIndex}`;  
    } else {  
        current.textContent = slideIndex;  
    }
});
```

### **014 Создаем навигацию для слайдов**

Индикаторы слайдов сделаем через CSS и JS. Без дополнительных иконок. 

```CSS
.carousel-indicators {  
   position: absolute;  
   right: 0;  
   bottom: 0;  
   left: 0;  
   z-index: 15;  
   display: flex;  
   justify-content: center;  
   margin-right: 15%;  
   margin-left: 15%;  
   list-style: none;  
}  
  
.dot {  
   box-sizing: content-box;  
   flex: 0 1 auto;  
   width: 30px;  
   height: 6px;  
   margin-right: 3px;  
   margin-left: 3px;  
   cursor: pointer;  
   background-color: #fff;  
   background-clip: padding-box;  
   border-top: 10px solid transparent;  
   border-bottom: 10px solid transparent;  
   opacity: .5;  
   transition: opacity .6s ease;  
}
```

И вот сам код слайдера:

```JS
const slides = document.querySelectorAll(".offer__slide"),  
      slider = document.querySelector(".offer__slider"), // Добавляем сам слайдер, чтобы относительно него спозиционировать точки  
      prev = document.querySelector(".offer__slider-prev"),  
      next = document.querySelector(".offer__slider-next"),  
      total = document.querySelector("#total"),  
      current = document.querySelector("#current"),  
      slidesWrapper = document.querySelector(".offer__slider-wrapper"),  
      slidesField = document.querySelector(".offer__slider-inner");  
  
const sourceWidth = window.getComputedStyle(slidesWrapper).width;// Получаем ширину окошка прямо из посчитанных стилей  
// Через регулярные выражения получаем ширину слайда  
const width = +sourceWidth.match(/\d/g).reduce((acc, val) => {  
    return acc += val; // собираем все значения массива в один  
});  
  
let slideIndex = 1;  
let offset = 0; // Определяет длину прокрутки внутри slidesField  
  
  
if (slides.length < 10) {  
    total.textContent = `0${slides.length}`;  
    current.textContent = `0${slideIndex}`;  
} else {  
    total.textContent = slides.length;  
    current.textContent = slideIndex;  
}  
  
slidesField.style.width = 100 * slides.length + "%";// Зададим карусельному блоку ширину во все слайды  
slidesField.style.display = "flex";  
slidesField.style.transition = "all .5s";  
  
slidesWrapper.style.overflow = "hidden";  
  
// Задаём всем слайдам одну ширину  
slides.forEach(slide => {  
    slide.style.width = width;  
})  
  
// Делать точки будем полностью через JS  
slider.style.position = "relative"; // Родитель должен иметь relative  
const indicators = document.createElement("ol"),  
      dots = []; // создаём истинный массив элементов  
indicators.classList.add("carousel-indicators");  
indicators.style.cssText = `  
    position: absolute;    
    right: 0;    
    bottom: 0;    
    left: 0;    
    z-index: 15;    
    display: flex;    
    justify-content: center;    
    margin-right: 15%;    
    margin-left: 15%;    
    list-style: none;
`;  
slider.append(indicators);  
  
for (let i = 0; i < slides.length; i++) {  
    const dot = document.createElement("li");  
    dot.setAttribute("data-slide-to", i + 1); // устанавливаем (атрибут, значение атрибута)  
    dot.style.cssText = `  
        box-sizing: content-box;        
        flex: 0 1 auto;        
        width: 30px;        
        height: 6px;        
        margin-right: 3px;        
        margin-left: 3px;        
        cursor: pointer;        
        background-color: #fff;        
        background-clip: padding-box;        
        border-top: 10px solid transparent;        
        border-bottom: 10px solid transparent;        
        opacity: .5;        
        transition: opacity .6s ease;    
    `;  
    if (i === 0) {  
        dot.style.opacity = 1;  
    }    
    indicators.append(dot); // добавляем на каждой итерации точку  
    dots.push(dot); // и сразу пушим точки в массив  
}  
  
// Активируем точку определённого слайда  
function activateDot() {  
    dots.forEach(dot => dot.style.opacity = ".5");  
    dots[slideIndex - 1].style.opacity = 1;  
}  
  
// Вынесем корректировку числа слайдеров вовне  
function checkToZero() {  
    if (slides.length < 10) {  
        current.textContent = `0${slideIndex}`;  
    } else {  
        current.textContent = slideIndex;  
    }
}  
  
// Так же вынесем создание оффсета  
function createOffset(offset) {  
    slidesField.style.transform = `translateX(-${offset}px)`;  
}  
  
next.addEventListener("click", () => {  
    if (offset === width * (slides.length - 1)) {  
        offset = 0;  
    } else {  
        offset += width;  
    }  
    createOffset(offset);  
  
    if (slideIndex === slides.length) {  
        slideIndex = 1;  
    } else {  
       slideIndex++;  
    }  
    checkToZero();  
    activateDot();  
});  
  
prev.addEventListener("click", () => {  
    if (offset === 0) {  
        offset = width * (slides.length - 1);  
    } else {  
        offset -= width;  
    }  
    createOffset(offset);  
  
    if (slideIndex === 1) {  
        slideIndex = slides.length;  
    } else {  
        slideIndex--;  
    }  
    checkToZero();  
    activateDot();  
});  
  
// Функциональность точек  
dots.forEach(dot => {  
    dot.addEventListener("click", (e) => {  
        // Получаем атрибут слайдера, на который мы тыкнули  
        const slideTo = e.target.getAttribute("data-slide-to");  
        slideIndex = slideTo; // Индекс = текущему слайдеру с таргета  
        offset = width * (slideTo - 1); // считаем оффсет относительно тыкнутого слайдера  
        createOffset(offset);  
  
        if (slides.length < 10) {  
            current.textContent = `0${slideIndex}`;  
        } else {  
            current.textContent = slideIndex;  
        }  
  
        activateDot();  
    })
});
```

### **015 Как сохранить данные без БД. Работа с localStorage**

> [!Info] `localStorage`- это свойство объекта Window, которое хранит в себе данные и сохранено в браузере пользователя. Оно позволяет сохранить данные даже после перезагрузки страницы

>[!Note] Пример использования: 
> 1) Запомнить время, на котором пользователь остановился
> 2) Запомнить введённые данные в поля
> 3) Запомнить настройки сайта (тёмная/светлая тема)

> Однако нужно отметить, что нам доступно только 5 мб информации

И вот пример того, как мы можем закинуть данные в локальное хранилище данных через `localStorage.setItem('ключ', значение)`. В браузере мы можем просмотреть настройки во вкладке Application

```JS
localStorage.setItem('number', 5);
```
![](_png/Pasted%20image%2020220918141638.png)

И так же через `getItem()` мы можем получить нужную нам строку

```JS
localStorage.setItem('string', 'some long string in this life');
console.log(localStorage.getItem('string'));
```
![](_png/Pasted%20image%2020220918142153.png)

А уже таким образом мы можем удалить ненужное нам значение

```JS
localStorage.removeItem('string');
```

Уже эта команда полностью очищает локальное хранилище

```JS
localStorage.clear();
```

Через этот код мы реализовали сохранение галочки на странице. Теперь при перезагрузке она остаётся в позиции checked

```JS
'use strict';

const checkbox = document.querySelector('#checkbox'),
      form = document.querySelector('form'),
      change = document.querySelector('#color');
      
// Проверим, есть ли наша запись при пезагрузке страницы
if (localStorage.getItem('isChecked')) { // если будет отсутствовать, то = null, а null === false
    checkbox.checked = true;
}

// Создадим новую запись в localStorage на клике галочки
checkbox.addEventListener('change', () => {
    localStorage.setItem('isChecked', true);
});
```
![](_png/Pasted%20image%2020220918144626.png)

А тут уже показана реализация изменения цвета формы по листенеру и сохранение этих настроек даже после перезагрузки. Цвет можно убрать только нажав ещё раз по кнопке

```JS
// Проверка на наличие цвета
if (localStorage.getItem('bg') === 'changed') {
    form.style.backgroundColor = 'violet';
}

// Листенер на изменение цвета
change.addEventListener('click', () => {
    if (localStorage.getItem('bg') === 'changed') {
        localStorage.removeItem('bg');
        form.style.backgroundColor = '#fff';
    } else {
        localStorage.setItem('bg', 'changed');
        form.style.backgroundColor = 'violet';
    }
});
```
![](_png/Pasted%20image%2020220918145307.png)

Ну и так же в localStorage мы можем закинуть объект (но только уже стрингифайнутый в JSON)

```JS
const person = {
    name: 'Alex',
    age: 18
}

const serializedPerson = JSON.stringify(person);

localStorage.setItem('alex', serializedPerson);
```
![](_png/Pasted%20image%2020220918145806.png)

Ну и так же спокойно мы можем получить это значение с сайта

![](_png/Pasted%20image%2020220918150000.png)


### **016 Регулярные выражения**

Где используются? Для работы со строками: удаление, замена части слов, ограничить ввод *определённых* знаков,  для поиска определённой буквы или сочетания букв в строке и так далее.

Регулярные выражения состоят из паттерна и флага. Записываются паттерны так: /паттерн/флаги.

Пример записи флагов выглядит так: всегда записываем сам паттерн и затем уже его флаги
```JS
new RegExp("pattern", "flags"); // редко используется
/pattern/flags; // используется часто
```

И тут мы в переменной *answer* через метод **search()** ищем *pattern* внутри ответа. Метод поиска вернёт нам индекс, где в слове находится паттерн. 
Тут 0 - A, 1 - n, ищем мы - n

![](../_png/Pasted%20image%2020220909181625.png)
![](../_png/Pasted%20image%2020220909181630.png)

При отсутствии нужного значения, получим "-1"

![](_png/Pasted%20image%2020220918080101.png)

Флаги: 
- i – пытаемся найти что-то вне зависимости от регистра
- g – пытаемся найти сразу несколько вхождений
- m – многострочный режим

И теперь мы можем попробовать вывести сразу несколько значений вне зависимости от регистра. Для этого мы должны будем поменять метод (search находит всегда только первое вхождение) на **match()**, который возвращает массив значений. А так же прописать нужные флаги (в любом порядке)

```JS
const answer = prompt("Имя?");
const pattern = /n/igm;
console.log(answer.match(pattern));
```
![](_png/Pasted%20image%2020220918080937.png)

Если внутрь регулярного выражения поместить точку, то это означает, что мы берём все значения из переменной. Конкретно сейчас мы воспользуемся методом **replace()**, который заменит все символы, которые мы в нём укажем

```JS
const pass = prompt("Пароль");
console.log(pass.replace(/./g, "*"));
```
![|600](_png/Pasted%20image%2020220918081823.png)

Так же мы можем экранировать точку и выделять только её. Делаем это мы, потому что точка - это зарезервированный спецсимвол

```JS
const pass = prompt("Пароль");

console.log(pass.replace(/\./g, "*"));
```
![](_png/Pasted%20image%2020220918082013.png)
![](_png/Pasted%20image%2020220918082020.png)

Кроме точки у нас есть ещё много разных зарезервированных спецсимволов: |, \, /, ^, &

И вот пример прямого использования строкового метода. Тут мы можем непосредственно и быстро изменять нужный нам текст. 

![| 600](_png/Pasted%20image%2020220918082508.png)

Дальше пойдут методы, которые непосредственно относятся к паттернам. Все прошлые относились к строкам. 
Метод **test()** вернёт булевое значение. Отвечает за поиск паттерна в слове

![| 600](_png/Pasted%20image%2020220918082929.png)

Так же перед нами может встать задача, которая будет заключаться в поиске значений определённого типа. Например, поиск чисел или слов. Для этого используются классы:
```JS
\d // - digits - числа
\w // - words - слова
\s // - spaces - пробелы
```

И вот пример поиска чисел:

![](_png/Pasted%20image%2020220918084319.png)
![](_png/Pasted%20image%2020220918084322.png)

Так же мы можем вписать заборчик из того паттерна, который нам нужно найти. 
Тут мы уже ищем слово, которое совпадает под наш паттерн

![](_png/Pasted%20image%2020220918084758.png)

Так же у нас имеются обратные классы, которые ищут НЕ_тип
```JS
\D // Ищет НЕ цифры
\W // НЕ буквы
\S // НЕ пробелы
```

Пример поиска НЕ цифр:

![](_png/Pasted%20image%2020220918085320.png)

==Дальше уже перейдём в наш проект==

Напомню, что мы получаем свойство ширины из компутированных стилей в браузере. Тут мы получаем строку '560px'
```JS
const sourceWidth = window.getComputedStyle(slidesWrapper).width;
```

Это первый вариант получения чисел из полученного массива. Тут мы складываем все полученные числа через reduce
```JS
const width = +sourceWidth.match(/\d/g).reduce((acc, val) => {  
    return acc += val;
});
```

А вот второй вариант. Тут мы все НЕ числа заменяем на пустую строку и переводим полученный результат в число
```JS
const width = +sourceWidth.replace(/\D/g, '');
```

### **017 Создаем калькулятор на сайте, часть 1**

Берём наш HTML-код:

```HTML
// Кнопки женщины и мужчины
<div class="calculating__choose" id="gender">  
    <div id="female" class="calculating__choose-item calculating__choose-item_active">Женщина</div>  
    <div id="male" class="calculating__choose-item">Мужчина</div>  
</div>

// Кнопки активности жизнедеятельности
// Через data-ratio мы задаём коэффициент для формулы в JS
<div class="calculating__subtitle">  
    Выберите вашу физическая активность  
</div>  
<div class="calculating__choose calculating__choose_big">  
    <div data-ratio="1.2" id="low" class="calculating__choose-item">Низкая активность </div>  
    <div data-ratio="1.375" id="small"  class="calculating__choose-item calculating__choose-item_active">Невысокая активность</div>  
    <div data-ratio="1.55" id="medium" class="calculating__choose-item">Умеренная активность</div>  
    <div data-ratio="1.725" id="high" class="calculating__choose-item">Высокая активность</div>  
</div>
```

И сама реализация нашего калькулятора:

```JS
const result = document.querySelector(".calculating__result span");  
// Задали значения по умолчанию, чтобы всё работало без клика по кнопкам  
let sex = "female",  
    weight, height, age,  
    ratio = 1.375;  
  
// Калькулятор результата ккал в день  
function calcTotal() {  
    if (!sex || !height || !weight || !age || !ratio) {  
        result.textContent = "----";  
        return; // досрочно прервёт функцию  
    }  
  
    if (sex === "female") {  
        result.textContent = Math.round((447.6 + (9.2 * weight) + (3.1 * height) - (4.3 * age)) * ratio);  
    } else {  
        result.textContent = Math.round((88.36 + (13.4 * weight) + (4.8 * height) - (5.7 * age)) * ratio);  
    }}  
  
// Активирует эффект нажатой кнопки  
function getStaticInformation(parentSelector, activeClass) {  
    const elements = document.querySelectorAll(`${parentSelector} div`);  
  
    elements.forEach(elem => {  
        elem.addEventListener("click", (e) => {  
            if (e.target.getAttribute("data-ratio")) {  
                ratio = +e.target.getAttribute("data-ratio"); // вытаскиваем значение активности из атрибута  
            } else {  
                sex = e.target.getAttribute("id");  
            }  
  
            elements.forEach(elem => {  
                elem.classList.remove(activeClass);  
            });  
  
            e.target.classList.add(activeClass);  
  
            calcTotal();  
        });  
    });  
}  
  
// Каждый раз при вводе данные будут записываться в нужный идентификатор  
function getDynamicInformation(selector) {  
    const input = document.querySelector(selector);  
  
    input.addEventListener("input", () => {  
        switch(input.getAttribute("id")) {  
            case "height":   
height = +input.value;  
                break;  
            case "weight":  
                weight = +input.value;  
                break;  
            case "age":  
                age = +input.value;  
                break;  
        }  
  
        calcTotal();  
    });  
}  
  
calcTotal();  
getStaticInformation("#gender", "calculating__choose-item_active");  
getStaticInformation(".calculating__choose_big", "calculating__choose-item_active");  
getDynamicInformation("#height");  
getDynamicInformation("#weight");  
getDynamicInformation("#age");
```
![](_png/Pasted%20image%2020220919194734.png)

### **018 Создаем калькулятор на сайте, часть 2**

Сначала сделаем проверку на вводимые значения в наши поля

![](_png/Pasted%20image%2020220926172736.png)
![](_png/Pasted%20image%2020220926172802.png)

При обращении к localStorage, мы сохраняем выбор пользователя в локальное хранилище, чтобы при перезагрузке сохранить эти значения

![](_png/Pasted%20image%2020220926173932.png)
![](_png/Pasted%20image%2020220926174111.png)

И немного перепишем задание наших переменных по умолчанию. Конкретно тут мы будем хранить наши значения в локальном хранилище и каждый раз при стирании их из локального хранилища (очистка кэша сайтов), у нас будут загружаться эти значения

![](_png/Pasted%20image%2020220926174854.png)
![](_png/Pasted%20image%2020220926174857.png)

И вот сама функция, которая будет реализовывать у нас сохранение положения активных классов при перезагрузке страницы

![](_png/Pasted%20image%2020220926190204.png)
![](_png/Pasted%20image%2020220926190207.png)

### **019 Геттеры и сеттеры (свойства объектов)**

- Свойства объектов делятся на две группы: свойства данные и свойства акцессоры. Свойства акцессоры так называются именно потому, что при вызове не ставятся круглые скобки – подразумевается, что мы обращаемся к свойству-методу

Реализуются свойства акцессоры через функции, которые начинаются с **get** и **set**. Такой функционал может напоминать шарп. Данные функции позволяют задать функционал отображения и задания свойства в объекте. Если написать гет, то через него мы получаем свойство. При использовании сета, мы задаём новое значение свойства. Если сет не написать, то и задать через эту функцию не получится.

Данные методы позволяют реализовать интерфейс задания и получения данных, а так же являются частью инкапсуляции (через них и получится инкапсулировать данные в объекте)
![](../_png/Pasted%20image%2020220909181644.png)
### **020 Инкапсуляция**

- Вот пример функции-конструктора, который создаёт нам персонажа. Тут мы легко можем поменять переменные внутри пользователя
![](../_png/Pasted%20image%2020220909181652.png)
- Однако если мы создадим переменную, то она станет недоступна для просмотра извне, но останется вполне себе изменяемой
![](../_png/Pasted%20image%2020220909181655.png)
- Дальше у нас идут собственные геттеры и сеттеры. Это методы, которые реализуют наш вывод данной переменной во внешнюю среду
![](../_png/Pasted%20image%2020220909181700.png)
- Так же мы можем переписать наш код на классы. Однако тут встаёт проблема, которая запрещает нам использовать простые переменные в конструкторе (let) и теперь опять наши переменные можно просто увидеть и изменить извне без геттеров и сеттеров
![](../_png/Pasted%20image%2020220909181705.png)
- По соглашению о наименовании переменных, если переменная начинается с нижнего подчёркивания (например, «_имя»), то эту переменную **нельзя** изменять
![](../_png/Pasted%20image%2020220909181710.png)
- И вот через сеттер age мы можем добавить нужное нам значение возвраста
![](../_png/Pasted%20image%2020220909181715.png)
- Однако у нас до сих пор есть возможность менять переменную, которую мы можем получить через геттеры и сеттеры. Есть возможность инкапсулировать значения полностью, но это уже экспериментальная технология

Так же можно инкапсулировать нормально значения в TypeScript
![](../_png/Pasted%20image%2020220909181720.png)
- Через решётку создаётся приватное поле класса. Оно создаётся вне конструктора, чтобы можно было обратиться к нему везде.

Так же он выполняет нужную нам функцию – не выходит за пределы класса. Его можно только просмотреть через метод (при обычном вызове будет undefined). Поменять извне – не получится
![](../_png/Pasted%20image%2020220909181725.png)
- И вот реализация геттера и сеттера для приватного поля класса
![](../_png/Pasted%20image%2020220909181729.png)
### **021 Прием модуль, как и зачем его использовать**

**Проблема**: иногда, при использовании сторонних библиотек, мы можем сталкиваться с проблемой, что мы создаём переменную, которая уже присутствует в библиотеке. Такие конфликты происходят в основе своей из-за того, что мы почти постоянно находимся в глобальной области видимости

Моделируем ситуацию:

```HTML
<script defer src="lib.js"></script>
<script defer src="script.js"></script>
```
![](_png/Pasted%20image%2020220926191856.png)
![](_png/Pasted%20image%2020220926191858.png)
Как итог, мы получаем вот такую вот ошибку:
![](_png/Pasted%20image%2020220926191827.png)

Один из способов решения проблемы: использовать IIFE функцию. Она создаёт локальную область видимости и исключает соударения с глобальной

```JS
(function() {  
    const a = 22;
}());
```

И тут нужно показать пример, который создаст для нас отдельный модуль, через который можно будет вызывать нужные для нас функции

```JS
const user = (function() {  
    const private = function () {
        console.log('I\'m a private');
    }
    
    return {
        sayHello: private
    };
}());

user.sayHello(); // I'm a private
```

### **022 Webpack. Собираем наш проект**

Все большие проекты на JS разбиваются на различные блоки кода и эти блоки кода убирают в отдельные файлы. Дробление проекта на отдельные модули позволяет нам нормально поддерживать проект и делить логику на составные части. 
Однако мы встречаемся с той проблемой, что браузеры не понимают деление проекта на модули и поэтому за помощью нам нужно обращаться к сборщикам модулей, которые создадут один файл из множества маленьких. И уже этот единственный файл браузер сможет обработать и смочь с нам работать 

Webpack - это сборщик модулей. Он позволяет нам собрать проект, состоящий из большого количества отдельных файлов с экспортами и импортами.

Gulp - это планировщик задач. Он выполняет определённые задачи при наших определённых действиях. Например, он может компилировать препроцессоры при сохранении кода

Вот пример импорта и экспорта с использованием CommonJS:

```JS
// lib.js - export

"use strict";

function myModule() {
    this.run = function() {
        console.log('run');
    };

    this.go = function() {
        console.log('go');
    };
}

module.exports = myModule; // exports
```
```JS
// script.js - import

const myModule = require('./lib'); // import

const myModuleInstance = new myModule();
myModuleInstance.run(); // run
```

Установка Webpack:

```bash
mkdir webpack-demo
cd webpack-demo
npm init
npm install webpack webpack-cli --save-dev

// Либо
npm install // установит все зависимости из package.json
```

Для запуска паковщика модулей:

```bash
npx webpack
```

Дальше нужно перейти к настройке конфигурации вебпака:
- mode - девелопментом пользуемся, когда нужно просто работать над сайтом, а ставим продакшн, когда выпускаем сайт на продакшен (там будут модули для оптимизации кода)
- entry - указываем точку входа в программу
- output - настраивает выходной файл
- watch - следит за файлами и пересобирает проект при каждом изменении
- devtool - определяет логику сохранения карты расположения кода (лучше чекнуть документацию)
- module - устанавливает дополнительные модули (например, babel)

![](_png/Pasted%20image%2020220927120216.png)
```JSON
'use strict';

let path = require('path');

module.exports = {
  mode: 'development', // or production
  entry: './js/script.js', // входная точка
  output: {
    filename: 'bundle.js', // название выходного файла
    path: __dirname + '/js' // путь до него
  },
  watch: true,
  devtool: "source-map",
  module: {}
};
```

И вот, что нам даёт карта. Мы можем видеть оригинальный несжатый код

![](_png/Pasted%20image%2020220927121943.png)

**И как с этим всем работать?**
Нужно весь код, который мы переносим в другой модуль, обернуть в функцию и эту функцию экспортнуть.
В принимаемом файле нужно через require получить и вызывать эту функцию.
Далее просто запускаем `npx webpack` с настройками выше и получаем готовый результат

```JS
function calculator() {  
    const result = document.querySelector(".calculating__result span");
    // ...
}  
  
module.exports = calculator;
```
Ну и в самом HTML подключаем выходной файл
```HTML
<script src="js/bundle.js"></script>
```
![](_png/Pasted%20image%2020220927134037.png)

При запуске вебпака, он начинает следить за проектом и работает на постоянной основе, поэтому для работы с терминалом, нам нужно запустить второй

![](_png/Pasted%20image%2020220927135226.png)

### **023 ES6 Modules**

==Импорт ES6== - это уже более современный способ импорта данных в файлы. Он обеспечивает более понятный синтаксис импорта, который представляет из себя конструкцию: `export` для экспорта элемента и `import from` для принятия экспорта из другого файла. 
Через `as` мы можем задать другое имя для импортируемого объекта (например, если имена очень длинные)
Если мы используем `export default`, то конкретно этот объект нам не нужно будет заключать в `{ }` при импорте
Ещё одна важная вещь - *модули **ES6** так же как и **CommonJS** нужно собирать сборщиком модулей **Webpack***

```JS
// lib.js - export

"use strict";

export const ex = 4;

const a = 1;
const b = 2;
const c = 3;

export { a, b, c};

export function go() {
    console.log('go');
}

export default class User {
    constructor(name) { console.log(name); }
}
```
```JS
// script.js - import

import User, { a as first, b, c, ex } from './lib'; // импорт 

new User('Andrew'); // Использование

console.log(first);
```

Через запись `* as all` мы импортируем всё под именем `all`. И теперь мы получили объект all, хранящий все экспорты из нужного нам файла

```JS
import * as all from './lib';

console.log(all.a); // 1
```

Интересная особенность дефолтного экспорта заключается в том, что под капотом он выглядит при импорте так: 

```JS
import {default as User} from './lib'; // ок - реализован так
import User from './lib'; // ок - выглядит так
```

И теперь мы можем подключить эти модули к браузеру. Можно воспользоваться вебпаком и сделать всё удобно, но так же мы можем обойтись и подключением, которое может сделать браузер.
Для нормальной работы нам нужно:
- `'./lib.js'` указать импорты с правильным наименованием браузера
- В HTML самым последним скриптом указать тот, который собирает все импорты
- Указать атрибут `type="module"` 

```JS
import User, { a as first, b, c, d} from './lib.js';
```
```HTML
<script type="module" src="js/lib.js"></script>
<script type="module" src="js/script.js"></script>
```

### **024 Собираем наш проект и фиксим баги**

В первую очередь, нам нужно дефолтно экспортировать наши обёртки и правильно их импортировать (в глобальной области видимости)

![](_png/Pasted%20image%2020220928082408.png)
![](_png/Pasted%20image%2020220928082941.png)

Дальше мы встречаемся с такой прописной истиной: все модули должны быть обособлены друг от друга. На нынешний момент времени нам нужно решить проблему с функцией, которая запускается в разных модулях и решить вопрос с переменными

Первым делом вынесем функции, которые нужны в других модулях и экспортнём их.
Дальше для всех функций создадим вызываемость с аргументами

```JS
export function closeModal(modalSelector) {  
    const modal = document.querySelector(modalSelector);  
    modal.classList.toggle("hide");  
    document.documentElement.style.overflow = "";
}  
  
export function openModal(modalSelector) {  
    const modal = document.querySelector(modalSelector);  
    modal.classList.toggle("hide");  
    document.documentElement.style.overflow = "hidden";  
    clearTimeout(modalTimer);  
}  
  
function modal(triggerSelector, modalSelector) {  
    const modal = document.querySelector(modalSelector),  
    modalBtns = document.querySelectorAll(triggerSelector);
    //...
}

export default modal;  
export {openModal, closeModal};
```
Импорт функций
```JS
//forms.js
import {openModal, closeModal} from './modal';
```

Мы встретимся с такой проблемой, что нам нужно добавить аргументы в функцию, которую не вызываем в данный момент времени (которая без **()**)

```JS
modalBtns.forEach(btn => {btn.addEventListener("click", openModal);}); // openModal не имеет ()
```
Для этого функцию с аргументами оборачиваем в колбэк
```JS
modalBtns.forEach(btn => {btn.addEventListener("click", () => openModal(modalSelector));});
```

И тут дальше хочется отметить, что не просто так учили мы методы строк. Мы можем модифицировать переменные и, если наш аргумент селектора немного не подходит, сделать это:

```JS
if (target && target.classList.contains('tabheader__item')) {
```
tabsSelector = `".tabheader__item"`
```JS
tabs(".tabheader__item", ".tabcontent", ".tabheader__items", "tabheader__item_active");
```
Слайсим переменную и пользуемся ей
```JS
if (target && target.classList.contains(tabsSelector.slice(1))) {
```

Сделаем подобие деструктурированной передачи информации для слайдеров как в slickslider 

![](_png/Pasted%20image%2020220928101732.png)

И тут мы реализовали передачу аргументов в функцию через деструктуризацию, которая происходит через **{}**. Это даёт нам возможность не передавать какие-либо аргументы (если они не нужны) или передавать их в хаотичном порядке 

```JS
// Реализация в slider.js
function slider({container, slide, nextArrow, prevArrow, totalCounter, currentCounter, wrapper, field}) {  
  
    const slides = document.querySelectorAll(slide),  
        slider = document.querySelector(container), // Добавляем сам слайдер, чтобы относительно него спозиционировать точки  
        prev = document.querySelector(prevArrow),  
        next = document.querySelector(nextArrow),  
        total = document.querySelector(totalCounter),  
        current = document.querySelector(currentCounter),  
        slidesWrapper = document.querySelector(wrapper),  
        slidesField = document.querySelector(field);
```
```JS
// Вызов из script.js
slider({  
    container: ".offer__slider",  
    totalCounter: "#total",  
    currentCounter: "#current",  
    prevArrow: ".offer__slider-prev",  
    nextArrow: ".offer__slider-next",  
    wrapper: ".offer__slider-wrapper",  
    field: ".offer__slider-inner",  
    slide: ".offer__slide"  
});
```


>[!Info] Модульный подход к разработке сайта предоставляет нам возможность 
> - переиспользовать код
> - более эффективно его модифицировать за счёт того, что теперь это не простыня, а отдельные блоки кода


### **025 Формируем портфолио на GitHub**

Гитхаб - это не только площадка для постинга репозиториев, но и отличная площадка для отображения своих скилов программиста. Тут мы можем в открытый доступ выкладывать наши приложения для того, чтобы работодатель мог увидеть наши скилы. 
В первую очередь внимание нужно обратить на оформление нашего гита. Нужно фото - желательно с улыбкой, имя и достаточное количество проектов (даже самых малых) + желательно много новых коммитов, которые покажут, что мы активно работаем
![](_png/Pasted%20image%2020220911171039.png)

### **026 Ошибки. Как избежать “поломки” своего кода**

Для обработки ошибок у нас существует стандартная конструкция `try-catch`. Внутрь него вкладываем код, который подозреваем на ошибку и в блоке `catch` пишем обработку нашей ошибки. Так же этот блок принимает в себя параметр ошибки. Из самой ошибки мы можем получить имя, сообщение и стек ошибки. 
Ну и блок `finally`, который необязателен, но позволяет выполнить логику, которая должна обязательно произойти

```JS
try { // проверяемый блок кода
    console.log('work');
    throw new Error('Some error');
} catch(e) { // Если ошибка
    console.log(e.name + ' - error name');
    console.log(e.message + ' - error message');
    console.log(e.stack + ' - error stack');
} finally { // блок кода, который выполняется в любом случае
    // Завершаем какую-то операцию
}

console.log('that\'s works!');
```
![](_png/Pasted%20image%2020220928175429.png)

Для чего, например, может использоваться такой подход в повседневной работе?
У нас есть функция, которая подключена сразу к двум документам. Эта функция из одного из них берёт информацию и обрабатывает её. Если на первой странице всё будет нормально, то на второй выйдет ошибка и код дальше работать не будет. 

![](_png/Pasted%20image%2020220928175610.png)
Уже с таким кодом ничего не будет падать и мы спокойно сможем работать одним скрипт-файлом на нескольких страницах
![](_png/Pasted%20image%2020220928182853.png)

### **027 (д) Создание своих ошибок**

Представим, что нам нужно добавить на страницу несколько блоков с определёнными элементами по тегу и атрибуту
В результате выполнения этого кода у нас будет один элемент без id

```JS
'use strict';

// Содержит будущие элементы
const data = [
    {
        id: 'box',
        tag: 'div'
    },
    {
        id: '',
        tag: 'nav'
    },
    {
        id: 'circle',
        tag: 'span'
    }
]

// Выводит эти элементы на страницу
data.forEach(blockObj => {
	// Создаст элемент с определённым тегом
    const block = document.createElement(blockObj.tag);
    // Добавит ему определённый атрибут
    block.setAttribute('id', blockObj.id);
    // Добавит элемент на страницу
    document.body.append(block);
})
```
![](_png/Pasted%20image%2020220928185834.png)

Однако если мы воспользуемся оператором `throw`, то мы сможем предотвратить ошибку. Этот оператор выдаёт в консоль какое-то сообщение (строку `'string'` или созданную нами ошибку `new Error()`) и останавливает выполнение дальнейшего кода
По итогу мы получим только один элемент

```JS
data.forEach((blockObj, i) => {
    const block = document.createElement(blockObj.tag);

    if (!blockObj.id) throw new Error(`Под индексом ${i} нет данных об id`); // !

    block.setAttribute('id', blockObj.id);
    document.body.append(block);
})
```
![](_png/Pasted%20image%2020220928185636.png)
![](_png/Pasted%20image%2020220928190905.png)

Так же есть SyntaxError, TypeError, ReferenceError и другие ошибки, которые можно выделить под определённые предполагаемые ситуации
```JS
const err = new ReferenceError('Ref Err');
console.log(err.name, err.message, err.stack);
```

И вот пример самих сущностей, которые мы получаем при ошибке

```JS
try {
    data.forEach((blockObj, i) => {
        const block = document.createElement(blockObj.tag);
        if (!blockObj.id) throw new SyntaxError(`Под индексом ${i} нет данных об id`);
        block.setAttribute('id', blockObj.id);
        document.body.append(block);
    })
} catch (e) {
    console.error(e.name);
    console.log(e.message);
    console.log(e.stack);
}
```
![](_png/Pasted%20image%2020220928192423.png)

Так же мы можем дописать логику для непредвиденных ошибок, которые выходят за рамки того, что можно предугадать. Для этого через условие можно прописать в блоке `catch`, какую ошибку мы ожидаем получить, а какая ошибка уже говорит о критических недоработках кода

```JS
'use strict';

const data = [
    {
        id: 'box',
        tag: 'div'
    },
    {
        id: 'had', // нормально
        tag: 'nav'
    },
    {
        id: 'circle',
        tag: '' // другая ошибка
    }
]

try {
    data.forEach((blockObj, i) => {
        const block = document.createElement(blockObj.tag);
        if (!blockObj.id) throw new SyntaxError(`Под индексом ${i} нет данных об id`);
        block.setAttribute('id', blockObj.id);
        document.body.append(block);
    })
} catch (e) {
    if (e.name === 'SyntaxError') { // если моя ошибка
        console.error(e.message); // То вывести сообщение ошибки
    } else throw e; // если ошибка не моя (непредвиденная), то пропустить ошибку
}
```
![](_png/Pasted%20image%2020220928192748.png)

### **028 Как превратить код ES6+ в старый формат ES5. Babel, Core.js и полифиллы**

==Трансплиттер== - это инструмент, который переводит код нового формата в более старый формат, который, например, понятен старым браузерам
==Полифилл== - это участки старого кода, которые эмулируют поведение современных стандартов кода

Использовать в своей работе мы будем ==babel==. Его уже в свою очередь нужно будет подключить к сборщику модулей

```shell
// Установка babel
npm install --save-dev @babel/core @babel/cli @babel/preset-env

// для установки всех полифилов в проект (даже неиспользуемых)
npm install --save @babel/polyfill 

// для работы конфига
npm install --save-dev babel-loader 

// Библиотека, которая оставляет только нужные полифиллы в проекте
npm install --save-dev corejs
```

Это настройка для `package.json,` которая скажет ==babel== для каких браузерв нужно подстраиваться

![](_png/Pasted%20image%2020220929174605.png)
![](_png/Pasted%20image%2020220929174521.png)

Это настройки для `webpack.config.js`, которые нужны для ==babel==

```JS
'use strict';

let path = require('path');

module.exports = {
  mode: 'production',
  entry: './js/script.js',
  output: {
    filename: 'bundle.js',
    path: __dirname + '/js'
  },
  watch: true,
  
  devtool: "source-map",

  // Настройка модулей в webpack
  module: {
  // Правила для модулей
    rules: [
      {
        test: /\.m?js$/,
        // Исключаем эти файлы
        exclude: /(node_modules|bower_components)/,
        // работаем с этими модулями
        use: {
	      // Модуль установили чуть выше 
          loader: 'babel-loader',
          // Настройки для этого лоадера
          options: {
	        // Пресеты есть на сайте babel во вкладке Presets
            presets: [['@babel/preset-env', {
                // Вывод полной информации при дебаге
                debug: true,
                // Версия библиотеки для полифилов (corejs)
                corejs: 3,
                // Выбирает только используемые полифиллы
                useBuiltIns: "usage"
            }]]
          }
        }
      }
    ]
  }
};
```

Дальше для активации ==Babel== нам нужно запустить вебпак через `npx webpack`. После компиляции файл может весить до двух раз больше :(

Так же нужно упомянуть, что иногда некоторые полифиллы могут не сработать и из-за этого может полететь функционал на странице. Для исправления ситуации, нужно зайти в гугл и ввести: <функция> polyfill js
Например, на том же npm можно найти полифилл для промиса

![](_png/Pasted%20image%2020220929182223.png)
```shell
// Установка полифилла
npm install es6-promise
```
```JS
// Активация полифилла в проекте
require('es6-promise').polyfill();
```
![](_png/Pasted%20image%2020220929182610.png)

Так же есть и другой вариант импорта полифиллов. Так же если мы пропишем просто `import 'имя_пакета'`, то он импортнётся из папки модулей 

```shell
npm i nodelist-foreach-polyfill
```
![](_png/Pasted%20image%2020220929182918.png)

Так же такой вариант импорта работает и для других отдельных полноценных плагинов, которые мы можем просто установить через npm и так импортнуть в проект
**И лучше плагины подключать именно так, так как это всё скомпилируется в один JS файл без кучи других отдельных с разными зависимостями**

```JS
import 'slick-slider';
```

### **029 Современные библиотеки и фрэймворки**

**Фреймворки и библиотеки**: #Angular #React #Vue 
==Библиотека== - это просто готовые участки кода, которые можно как использовать для быстрого написания какой-то логики, так и не использовать
Библиотека зачастую направлена на решение одной задачи

==Фреймворк== - это уже определённая структура, которая диктует правила, как нужно писать код программисту и заставляет его их придерживаться
Фреймворки позволяют нам создать полноценное приложение прямо из того функционала, который в нём присутствует

Фреймворки позволяют нам создавать #SPA (Single Page Applications), которые, в свою очередь, представляют из себя приложения в браузере. Эти приложения позволяют работать с сайтом как с программой, которая располагается на удалённом компьютере. При этом при переходе в другие вкладки внутри приложения - *страница не перезагружается*.

Что нужно знать, прежде чем изучать фреймворки:
- #Angular
	- #TypeScript 
	- node.js
	- #Webpack
	- MVC pattern
	- Сам фреймворк (документация)
- #React
	- node.js
	- JSX (препроцессор)
	- Babel (компилятор JSX)
	- #Webpack
	- Сам фреймворк (документация)
- #Vue
	- node.js
	- #Webpack
	- Сам фреймворк (документация)

Так же стоит упомянуть о ==jQuery==. Это библиотека, которая используется в большом количестве старых сайтов для создания интерактива. Её просто стоит знать, чтобы понимать, с чем может прийтись работать. 

### **030 Библиотека Jquery**




















### **031 Функции-генераторы**

Функция-генератор в разные моменты времени выдаёт разные результаты. Первым делом нам нужно присвоить функцию в новую переменную и через эту переменную вызвать методы, которые контролируют поведение функции-генератора. Одним из методов, который вызывают следующее значение является `next()`. Так как этот метод возвращает объект, то мы сразу можем обратиться к нужному нам свойству.

```JS
function* generator() {
    yield 'S'; // Первый вызов
    yield 'b'; // Второй вызов
    yield 'c'; // Третий вызов
    yield 'd'; // Четвёртый вызов
}

const str = generator();

console.log(str.next());
console.log(str.next().value); // сразу получаем значение
console.log(str.next());
console.log(str.next());
console.log(str.next());
```
```shell
{ value: 'S', done: false }
b
{ value: 'c', done: false }
{ value: 'd', done: false }
{ value: undefined, done: true }
```

И вот пример функции-генератора, которая будет при каждом вызове возвращать новое значение

```JS
function* count(n) {
    for (let i = 0; i < n; i++) {
        yield i;        
    }
}

const counter = count(7);

console.log(counter.next().value); // 0
console.log(counter.next().value); // 1
console.log(counter.next().value); // 2
```

Так же конструкция for-of позволяет нам максимальное количество раз перебрать конструкцию функции-генератора

```JS
function* count(n) {
    for (let i = 0; i < n; i++) {
        yield i;        
    }
}

for (const k of count(7)) {
    console.log(k);
}
```

### **032 JS анимации, requestAnimationFrame**


### **033 () Web Animations API**



### **034 Event loop, подробная работа асинхронных и синхронных операций**



### **035 Макро и микрозадачи**



### **036 Работаем с готовым кодом**

