### **015 Контекст вызова. This**

- Понимать контекст вызова с «this», стоит как присваивание переменной к определённому контексту (функции). То есть любая переменная, которую мы создаём – принадлежит всей области видимости. Если мы создаём переменную с «this», то она будет принадлежать только данной области

**_Так же тут стоит отметить, что при обычном вызове функции с_** **_this_** **_внутри, у нас будет выходить глобальная переменная_** **_Window_****_. Если мы добавим “_****_use_** **_strict_****_”, то получим_** **_undefined_**
![](../_png/Pasted%20image%2020220909175837.png)
![](../_png/Pasted%20image%2020220909175842.png)
- И тут представлен пример, когда мы используем «**this**» и избегаем его. Благодаря «**замыканию функции**» в обычной ситуации (первый скрин) у нас переменные ищутся сначала внутри самой функции, потом поиск заходит в функцию родителя.

На втором изображении уже используется вызов переменной через «**this**» и функция ищет переменную **_только_** внутри себя и дальше не выходит. Поэтому и возвращается **undefined**
![](../_png/Pasted%20image%2020220909175848.png)
![](../_png/Pasted%20image%2020220909175853.png)
- **_Контекст вызова у методов объекта – это сам объект_**
![](../_png/Pasted%20image%2020220909175859.png)
- Уже в данном примере контекст вызова (объект) теряется, так как внутри метода просто вызывается функция
![](../_png/Pasted%20image%2020220909175907.png)
- **_This_** **_в конструкторах и классах – это новый экземпляр объекта_**

То есть при создании свойства в конструкторе через «**this**», это значение будет присваиваться только созданным экземплярам через данный конструктор
![](../_png/Pasted%20image%2020220909175912.png)
- **_Ручная_** **_привязка_** **_this_**: call , apply, bind

Так же мы можем вызывать функцию и подвязать ей контекст вызова через методы **call** и **apply** (оба метода выполняют одно и то же, но по-разному передают аргументы в функцию)

Так же можно сделать много вариаций одной и той же функции, используя контекст вызова и функцию **bind****.** Баинд принимает в себя значение «**this**» и возвращает в переменную новую функцию, где **this** заменён на данный аргумент метода
![](../_png/Pasted%20image%2020220909175922.png)
![](../_png/Pasted%20image%2020220909175927.png)
- И когда мы используем конструкцию с function() в ивенте мы так же можем пользоваться и «this», так как он будет вызывать конкретно наш нажатый объект
![](../_png/Pasted%20image%2020220909175933.png)
![](../_png/Pasted%20image%2020220909175937.png)
- И работать с этим объектом мы так же можем
![](../_png/Pasted%20image%2020220909175942.png)
![](../_png/Pasted%20image%2020220909175949.png)
- Как помним из примера выше – функция внутри функции имеет свой контекст вызова и поэтому в объекте такая вложенная функция вернёт **undefined**. Но отличительной особенностью **стрелочных функций** является то, что у них **нет своего контекста вызова**. Контекст вызова они наследуют от родителя и поэтому код, приведённый ниже, будет работать
![](../_png/Pasted%20image%2020220909180012.png)
- Ну и так как нет собственного контекста вызова у стрелочной функции, то берём пример чуть выше с function() и переделываем его на стрелочную функцию. Работать уже такой ивент не будет, так как контекст, опять же, берётся у родителя
![](../_png/Pasted%20image%2020220909180018.png)
![](../_png/Pasted%20image%2020220909180022.png)
- И чтобы заменить «this» в таких функциях, используют таргет ивента
![](../_png/Pasted%20image%2020220909180027.png)
![кнопка|400](../_png/Pasted%20image%2020220909180044.png)