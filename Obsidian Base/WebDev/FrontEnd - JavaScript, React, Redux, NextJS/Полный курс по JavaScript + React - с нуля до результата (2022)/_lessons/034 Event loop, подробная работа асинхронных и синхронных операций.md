
Ниже представлено сочетание синхронных и асинхронных функций:

```JS
console.log(1);  
  
setTimeout(() => {  
    console.log('timeout_1');  
}, 2000)  
  
setTimeout(() => {  
    console.log('timeout_2');  
}, 4000)  
  
console.log(2);

// 1
// 2
// timeout_1
// timeout_2
```

Во втором случае команды оставим всё те же, но сеттаймауты сделаем по одинаковому времени. Вывод будет идентичен первому варианту, так как первый сеттаймаут в коде запустился чуть раньше второго 

```JS
console.log(1);  
  
setTimeout(() => {  
    console.log('timeout_1');  
}, 4000)  
  
setTimeout(() => {  
    console.log('timeout_2');  
}, 4000)  
  
console.log(2);

// 1
// 2
// timeout_1
// timeout_2
```

==Call Stack== - это операции, которые выполняются прямо сейчас на данный момент
==Web Apis== - это хранилище в браузере для хранения промежуточных данных
==Callback Queue== - это очередь задач. Все операции не могут выполняться параллельно, они встают в очередь друг за другом, чтобы нормально выполниться.

**Что тут происходит?** Все наши таймауты, ивенты на кнопках попадают в Web Apis и ждут своего выполнения (таймауты - конца таймера, кнопки - срабатывания). Дальше абсолютно все задачи попадают в порядке очереди в Callback Queue (). После того, как задача подошла к выходу из очереди, она попадает в Call Stack, где и выполняется.  

![](_png/Pasted%20image%2020221022174717.png)

Все события (клики, коллбэки, таймауты, промисы), которые мы вызовем, становятся в очередь и не могут выполниться одновременно, так как JS - это однопоточный язык.






