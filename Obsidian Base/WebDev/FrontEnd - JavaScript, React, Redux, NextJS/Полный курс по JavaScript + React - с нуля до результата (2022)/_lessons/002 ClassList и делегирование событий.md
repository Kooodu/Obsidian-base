### 002 ClassList и делегирование событий

- С помощью приведённых ниже методов обычно создают изменения в классах для применения новых стилей на объекте и проявления элементов. Конкретно данный гамбургер был сделан через использование метода **toggle()**
![](../_png/Pasted%20image%2020220909163935.png)
![](../_png/Pasted%20image%2020220909163942.png)

- Изначальный код на странице:
![](../_png/Pasted%20image%2020220909163948.png)
- Сначала мы получим псевдомассив со всеми нашими кнопками со страницы. Через **classList****.****length** можно получить количество классов на объекте. Через **classList****.****item****(индекс)** можно получить наименование класса объекта под определённым индексом
![](../_png/Pasted%20image%2020220909163956.png)
-
![](../_png/Pasted%20image%2020220909164000.png)
- Метод classList.togle() крайне полезен и юзабелен. Данный метод добавит класс, если он отсутствует на объекте и удалит, если уже присуствует. Он может заменить целый блок с условной конструкцией, так как в его нутрянке и есть подобная проверка
![](../_png/Pasted%20image%2020220909164025.png)
- Метод contains() проверяет наличие класса в выбранном объекте. С помощью него можно прописать условие, которое будет срабатывать при наличии определённого класса
![](../_png/Pasted%20image%2020220909164030.png)
- И вот пример добавления/удаления класса через условную конструкцию и через toggle()
![](../_png/Pasted%20image%2020220909164034.png)
- className – устаревший способ изменения классов. Он хранит в себе классы как строчку и использовать его неудобно
![](../_png/Pasted%20image%2020220909164038.png)
- И сейчас нужно поговорить про добавление события для нескольких элементов на странице. Дело в том, что если нам нужно одинаковое событие на странице для нескольких элементов, то мы могли бы добавить addEventListener через forEach на все такие элементы. Однако такой подход немного устарел и имеет свои минусы в виде того, что если элемент отсутствовал на странице, то тот при появлении не будет иметь данный ивент.

Чтобы упростить задачу, нам нужно применить данный ивент на сам враппер, который в себе содержит эти элементы
![](../_png/Pasted%20image%2020220909164046.png)
- Далее хорошо бы было узнать название элемента в самой HTML-структуре через дир - ивент.таргет (название элемента можно увидеть при нажатии на него на странице)
![](../_png/Pasted%20image%2020220909164050.png)
![](../_png/Pasted%20image%2020220909164055.png)
- И теперь при нажатии любой кнопки внутри враппера (даже если кнопка появилась позже в нём) у нас будет срабатывать ивент. При нажатии на сам враппер, ничего происходить не будет

Такой способ называется делегированием
![](../_png/Pasted%20image%2020220909164100.png)
![](../_png/Pasted%20image%2020220909164105.png)
- Так же можно присвоить ивенты только тем кнопкам, которые имеют определённый класс (тут – blue)
![](../_png/Pasted%20image%2020220909164111.png)
![](../_png/Pasted%20image%2020220909164115.png)
- И вот простой пример. Созданная кнопка после объявления ивента, уже имеет данный ивент, потому что он делегируется дочерним элементам
![](../_png/Pasted%20image%2020220909164120.png)
![](../_png/Pasted%20image%2020220909164125.png)
- При таком коде новый ивент не будет добавлен на кнопку и она будет грустить одна такая☹
![](../_png/Pasted%20image%2020220909164130.png)
- И так же есть продвинутая техника обращения к элементу через метод matches(), внутрь которого мы положим наименование элемента и селектор класса
![](../_png/Pasted%20image%2020220909164134.png)
![](../_png/Pasted%20image%2020220909164139.png)