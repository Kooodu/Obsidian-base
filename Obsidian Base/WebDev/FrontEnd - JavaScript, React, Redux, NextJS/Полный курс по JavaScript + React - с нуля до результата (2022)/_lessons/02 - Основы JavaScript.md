## **02 - Основы JavaScript**

### **001 Что такое JS и как его подключить к странице**

- Подключается скрипт к сайту таким образом. Больше никаких тегов внутри прописывать не надо. Если присутствует тег «type», то его нужно будет убрать. Скрипт мы помещаем в самый конец, так как он работает только с существующей вёрсткой на сайте и так же может долго загружаться, что застопорит загрузку сайта
![](../_png/Pasted%20image%2020220908194327.png)
### **003 Переменные и строгий режим**

- Объявлять переменные через var – нельзя. В современных структурах она может принести очень много вреда. Дело в том, что такая переменная не учитывает своё положение в коде и видна во всех областях видимости. Приведённый ниже код сработает и вернёт undefined:
![](../_png/Pasted%20image%2020220908194332.png)
- Данная директива позволяет писать код только по современному защищённому стандарту, исключая старый
![](../_png/Pasted%20image%2020220908194337.png)![](../_png/Pasted%20image%2020220908194345.png)
- Стиль написания кода JS:
![](../_png/Pasted%20image%2020220908194351.png)
### **004 (д) Правила и типы названия переменных**

-
![](../_png/Pasted%20image%2020220908194439.png)![](../_png/Pasted%20image%2020220908194444.png)
- Стиль наименования переменной «snake_case» или написание в камеле, но с нижнего подчёркивания используется для написания константы (которую точно не стоит менять в коде)
![](../_png/Pasted%20image%2020220908194452.png)
### **005 Классификация типов данных в JavaScript**

- В первом столбце – примитивные типы данных, во втором – комплексные (могут хранить в себе разные типы данных)
![](../_png/Pasted%20image%2020220908194502.png)
-
![](../_png/Pasted%20image%2020220908194507.png)![](../_png/Pasted%20image%2020220908194510.png)
- Объект представляет из себя набор свойств (ключ + значение). Массив – это частый случай от типа данных объект (в качестве ключа используется индекс). Поэтому работа с массивом и объектом достаточно похожа
![](../_png/Pasted%20image%2020220908194516.png)
### **006 (д) Разница между объектами и массивами и неочевидные синтаксические возможности**

- Разница между объектом и массивом заключается в разных прототипах (которые определяют функционал)
![](../_png/Pasted%20image%2020220908194523.png)
### **007 Простое общение с пользователем**

- Самый простой способ общения с пользователем – это alert(), confirm() и prompt(). Последняя функция всегда возвращает строковое значение от пользователя
![](../_png/Pasted%20image%2020220908194528.png)
- Так же можно вернуть и число (динамическая типизация в число)
![](../_png/Pasted%20image%2020220908194533.png)
- Так же можно сделать серию вызовов диалоговых окон и предоставить их пользователю.

Document.write()- перезатирает страницу и выводит нашу переменную
![](../_png/Pasted%20image%2020220908194540.png)![](../_png/Pasted%20image%2020220908194544.png)
### **008 Интерполяция (ES6)**

-
![](../_png/Pasted%20image%2020220908194551.png)![](../_png/Pasted%20image%2020220908194555.png)
### **009 Операторы в JS**

-
![](../_png/Pasted%20image%2020220908194603.png)![](../_png/Pasted%20image%2020220908194607.png)
### **010 Учимся работать с системой контроля версий Git и с сервисом GitHub**

- В современном мире встала такая проблема, что нужно сохранять огромное количество вариантов кода. Если нам нужно добавить фичу, а она может крашнуть весь проект, нам нужно иметь возможность откатиться обратно. Если сохранять каждую папку отдельно, то это может оказаться накладно как по месту, так и по ориентированию между папками
![](../_png/Pasted%20image%2020220908194616.png)
- Дальше стоит чекнуть курс по гиту, который ниже или чекнуть данный сайт:
![](../_png/Pasted%20image%2020220908194622.png)
### **011 Как работать с GitHub с разных компьютеров, gitignore и Git Kraken**

- Всегда перед началом работы с проектом пишем: git pull. Может оказаться так, что проект на гите имеет более новую версию, чем сейчас имеется на компьютере, поэтому будет хорошей практикой его себе загрузить

- Так же стоит игнорировать рабочие инструменты (не пушить те же sass файлы)
![](../_png/Pasted%20image%2020220908194630.png)
### **012 (д) Сетевые протоколы. Подключение компьютера к аккаунту Github через SSH**

- Существует множество протоколов для передачи данных по сети. Для подключения к нашему гитхабу используется HTTPS (логин-пароль). Но так же может использоваться и SSH (ключ локальный на компьютере сравнивается с открытым в проекте и даётся доступ к проекту)
![](../_png/Pasted%20image%2020220908194636.png)![](../_png/Pasted%20image%2020220908194639.png)
- Сравнение HTTPS и SSH

[https://ourtechroom.com/tech/https-vs-ssh-in-git/](https://ourtechroom.com/tech/https-vs-ssh-in-git/)

- Подключение к гитхабу через SSH

[https://docs.github.com/en/authentication/connecting-to-github-with-ssh](https://docs.github.com/en/authentication/connecting-to-github-with-ssh)

### **013 Практика, ч.1. Начинаем создавать приложение**

-
![](../_png/Pasted%20image%2020220908194649.png)
-
![](../_png/Pasted%20image%2020220908194654.png)![](../_png/Pasted%20image%2020220908194657.png)
### **014 Условия**

-
![](../_png/Pasted%20image%2020220908194703.png)![](../_png/Pasted%20image%2020220908194707.png)
### **015 (д) Логические операторы**

-
![](../_png/Pasted%20image%2020220908194713.png)![](../_png/Pasted%20image%2020220908194717.png)
### **016 Циклы**

[https://learn.javascript.ru/while-for](https://learn.javascript.ru/while-for)
![](../_png/Pasted%20image%2020220908194725.png)
###   **017 (д) Цикл в цикле и метки**

-
![](../_png/Pasted%20image%2020220908194736.png)
- **Метки.** Можно отправить цикл выполнять другой цикл, который является его частью (тут – если к === 2, то будет выполняться самый первый цикл). Continue и break работают похожим образом как и в других языках
![](../_png/Pasted%20image%2020220908194742.png)![](../_png/Pasted%20image%2020220908194745.png)
### **018 Практика, ч2. Применяем условия и циклы**

- Тут стоит отметить, что если пользователь нажал на «отмену» при вводе значения в prompt, то у нам вернётся null
![](../_png/Pasted%20image%2020220908194754.png)
```JavaScript
'use strict';  
  
let numberOfFilms = +prompt('Сколько фильмов вы посмотрели?')  
  
  
const personalMovieDB = {    count: numberOfFilms,    movies: {},    actors: {},    genres: [],    private: false,  
}  
  
	while (true){    
	if (numberOfFilms >= 0) {    
	    if(personalMovieDB.count < 10){   
	             alert('Просмотрено довольно мало фильмов') 
	                        break 
	}else if(personalMovieDB.count >= 10 && personalMovieDB.count <= 30){    
	        alert('Вы классический зритель')   
	                 break     
   }else if(personalMovieDB.count > 30){     
          alert('Вы киноман')
          break
          }
	} else {
		alert('Вы ввели не число или неверное число')    
	}  
}  
  
let name, mark  
  
cycle: for (let i = 0; i < 5;){  
	name = prompt('Один из последних просмотренных фильмов?')  
	mark = prompt('На сколько оцените его по десятибальной шкале?', '5')  
	if (name != null && name != '' && name.length < 50 && mark != '' && mark != null && mark >= 0 && mark <= 10) {       
	personalMovieDB.movies[name] = mark   
	i++; 
} else {     
	alert('Одно из введённых вами значений неверно')        
	continue cycle  
	}  
}
```
- И стоит отметить, что если мы тут оставим «+», то при отмене ввода значения пользователем, данный оператор переведёт значение «null» в «0»
![](../_png/Pasted%20image%2020220908195153.png)
### **019 Функции, стрелочные ф-ции (ES6)**

-
![](../_png/Pasted%20image%2020220908195342.png)
### **020 (д) Еще раз про аргументы функций**

-
![](../_png/Pasted%20image%2020220908195347.png)
### **021 (д) Про важность return**

- return в первую очередь нам нужен для того, чтобы вернуть результат из функции (например в переменную, которая вызвала эту функцию)
![](../_png/Pasted%20image%2020220908195351.png)
- Так же можно вернуть значение из цикла (и цикл сразу же завершится)
![](../_png/Pasted%20image%2020220908195356.png)
- Но так же важно сказать, что функция (когда она не имеет return) всегда возвращает undefined. И console.log() тоже всегда возвращает undefined
![](../_png/Pasted%20image%2020220908195401.png)
### **022 Методы и свойства строк и чисел**

- Основные методы строк и чисел
![](../_png/Pasted%20image%2020220908195406.png)
### **023 Практика , ч3. Используем функции**

- Тут хочется показать неочевидное условие. Нам нужно, чтобы пользователь в любом случае ввёл число. Что
![](../_png/Pasted%20image%2020220908195418.png)
### **024 (д) Метод trim()**

- Метод trim() стоит использовать почти везде, где есть ввод данных пользователем. Это позволяет избегать пустых строк и огромного количества пробелов, так как данный метод убирает лишние пробелы из строки
![](../_png/Pasted%20image%2020220908195423.png)
### **025 Callback- функции**

- Сюда мы передаём анонимную функцию (исчезнет после использования)
![](../_png/Pasted%20image%2020220908195428.png)
- А сюда мы передаём стрелочную
![](../_png/Pasted%20image%2020220908195432.png)
### **026 Объекты, деструктуризация объектов (ES6)**

- Тут мы получаем ключ и его значение из объекта, а так же проходимся по объектам внутри объекта
![](../_png/Pasted%20image%2020220908195439.png)
- Это пример части деструктуризации объекта
![](../_png/Pasted%20image%2020220908195450.png)

### **027 Массивы и псевдомассивы**
-
![](../_png/Pasted%20image%2020220908195510.png)
### **029 Передача по ссылке или по значению, Spread оператор (ES6-ES9)**

- Копирование объекта через приравнивание копирует только ссылку из одной в другую переменную. Поэтому нужно копировать объекты, чтобы иметь возможность работать с ними по отдельности

### **030 Основы ООП, прототипно-ориентированное наследование**

- Тут описывается цепочка наследования и особенности ООП в JS
![](../_png/Pasted%20image%2020220908195526.png)
-
![](../_png/Pasted%20image%2020220908195532.png)
### **031 Практика , ч4. Используем объекты**

- Очень важный мем! Чтобы проверить, что наш пользователь ввёл число, нужно проверять не само равенство введённого значения к типу (count === Number), а тип введённого числа к типам, которые выдаёт typeof (пример на рисунке)
![](../_png/Pasted%20image%2020220908195538.png)
-
![](../_png/Pasted%20image%2020220908195622.png)
- Так же есть ещё один интересный способ, как можно принять значения от пользователя в виде массива. Метод split(‘, ’) позволяет указать разделитель для строчки и по этому разделителю разложить значения в массив.

Тут впринципе показана реализация, когда мы приводим сначала строку к нижнему регистру (потому что сортировка, которая идёт дальше, будет производиться по юникоду, а в юнкоде сначала идут заглавные буквы)
![](../_png/Pasted%20image%2020220908195630.png)
### **032 Отлавливаем ошибки в своем коде при помощи консоли разработчика. Breakpoints**

- На данной вкладке нашего инструмента разработчика находится инструмент просмотра сурсов и дебаггинга
![](../_png/Pasted%20image%2020220908195637.png)
- На номерах строк мы ставим маркеры. Справа находятся кнопки стартаа программы, перехода в другую функцию (вызванную), входа внутрь функции, выхода из функции (она выполнится) и выполнения одного шага. Так же есть снятие маркера и паузы на ошибках
![](../_png/Pasted%20image%2020220908195642.png)
### **033 Динамическая типизация в JS**

-
![](../_png/Pasted%20image%2020220908195648.png)
- Способы перевода в другие типы данных
![](../_png/Pasted%20image%2020220908195658.png)
### **034 Замыкание и лексическое окружение**

- В данном примере кода мы доходим до такого понятия как «лексическое окружение» или «область видимости». Любая переменная – это свойство объекта лексического окружения. И мы имеем внутреннее лексическое окружение (например, область той же функции) и внешнее (всё, что находится на глобальном уровне).

Тут стоит пояснить, то бОльший приоритет имеют свойства внутренней области, но так же внутреннее окружение может брать значения из внешнего. Так же те же функции берут самое последнее значение переменной, которая может изменяться далеко дальше по коду
![](../_png/Pasted%20image%2020220908195707.png)![](../_png/Pasted%20image%2020220908195711.png)
- Тут функция так же будет брать только актуальное значение переменной (6, а затем уже 8). Так же тут же отметим, что при каждом вызове функции, у нас создаётся разное лексическое окружение, что говорит нам о том, что в функции в разных местах кода спокойно могут находиться разные значения переменных. Но так же эти пространства удаляются, когда они выполняются и полностью исчезают из выполненного программного кода
![](../_png/Pasted%20image%2020220908195718.png)
- Тут так же можно увидеть, что при вызове функции у нас создаётся определённая область видимости, где сохраняются ссылки на переменные, которые были им доступны на время создания этих функций (создание == вызов)
![](../_png/Pasted%20image%2020220908195722.png)
### **035 Задачи с собеседований на понимание основ**

-
![](../_png/Pasted%20image%2020220908195728.png)![](../_png/Pasted%20image%2020220908195735.png)
### **036 Получение элементов со страницы**

- На нашей странице располагается бокс. Через первую строчку кода мы получили элемент по его id и выводим его в консоль разработчика
![](../_png/Pasted%20image%2020220908195743.png)
![](../_png/Pasted%20image%2020220908195753.png)
- Здесь мы получаем уже не один элемент, а псевдомассив (это массив, который не имеет методов высшего порядка массивов)
![](../_png/Pasted%20image%2020220908195849.png)![](../_png/Pasted%20image%2020220908195853.png)
- Но мы так же можем обратиться к определённому элементу этого псевдомассива и получить нужное нам значение через массивное указание индекса элемента

Тут стоит отметить, что даже если у нас на странице будет всего один элемент, то на выходе мы так же получим HTMLCollection (псевдомассив), но из одного элемента
![](../_png/Pasted%20image%2020220908195900.png)![](../_png/Pasted%20image%2020220908195903.png)
![](../_png/Pasted%20image%2020220908195909.png)
- Тут уже элементы вызываем по имени класса
![](../_png/Pasted%20image%2020220908195916.png)
![](../_png/Pasted%20image%2020220908195920.png)
- И далее тут представлены уже современные способы вызова элементов по селекторам CSS. То есть тут уже для указания элемента нам нужно будет прописывать «.», «#», «:», «*» и так далее. Такой способ рекомендуется к использованию и является более правильным. Так же он имеет один из методов массива (только forEach())
![](../_png/Pasted%20image%2020220908195925.png)
![](../_png/Pasted%20image%2020220908195931.png)
### **037 Действия с элементами на странице**

- Представленные способы добавления стилизации на страницу, позволяют добавить её в инлайновом виде (т.е. они вставляются в тег и имеют наивысший приоритет отображения).

Тут так же нужно отметить, что мы в основном имеем дело в псевдомассивами, поэтому нужно не забывать обращаться к элементам по индексу.

Так же нужно обратить внимание на современную форму записей стилей (в виде строки с возможностью добавления переменных), а не через «style.color=itc..»
![](../_png/Pasted%20image%2020220908195956.png)![](../_png/Pasted%20image%2020220908200002.png)
- И вот тут представлено создание нового элемента нашей страницы с классом black (в CSS заранее прописаны свойства цвета, ширины и высоты данного блока по названию класса)
![](../_png/Pasted%20image%2020220908200008.png)
Это второй вариант записи обращения к элементу (тут мы запихиваем див во враппер)
![](../_png/Pasted%20image%2020220908200013.png)![](../_png/Pasted%20image%2020220908200018.png)
Так же у нас есть возможность добавить элемент в начало объекта, но через другой метод
![](../_png/Pasted%20image%2020220908200028.png)![](../_png/Pasted%20image%2020220908200032.png)
Так же мы можем конкретно пометить после какого элемента мы вставляем блок
![](../_png/Pasted%20image%2020220908200039.png)![](../_png/Pasted%20image%2020220908200044.png)
Ну и несложно догадаться, что если есть before, то должен быть и after
![](../_png/Pasted%20image%2020220908200049.png)![](../_png/Pasted%20image%2020220908200053.png)
Но есть куда более старый метод, который тоже подойдёт для вставки элемента. Ему нужно передать в качестве аргументов два объекта: вставляемый объект и тот, перед которым вставляем
![](../_png/Pasted%20image%2020220908200057.png)![](../_png/Pasted%20image%2020220908200105.png)
- Тут уже представлено удаление одного из трёх кружков через метод remove()
![](../_png/Pasted%20image%2020220908200111.png)![](../_png/Pasted%20image%2020220908200116.png)
И вот представление альтернативного метода, который был актуален раньше
![](../_png/Pasted%20image%2020220908200120.png)
- Так же мы имеем возможность крайне просто и быстро поменять объекты местами между друг другом
![](../_png/Pasted%20image%2020220908200126.png)![](../_png/Pasted%20image%2020220908200132.png)
И вот ещё один абсолютно аналогичный по логике выполнения код, но более старый по записи:
![](../_png/Pasted%20image%2020220908200142.png)
- И вот тут уже нужно познакомиться с двумя методами **innerHTML** и **innerText**.

Первый добавляет на страницу код HTML, который будет работать, а второй добавляет только текст (который мог ввести, например, пользователь)
![](../_png/Pasted%20image%2020220908200151.png)![](../_png/Pasted%20image%2020220908200158.png)
- Данный метод вставляет вписанный код несколькими описанными способами. В качестве первого аргумента мы передаём способ вставки, в качестве второго – сам код

Первый вставит код в самом блоке (в див)

Второй вставит после блока

Третий вставит до блока

Четвёртый вставит как и первый в самом
![](../_png/Pasted%20image%2020220908200241.png)![](../_png/Pasted%20image%2020220908200245.png)
- Так же при инициализации HTML элемента в JS можно указывать откуда мы будем конкретно брать вложенные элементы. То есть, мы можем искать элементы не по всему документу, а внутри враппера, который мы импортнули в JS
![](../_png/Pasted%20image%2020220908200250.png)

### **038 Практика. Задание на отработку действий со страницей**

- Дано 5 задач и начальный объект, внутри которого располагается массив
![](../_png/Pasted%20image%2020220908200303.png)
- Приведены мои решения и решения преподавателя

Тут хочется обратить внимание на textContent. Он позволяет обратиться к контенту внутри блока
![](../_png/Pasted%20image%2020220908200312.png)![](../_png/Pasted%20image%2020220908200319.png)
### **039 События и их обработчики**

- Существует огромное количество событий в JS. Все они применяются при взаимодействии пользователя и нашей формы
![](../_png/Pasted%20image%2020220908200325.png)
- Самое первое и простое взаимодействие – это нажатие кнопки пользователем, которое мы можем прописать прямо в теге (но так делать не рекомендуется)
![](../_png/Pasted%20image%2020220908200329.png)![](../_png/Pasted%20image%2020220908200332.png)
- Так будет правильнее писать событие, но всё равно этот метод достаточно устаревший. Этот код плох тем, что мы можем забыть и переназначить кнопке другое действие далее в коде. А это уже точно приведёт к сбою логики программы
![](../_png/Pasted%20image%2020220908200339.png)
- Это уже современная форма записи через **addEventListener****()**. Первым делом записывается название самого события (нажатие -> click), уже потом вставляем колбэк-функцию
![](../_png/Pasted%20image%2020220908200348.png)
- **mouseenter** – вызывает срабатывание ивента при наведении мыши на элемент
![](../_png/Pasted%20image%2020220908200356.png)![](../_png/Pasted%20image%2020220908200402.png)
- Выводим сам ивент (так же можно ввести event.target – выведет элемент, event.type – тип ивента)
![](../_png/Pasted%20image%2020220908200407.png)![](../_png/Pasted%20image%2020220908200412.png)
- Удаляет блок кода (сам элемент), на который навелись мышкой
![](../_png/Pasted%20image%2020220908200417.png)![](../_png/Pasted%20image%2020220908200421.png)
- Тут логика нашей программы описывается так: у нас есть чекер кликов, после нажатия на первую кнопку – она пропадает и вместе с ней удаляется чекер кликов со второй кнопки
![](../_png/Pasted%20image%2020220908200437.png)
- Тут показаны **вложенные события**. Когда на родительсском и дочернем элементе находится один и тот же обработчик. Сначала всегда срабатывает вложенное событие
![](../_png/Pasted%20image%2020220908200443.png)![](../_png/Pasted%20image%2020220908200446.png)
![](../_png/Pasted%20image%2020220908200455.png)
- Метод currentTarget выводит событие каждого элемента отдельно (сработали отдельно дочерний, потом родительский элементы)
![](../_png/Pasted%20image%2020220908200500.png)
![](../_png/Pasted%20image%2020220908200505.png)
- **preventDefault****()** – позволяет вписать свою логику выполнения для элемента
![](../_png/Pasted%20image%2020220908200510.png)
![](../_png/Pasted%20image%2020220908200516.png)
-
![](../_png/Pasted%20image%2020220908200521.png)
- Так же в mdn можно увидеть, что метод, добавляющий ивенты, может принимать в себя до трёх значений, последний из которых - модификатор
![](../_png/Pasted%20image%2020220908200529.png)
![](../_png/Pasted%20image%2020220908200533.png)
- Пример использования опции:
![](../_png/Pasted%20image%2020220908200542.png)
![](../_png/Pasted%20image%2020220908200546.png)
-

### **040 Навигация по DOM - элементам, data-атрибуты, преимущество forof**

- Мы можем легко вывести и увидеть элементы через JS. Тут хочется выделить такую особенность, что documeentElement – это <html></html> тег, внутри которого всё находится.

Так же, когда мы используем childNodes (вывод всех дочерних элементов), мы можем увидеть очень много разных объектов. В качестве text выступает перенос строки, который мы можем увидеть в коде, но который не отображается

И тут уже стоит пояснить, что в ДОМ-дереве не всё является элементами или узлами. Элемент – это видимая часть HTML, а узел, в свою очередь, – это та связующая часть между элементами и текст. Например, кнопка – это элемент, а текст в кнопке – это узел (нода)
![](../_png/Pasted%20image%2020220908200605.png)
![](../_png/Pasted%20image%2020220908200609.png)
- **parentNode** выводит родительский узел и повторять его можно много раз
![](../_png/Pasted%20image%2020220908200615.png)
![](../_png/Pasted%20image%2020220908200623.png)
- Так же мы можем обращаться к определённым атрибутам в HTML-коде (тут так же работает логика CSS, так как обращение к артрибуту там идёт через **[такой синтаксис]**)
![](../_png/Pasted%20image%2020220908200638.png)![](../_png/Pasted%20image%2020220908200643.png)
- Используя предыдущий синтаксис, мы можем обратиться к предыдущему и следующему объекту (тут как предыдущий, так и следующий объект – это текстовая нода переноса строки)

Но такими методами неудобно пользоваться, так как мы можем попасться на ноду переноса строки, что нам может быть и не нужно
![](../_png/Pasted%20image%2020220908200653.png)![](../_png/Pasted%20image%2020220908200657.png)
- Выводит предыдущий/следующий **элемент** после того, к которому обратились
![](../_png/Pasted%20image%2020220908200704.png)![](../_png/Pasted%20image%2020220908200709.png)
-

**firstElementChild** - выводит первого ребёнка в выбранном элементе

**parentElement** - выводит родителя выбранного элемента
![](../_png/Pasted%20image%2020220908200719.png)![](../_png/Pasted%20image%2020220908200722.png)
- И вот как данный функционал пишется: мы перебираем все элементы объекта body, и если имя элемента «text», то данная итерация цикла пропускается (continue – пропускает итерацию цикла, break – завершает цикл досрочно)
![](../_png/Pasted%20image%2020220908200727.png)![](../_png/Pasted%20image%2020220908200731.png)
### **041 Рекурсия**

- Как можно увидеть, рекурсия позволяет нам множество раз перевыполнять код до его предельного значения. Рекурсия позволяет функции запускать саму себя множество раз для выполнения поставленной задачи

Так же имеются основные понятия как: б аза рекурсии, шаг рекурсии и глубина рекурсии

Нужно сразу упомянуть, что рекурсии менее производительны, нежели чем стандартные функции языка по перебору информации. Однако рекурсии более удобны в большинстве остальных методов
![](../_png/Pasted%20image%2020220908200742.png)
- Первый метод переводит объект в массив, второй метод проверяет является ли объект массивом
![](../_png/Pasted%20image%2020220908200749.png)![](../_png/Pasted%20image%2020220908200753.png)
- Тут представлен объект, который хранит в себе данные о студентах и завершённости прохождения курса
![](../_png/Pasted%20image%2020220908200822.png)
- И нам нужно создать переборщик объекта, который выведет общий процент прхождения курсов. Основная проблема этого переборщика заключается в том, что при переборе объекта он не зайдёт в ещё более вложенные объекты кроме тех, что мы описали – это и есть ограничение нерекурсивных методов
![](../_png/Pasted%20image%2020220908200827.png)
- И вот представление кода с рекурсией. Он уже может обработать объекты любой сложности и вложенности, так как при каждой встрече объекта, он переходит во второй условный блок кода, где располагается else и там запускает массив заново, чтобы дойти до массива, где сработает блок кода true
![](../_png/Pasted%20image%2020220908200834.png)
- С представленным выше объектом оба массива справляются одинаково
![](../_png/Pasted%20image%2020220908200840.png)
- Но если немного изменить структуру
![](../_png/Pasted%20image%2020220908200846.png)![](../_png/Pasted%20image%2020220908200850.png)
### **042 Практика. Используем события на странице проекта**

-
![](../_png/Pasted%20image%2020220908200857.png)
- DOMContentLoaded – браузер полностью загрузил HTML, было построено DOM-дерево, но внешние ресурсы, такие как картинки <img> и стили, могут быть ещё не загружены
![](../_png/Pasted%20image%2020220908200903.png)
[https://learn.javascript.ru/onload-ondomcontentloaded](https://learn.javascript.ru/onload-ondomcontentloaded)

- обращение ко всем изображениям внутри класса
![](../_png/Pasted%20image%2020220908200909.png)
- Тут находятся все переменные в проекте (и необычные селекторы вызова)
![](../_png/Pasted%20image%2020220908200914.png)
- Это одна из самых сложных частей данного сайта – формирование списка фильмов. Первым делом, в текст вкладываемого родителя мы вставляем пустую строку, которая нам позволит очистить имеющиеся айтемы списка (li). Дальше мы сортируем массив. Потом мы заменяем элемент списка, и именно вставляем новый айтем включая добавление HTML-структуры. Добавляем структуру через «+=», так как мы добавляем айтем списка - li.

Потом мы добавляем функционал удаления фильма из писка элементов. Сначала вызываем иконки с классом «delete», в которые через forEach вставляем ивент, который будет срабатывать при нажатии (‘click’). Внутри ивента будем обращаться к родителю иконки и удалять его. Удалять уже фильм из массива будем через метод splice, в который поместим номер элемента (второй аргумент forEach) и количество элементов. Потом уже вызовем рекурсией наш фонрмировщик списка (для формирования обновлённой структуры)

![](../_png/Pasted%20image%2020220908200932.png)

- Это дополнительные методы. Первый удаляет рекламу со страницы. Второй вносит изменения в жанре и фоне. Третий сортирует массив. Четвёртый проводит проверку наличия фильма в массиве (вызываем тоже при нажатии кнопки)
![](../_png/Pasted%20image%2020220908201058.png)
- Это полное описание события ‘submit’, которое хранит в себе порядок действий при нажатии на кнопку в форме
![](../_png/Pasted%20image%2020220908201104.png)
- А тут мы вызываем методы для изменения нашего списка (внутри него и сортировка тоже), внесения изменений (смена жанра и заднего фона) и удаления рекламы
![](../_png/Pasted%20image%2020220908201109.png)
### **043 События на мобильных устройствах**

- На телефоне в основе своей нет кликов мышкой – есть тачи. Однако события с кликами нормально отрабатывают и в мобильных версиях браузеров

- Мобильных событий всего 6:

·         touchstart – возникает при соприкосновении

·         touchmove – возникает при перемещении пальцем

·         touchend – палец отпускается от элемента с данным ивентлистенером

·         touchenter – срабатывает как только палец при скольжении попадает на элемент с данным ивентом

·         touchleave – срабатывает когда палец выходит за пределы элемента

·         touchcancel – срабатывает тогда, когда точка соприкосновения не регистрируется на поверхности (если палец выйдет за пределы браузера)

- И вот примеры отображения ивентов в браузере. Первый ивент срабатывает при первом клике на объект, второй ивент срабатывает когда мы тыкаем по объекту и водим по нему, третий срабатывает, когда мы отпускаем палец с объекта
![](../_png/Pasted%20image%2020220908201144.png)![](../_png/Pasted%20image%2020220908201150.png)
- Так же стоит упомянуть, что у ивентов есть свои методы. И вот три из них, которые позволяют отслеживать тачи относительно объекта:
![](../_png/Pasted%20image%2020220908201156.png)
- Сама информация о тачах представляет из себя: положение в пространстве, поворот, радиус, количество пальцев и так далее
![](../_png/Pasted%20image%2020220908201201.png)
- Вот пример вывода всех методов о клике и вывода положения по X пальца, который перемещается по боксу
![](../_png/Pasted%20image%2020220908201206.png)![](../_png/Pasted%20image%2020220908201213.png)
_Ресурс, который позволит немного упростить работу с тачами_ - [https://hammerjs.github.io/](https://hammerjs.github.io/)

### **044 Async, defer, динамические скрипты**

- Тут нужно уопмянуть, что при расположении скрипта в хеде страницы у нас вылазит две проблемы:

1) Так как скрипт загрузился, а страница нет, то скрипту не с че будет работать и он выдаст ошибку

2) Сам по себе скрипт стопорит загрузку HTML-страницы и при большом его весе у нас страница может долго загружаться
![](../_png/Pasted%20image%2020220908201219.png)
- Но так же перед нами может встать другая проблема: очень большой проект. Сайт может содержать в себе тысячи элементов, которые могут очень долго загружаться. Это приведёт к тому, что скрипт может не сработать в тех местах, где нам это нужно было
![](../_png/Pasted%20image%2020220908201225.png)
- Атрибут **defer**. Он сообщает браузеру, чтобы он продолжал загружать страницу, но так же браузер должен загружать и скрипт в фоновом режиме, а затем запустить скрипт, когда он загрузится.

1) Скрипты с **defer** никогда не блокируют страницу

2) Скрипт запустится только тогда, когда DOM-дерево уже готово
![](../_png/Pasted%20image%2020220908201233.png)
- Так же ещё одной особенностью является то, что скрипты выполняются последовательно друг за другом, даже если какой-то загрузился раньше.

Это позволяет нам закинуть те же скрипты в хедер сайта, но гугл сео-тест будет ругаться на такое расположение скриптов
![](../_png/Pasted%20image%2020220908201241.png)![](../_png/Pasted%20image%2020220908201244.png)
- Ещё один атрибут, который модифицирует работу скриптов – это **async**.

1) Страница не ждёт асинхронных скриптов – содержимое загружается и обрабатывается

2) Событие “DOMContentLoaded” и асинхронные скрипты не ждут друг друга

Тут уже нужно убедиться, что скрипты не зависят от DOM-структуры, так как выполняются они сразу же
![](../_png/Pasted%20image%2020220908201250.png)
- И вот пример подключения скриптов по нужному порядку к сайту
![](../_png/Pasted%20image%2020220908201254.png)
![](../_png/Pasted%20image%2020220908201259.png)
![](../_png/Pasted%20image%2020220908201303.png)
### **045 Ресурсы для оттачивания навыков программирования**

- СсылОчки:

[https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/](https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/)

[https://www.hackerrank.com/](https://www.hackerrank.com/)

[https://leetcode.com/](https://leetcode.com/)

[https://www.codewars.com/](https://www.codewars.com/)