## 016 Устройство Node.js

В начале 2000-х годов у нас были стандартный многопоточные серверы. Один поток процессора сервера выполнял один запрос от пользователя. 
Основная проблема заключалась в том, что 1 поток занимал 1 мб памяти и само переключение потоков требовало определённых ресурсов компьютера. 

![](_png/Pasted%20image%2020221120120612.png)

Далее проблема переходила в то, что наш поток блокировался в процессе выполнения своих операций и простаивал пока происходило логирование данных, получение данных из базы и происходил сам рендер шаблона 

![](_png/Pasted%20image%2020221120120701.png)

Так же вследствие того, что поток занимал 1 мб памяти, то при выделении большого количества потоков, у нас может появиться стопор в виде недостатка памяти (а на момент начала 21-ого века 10 гб памяти было большой цифрой) 

![](_png/Pasted%20image%2020221120120815.png)

Поэтому вдальнейшем была придумана система, при которой наш поток не блокируется

![](_png/Pasted%20image%2020221120120858.png)

Поэтому схема, которая работала раньше, преобразуется уже в другую: 
1) Мы имеем запросы
2) Все они поступают в основной поток, который выполняет задачи запросов
3) Если задача достаточно тяжёлая, то она отправляется на дополнительный поток сервера (например, криптография, чтение файлов и так далее)

![](_png/Pasted%20image%2020221120121352.png)

Так же в ноде существуют такие понятия как: стек и куча.
1) Куча хранит в себе переменные
2) Стек - это хранилище стека вызова функций

Конкретно тут мы видим ситуацию со схемы выше. Стек - это основной поток, который выполняет все операции. Конкретно функция `setTimeout` не будет блокировать все остальные операции - она вынесется в дополнительный поток, где и обработается.

==node== - это не однопоточный фреймворк. Это фреймворк, который имеет один основной поток (стек вызовов) и множество дополнительных поток, в котором выполняются более затратные операции.

![](_png/Pasted%20image%2020221120121555.png)

Составляющие ==NodeJS==:
1) Движок ==V8== (виртуальная машина JS), который разрабатывается в ==google== и находится в хроме;
2) Библиотека LibUV. Она реализует концепцию Event Loop, Thread Pool и асинхронный ввод/вывод;
3) Стандартная библиотека. Она содержит в себе функциональность работы с файловой системой, криптографией, ивентами и всеми остальными функциями ноды (аналог - WebAPI);
4) Далее наш код будет биндиться в C/C++ код, который уже будет выполнять эффективные операции над нашими операциями;
5) Так же мы можем подключать C/C++ аддоны к нашему приложению;
6) NodeJS API

![](_png/Pasted%20image%2020221120122123.png)

К нам пришёл на сервер запрос от пользователя, первым делом он попадает в движок V8 откуда попадает в биндер ноды, уже который переводит запрос в очередь событий. В рамках очереди событий, у нас есть Event Loop, который крутиться и обслуживает всю нашу систему. После же Event Loop отправляет все задачи в Callstack (тот самый основной поток - Stack), где задача и выполняется на движке V8, либо, если встречается тяжёлая задача, она идёт на выполнение в отдельный поток. После выполнения задачи уже из этого стека результат задачи идёт обратно в ивент луп, откуда и передаётся обратно на входные системы для выдачи ответа.
Если выполнилась тяжёлая задача, то её коллбэки будут передаваться обратно в очередь событий, откуда пройдёт стандартный путь стандартной задачи.

![](_png/Pasted%20image%2020221120123235.png)

## 017 Event Loop





















## 018 Таймеры



## 019 Пример работы event loop



## 020 Stack вызова



## 021 Worker threads



## 022 Измерение производительности