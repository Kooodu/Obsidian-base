## 016 Устройство Node.js

В начале 2000-х годов у нас были стандартный многопоточные серверы. Один поток процессора сервера выполнял один запрос от пользователя. 
Основная проблема заключалась в том, что 1 поток занимал 1 мб памяти и само переключение потоков требовало определённых ресурсов компьютера. 

![](_png/Pasted%20image%2020221120120612.png)

Далее проблема переходила в то, что наш поток блокировался в процессе выполнения своих операций и простаивал пока происходило логирование данных, получение данных из базы и происходил сам рендер шаблона 

![](_png/Pasted%20image%2020221120120701.png)

Так же вследствие того, что поток занимал 1 мб памяти, то при выделении большого количества потоков, у нас может появиться стопор в виде недостатка памяти (а на момент начала 21-ого века 10 гб памяти было большой цифрой) 

![](_png/Pasted%20image%2020221120120815.png)

Поэтому вдальнейшем была придумана система, при которой наш поток не блокируется

![](_png/Pasted%20image%2020221120120858.png)

Поэтому схема, которая работала раньше, преобразуется уже в другую: 
1) Мы имеем запросы
2) Все они поступают в основной поток, который выполняет задачи запросов
3) Если задача достаточно тяжёлая, то она отправляется на дополнительный поток сервера (например, криптография, чтение файлов и так далее)

![](_png/Pasted%20image%2020221120121352.png)

Так же в ноде существуют такие понятия как: стек и куча.
1) Куча хранит в себе переменные
2) Стек - это хранилище стека вызова функций

Конкретно тут мы видим ситуацию со схемы выше. Стек - это основной поток, который выполняет все операции. Конкретно функция `setTimeout` не будет блокировать все остальные операции - она вынесется в дополнительный поток, где и обработается.

==node== - это не однопоточный фреймворк. Это фреймворк, который имеет один основной поток (стек вызовов) и множество дополнительных поток, в котором выполняются более затратные операции.

![](_png/Pasted%20image%2020221120121555.png)

Составляющие ==NodeJS==:
1) Движок ==V8== (виртуальная машина JS), который разрабатывается в ==google== и находится в хроме;
2) Библиотека LibUV. Она реализует концепцию Event Loop, Thread Pool и асинхронный ввод/вывод;
3) Стандартная библиотека. Она содержит в себе функциональность работы с файловой системой, криптографией, ивентами и всеми остальными функциями ноды (аналог - WebAPI);
4) Далее наш код будет биндиться в C/C++ код, который уже будет выполнять эффективные операции над нашими операциями;
5) Так же мы можем подключать C/C++ аддоны к нашему приложению;
6) NodeJS API

![](_png/Pasted%20image%2020221120122123.png)

К нам пришёл на сервер запрос от пользователя, первым делом он попадает в движок V8 откуда попадает в биндер ноды, уже который переводит запрос в очередь событий. В рамках очереди событий, у нас есть Event Loop, который крутиться и обслуживает всю нашу систему. После же Event Loop отправляет все задачи в Callstack (тот самый основной поток - Stack), где задача и выполняется на движке V8, либо, если встречается тяжёлая задача, она идёт на выполнение в отдельный поток. После выполнения задачи уже из этого стека результат задачи идёт обратно в ивент луп, откуда и передаётся обратно на входные системы для выдачи ответа.
Если выполнилась тяжёлая задача, то её коллбэки будут передаваться обратно в очередь событий, откуда пройдёт стандартный путь стандартной задачи.

![](_png/Pasted%20image%2020221120123235.png)

## 017 Event Loop

Event Loop имеет свои фазы, которые описаны в его документации. Самой важной и основной является четвёртая, потому как нода очень быстро работает с вводом/выводом.

![](_png/Pasted%20image%2020221120164001.png)

Так как указаны не все выполняемые элементы языка, то между этими фазами выполняются остальные функции (те же промисы)

![](_png/Pasted%20image%2020221120164516.png)

В полной картине выполнения ивент лупа выполняется в самом начале инициализация всех импортов и функций. Далее по порядку выполяются все элементы ивент лупа. Потом ивент луп проверяет, на закончена ли программа (например, если в моменте совершения лупа таймер был 3 секунды, то луп повторяется до тех пор, пока время таймера не кончится и не выполнится операция).

![](_png/Pasted%20image%2020221120165120.png)

## 018 Таймеры

Первое, что нужно отметить это то, что таймер не гарантирует нам выполнение функции ровно в то время, которое мы указали. Он гарантирует нам, что функция сработает не раньше указанного времени. И чем более высоконагруженные задачи будут в стеке, тем на большее время будет отдаляться выполнение функции от таймера  

```JS
const start = performance.now();

setTimeout(() => {
	console.log(performance.now() - start);

	console.log("Прошла секунда");
}, 1000);
```
![](_png/Pasted%20image%2020221120170311.png)












## 019 Пример работы event loop



## 020 Stack вызова



## 021 Worker threads



## 022 Измерение производительности




