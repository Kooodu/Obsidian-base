### 009 Сравнение сред выполнения JS

==NodeJS== имеет своё собственное API, которое несовместимо с браузером, поэтому могут быть некоторые сложности из-за несовместимости со стандартным ==JS== (в браузере). Так же нода имеет свои глобальные переменные, так как она работает непосредственно с ПК

![](_png/Pasted%20image%2020221029153615.png)

Так же есть и более свежый вариант бэка на ==JS== - это ==Deno==. Единственная его проблема заключается в том, что он пока очень молод и коммьюнити не такое и большое.

![](_png/Pasted%20image%2020221029153908.png)


### 010 Запускаем код и REPL

REPL-режим - это режим, при котором мы можем запустить определённую среду в консоли

Запускается REPL в ноде командой:
```bash
node
```

И работать в этом режиме так же как и в браузере

![](_png/Pasted%20image%2020221029155318.png)

Создаём поток чтения `fs`, который будет читать наш текстовый файл и выводить его в консоль
 
```JS
fs = require("fs");  
  
const data = fs.readFileSync("./data.txt");  
console.log(data.toString());
```
![](_png/Pasted%20image%2020221029155934.png)

### 011 Модули в JavaScript

Плюсы модулей:

![](_png/Pasted%20image%2020221029160153.png)

История выраженности нужности импортов достаточно небольшая и она состояла из трёх этапов:
1) IIFE функции
2) Второй стандарт появился в NodeJS и работал через `require`. Для работы в браузере он требовал сборку в один файл (через сборщики модулей)
3) Последняя версия стандарта появилась сначала для работы на фронте, но в последние несколько лет её можно использовать и на бэке

![](_png/Pasted%20image%2020221029161331.png)

Самые первые импорты - **IIFE**. Это функции, которые вызвались самостоятельно. Внутри них происходил не просто самовызов на странице пользователя, а взаимное связывание и присвоение отдельных компонентов функции к главному скриптовому файлу.
Порядок подключения был важен.

![](_png/Pasted%20image%2020221029161422.png)

Второй способ - **CommonJS** . В первую очередь, они работают именно на бэке. Для работы на фронте им был нужен сборщик модулей, который собирал бы на ноде файл в один модуль.

![](_png/Pasted%20image%2020221029172531.png)

И последний способ импорта - **ES Modules**. Особенность ноды заключается в том, чтобы использовать современные импорты, нужно использовать расширение `.mjs`

![](_png/Pasted%20image%2020221029172757.png)

Главным преймуществом CommonJS является то, что его можно использовать в любом месте кода, а так же в условиях (что позволяет нам не подключать какой-либо модуль, если нам то не нужно)
Главным преймуществом ES Modules является то, что он подключает тольк указанные части модуля, а не его полностью (если то не требуется) + он асинхронен (не останавливает выполнение приложения, если импорт не подгрузился)

![](_png/Pasted%20image%2020221029173425.png)

Подключить модули в NodeJS можно тремя способами:

![](_png/Pasted%20image%2020221029173727.png)

### 012 CommonJS Modules



`characters.js`
```JS
let characters = [  
   { name: 'Фродо', hasRing: false },  
   { name: 'Бильбо', hasRing: false },  
];  
  
function steelRing(characters, owner) {  
	// тут функция конкретно изменяла вложенное в неё значение
   characters.map(c => {  
      if (c.name == owner) {  
         c.hasRing = true;  
      } else {  
         c.hasRing = false;  
      }  
   });  
}  
  
module.exports = { characters, steelRing };
```

`app.js`
```JS
const { characters, steelRing } = require('./characters.js');  
  
steelRing(characters, 'Фродо');  
  
for (const c of characters) {  
   console.log(c);  
}
```

![](_png/Pasted%20image%2020221029175824.png)

И дальше нужно переписать код так, чтобы функция работала правильно и не мутировала внутри себя значение, а возвращала изменённое значение вовне.

```JS
// characters.js
let characters = [  
   { name: 'Фродо', hasRing: false },  
   { name: 'Бильбо', hasRing: false },  
];  
  
function steelRing(characters, owner) {  
   return characters.map(c => {  
      if (c.name == owner) {  
         c.hasRing = true;  
      } else {  
         c.hasRing = false;  
      }  
   });  
}  
  
module.exports = { characters, steelRing };


// app.js
const { characters, steelRing } = require('./characters.js');  

// Нужно создать новую переменную, которая будет хранить старую версию массива и принимать изменённый
let myChars = characters;  
myChars = steelRing(myChars, 'Фродо');  
  
for (const c of characters) {  
   console.log(c);  
}
```










### 013 ES Modules







### 014 Глобальные переменные









### 015 Events







