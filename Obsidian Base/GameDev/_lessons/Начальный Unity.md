### Глава 1. Введение

#### **Урок 1. Что такое движок**

- Это абстракция, на которой строят геймплей. Он забирает на себя воспроизведение логики, рендеринга и остальных задач

#### **Урок 2. Обзор Unity**

- В юнити присуствуют все компоненты для разработки 2Д и 3Д игр: от тайловой системы, скриптинга, шейдоров до инструментов по созданию сцен и анимации

#### **Урок** **3.** **Что** **сделано** **на** **Unity**

- Cuphead, Ori, Ghost of a Tale, Pokemon Go, Rick and Morty
![](_png/Pasted%20image%2020221017100439.png)

### **Глава 2. Основной интерфейс**

#### **Урок 1. Окно** **Project**

- Чтобы добавить сюда ассет, нужно просто перетащить его сюда, открыть через распаковщик юнити или сразу закинуть в папку Asset через проводник. Так же можно удобно пользоваться поиском

#### **Урок 2. Окно** **Scene**

- Тут мы можем включить различные типы отображения

- Тут переключаем 2Д и 3Д вид, свет, звук в игре, отключаем или включаем различные пост-эффекты

- Галазик скрывает помеченные объекты на скрытие

- А тут располагается Gizmos (скрытие различных объектов)

-

#### **Урок 3. Окно** **Hierarchy**

- Мы можем добавить складку через многоточие

- И для работы сразу с двумя объектами можно заблокировать один инспектор и пользоваться свободно вторым

- И так же можно копировать один объект на другой

- В иерархии можно не только обращаться к объектам, но и задавать им родительские объекты (от которых будут перениматься начальные значения)

-

#### **Урок 4. Окно** **Inspector**

- Тут производятся настройки сущности

- Так же можно накинуть ярлык на невидимый объект

#### **Урок 5. Окно** **Game**

- Тут запускается игра

### **Глава 3. Создание уровня 3D**

#### **Урок 1. Работа с объектами перемещение, вращение, и масштабирование**

- Чтобы скрыть объекты из вьюпорта и из окна игры, нужно просто отключить галку

- Зажав Ctrl мы можем менять поворот и перемещать объекты на определённое значение

- Предпоследний инструмент позволяет сделать всё то же самое, что и прошлые инструменты. А самый последний меняет бокс объекта (область взаимодействия с ним)

#### **Урок 2. Полезные фишки при работе с редактором**

-

- Тут указываем ось, с которой мы будем смотреть на объекты

- Так же если нам нужно расположить один объект на другом, то мы можем зажать Shift+Ctrl и передвигать объект за квадратик, тогда один коллайдер будет идти по второму (нужно для правильного позиционирования одного объекта поверх другого)

- Так же если мы поменяем тут центр на якорную точку, то объект будем перетаскивать серединой по коллайдеру другого объекта (если будут ошибки при перетаскивании, то стоит поменять эту настройку)

- Зажав V и потянув с ЛКМ, у нас появляется возможность перетянуть блок в то место, куда нам нужно

- В гейммоде положение объектов не сохраняется

#### **Урок 3. Добавляем контроллер игрока**

- В ассет сторе можно найти себе модельки и уже потом их скачать в юньке

- Если появляется какая-то ошибка при импорте ассетов, то данный ассет можно удалить

- И теперь мы закинем данные префам гейм контроллера (персонажа с ригом, анимацией и кодом) в наш проект и закинем в персонажа камеру (чтобы она двигалась за ним). И теперь, когда мы запустим проект, у нас всё заработает

#### **Урок 4. Импортируем текстуры и модели**

- Если мы импортируем текстуру, то нам нужно поменять тип текстуры со спрайта на дефолтную и добавить репит (если текстура тайловая)

- А сейчас остаётся перенести текстуру в альбедо материала и сам материал закинуть на какой-либо объект в сцене

- **Лайфхак.** Чтобы быстро сделать нормаль прямо в юнити, можно поменять тип текстуры на карту нормалей, поставить галку на грейскейл и отрегулировать бампнесс (не забываем апплайнуть). И переносим текстуру в нормали материала

- Так же тут в мелком окошке мы можем менять фигуру, положение источника освещения и регулировать рефлекшены

- Так же можно спокойно закидывать 3Д модели в проект

- Чтобы накинуть текстуры на материал, нам нужно поменять типы этих текстур

- И закинуть материал можно так же через элемент объекта

- Так же в настройках материала убирается металлический блеск

#### **Урок 5. Материалы**

- Материал – это шейдер. Шейдер – это специальная программа, которая отрисовывает объект на видеокарте + данные для шейдера. Когда мы накидываем шейдер на игровой объект, то объект начинает рендериться с данными настройками

- Так же этим ползунком можно повысить бликовость материалов (можно сделать имитацию сырого объекта)

- Так же есть Unlit материалы. Это материалы, которые не зависят от освещения

#### **Урок 6. Терраин**

- Далее создаём 3Д объект - Террарию

- Включаем последнее меню компонента Terrarian и можем поменять размер террарии

- И в разделе рисования геометрии, мы можем поменять высотую неровностей. Выбираем режим Set Height, меняем параметр Height (максимальная высота изменений), выбираем кисть и настраиваем её

- Дальше для раскраски выбираем режим пэинтинга и тыкаем по Edit Terrarian Layers

- Если мы докинем ещё одну текстуру, то сможем ею рисовать поверх первой

- Дальше переходим во вкладку распределения деревьев и добавляем ассет дерева

- Рисуем деревья. Так же можно настроить высоту дерева и вариацию цветов дерева

- Ну и дальше по схожему принципу добавляем траву в отдельной вкладке

- В юнити очень плохо добавляется трава, поэтому это делают в отдельных программах

#### **Урок 7. Как устроены 3D модели и текстуры**

- Очень важная вещь в 3Д – Mip мапы. Движок генерирует уменьшенные версии текстур, чтобы повысить производительность, не прогружая дальние объекты на 100%

- Так же все объекты непосредственно в движке находятся с треугольными полигонами, которые прощу обрабатываются компьютером, нежели чем обычные полигоны

#### **Урок 8. Физика и коллайдеры в 3D**

- Так как мы делаем игру, то у нас очень остро стоит вопрос об оптимизации. Мы не можем реализовать каждую травинку ровно такой, как она выглядит ровно потому, что это будет очень сильно потреблять ресурсы компьютера. Поэтому придумали использовать разные понятия и реализации объектов: объекты и коллайдеры.

Объекты – это тот объект, который мы видим

Коллайдер – это то поле, с которым взаимодействует игровое окружение (оно имеет более простую форму)

- Коллайдер – это физическая форма объекта

- RigidBody отвечает уже за реализацию физики объекта. Он в свою очередь реализует трение, сопротивление воздуха, гравитацию и другие физические законы

Если сейчас запустить игру, то персонаж упадёт на землю

### **Глава 4. Создание уровня 2D**

#### **Урок 1. Спрайты и SpriteRenderer**

- Меняется естественно цвет спрайта и его альфа

- Флипается

- Тут стоит обычное растягивание

- Дальше врубаем Sliced растягивание. Для его работы нужно немного изменить исходник так, чтобы он был единым полигоном и выделить область, которая будет изменяться

- Если выбрать Tiled, то то, что мы выделили будет тайлиться

- Если поменять режим тайла с Continuous на Adaptive, то у нас тайл будет совершаться в том случае, если блок будет подходить под размер, а в противном случае блоки будут сжиматься (выглядит прикольно так-то)

- А тут уже идёт масштабирование без потери качества

-

#### **Урок 2. 2D с 3D камерой**

- Ортографию используем в 2Д, Перспективу в 3Д. Это правило можно нарушать, но если это будет оправдано (например, для создания параллакса можно использовать перспективную камеру)

-

-

#### **Урок 3. Слои**

- Чем меньше значение Order, тем дальше от камеры будет отображаться объект. Особенно актуально в ортографическом режиме

-

#### **Урок 4. Атласы**

- Имеем мы такой тайтл-атлас

- Выбирает в Sprite mode параметр Multiple и переходим в спрайт эдитор. В нём мы можем просто проводить свой аутлайн и применять изменения

- Однако куда быстрее будет вырезать персонажа по сетке

- Или предоставить дело автоматике

- Важно! Если появляются проблемы с тем, что объекты заходят на границы других, можно сделать кастомный аутлайн для определённых спрайтов.

Для этого переходим в этот режим, зажимаем ЛКМ и проводим квадрат (свой квадрат). Дальше можно будет в него добавить дополнительные точки и тягать за них

-

#### **Урок 5. TileEditor**

- Мы можем выделить сразу все спрайты и поменять им всем сразу параметры

- Дальше мы открываем Tile Palette

- Создаём новую тайловую палитру и сохраняем её

- Перекидываем нужные тайлы в неё (их опять же сохраняем)

- Далее нам нужно создать наш «холст». Для этого создаём тайлмапу

- Выбираем нужный блок кистью и рисуем на тайлмапе. Так же у нас есть резинка и заливка

- Так же мы можем нарисованный блок перенести в палитру с помощью пипетки и режима редактирования в палитре

- Дальше кистью вне режима редактирования можно выбрать определённый регион и рисовать этим регионом по тайлмапе

- Так же в режиме редактирования можно рисовать в самой палитре (+пипетка)

- Так же мы можем создать несколько наших тайлмэпов для разделения труда

-

### **Глава 5. 2D Физика**

#### **Урок 1. 2D Физика и 2D коллайдеры**

- Так же можно просто затайлить текстуру, выбрав режим и растянув её

- У нас есть несколько Box Collider – один для 3Д другой для 2Д

- И когда мы закинули Box Collider 2D на наш тайл, переходим в режим редактирования тайла и растягиваем его по длине платформы

- И дальше на персонажа нам нужно накинуть тоже коллайдер (для примера взял Circle, хотя box сошёл бы лучше). Подгоняем размер коллайдера под размер персонажа. Так же накинем RB2D, чтобы у персонажа появилась физика и он заимел гравитацию

- И вот персонаж на тайле

- Так же можно создать 2Д материал, который будет корректировать физику взаимодействия с объектом. Этот материал закидывается в коллайдер

- Так же есть и 3Д физический материал (для трёхмерных объектов)

- Чтобы добавить коллайдер на тайлмапу, мы должны воспользоваться Tilemap Collider. У нас создастся для каждого блока отдельно тайлмапа.

Минус такого подхода в том, что каждый блок имеет разный коллайдер, оттого и объекты, которые на него попадут будут вертеться туда-сюда

- Поэтому докидываем компонент Composite Collider и вместе с ним сразу докинется и RigidBody. В RB2D поставим статический бодитайп, чтобы блок не падал.

Composite Collider объединит коллайдеры всех наших тайлов в тайлмапе и превратит их всех в один монолитный (чтобы персонаж не переворачивался при том же падении)

-

#### **Урок 2. Эффекторы**

- Эффекторы – это компоненты, которые позволяют без программирования совершать какие-либо действия

Первый эффектор – это Surface Effector. Он реализует конвейер (объект будет катиться в сторону угла).

Накидываем эффектор и коллайдер на платформу. Далее нам нужно в коллайдере указать, что он будет использоваться эффектором.

- Далее идёт Buoyancy Effector. Он симулирует поведение течения.

В коллайдере нам нужно указать, что он будет использоваться эффектором и указать, что коллайдер будет триггером (у него пропадёт его привычный коллайдер и триггер будет возвращать, что другой объект находится внутри него). Далее в самом эффекторе нам нужно указать density (плотность потока), level (уровень заполненности объекта), angle (угол, под которым будет идти течение) и magnitude (сила направления объекта (влияет на скорость))

- Area effector.

Для применения этого эффектора нужен отдельный объект. Вернём Surface Effector на наш биом (уберём галку с isTrigger) и создадим отдельный (пустой) объект со своим коллайдером и добавим в него Area Effector. Поменяем в эффекторе параметр magnitude, который отвечает за силу изменения скорости объекта.

В результате объект просто ускорится в диапазоне коллайдера эффектора (на значение, указанное в магнитуде)

- Если мы добавим значение в параметр Angle, то сила применится к персонажу в указанный угол

- Point Effector. Этот эффектор создаёт которую точку из выбранного объекта, относительно которой будет действовать определённая нами физика.

Накидываем коллайдер на любой объект и увеличиваем его радиус (не забываем про триггер и использование эффектором). Накидываем эффектор и указываем магнитуду.

Указав отрицательную магнитуду, мы заставили Поинт притягивать к себе объекты. Наш герой теперь будет вечно крутиться (совершать покачивающие движения) вокруг данной точки.

Если указать положительное значение, то точка будет выталкивать объекты из своего коллайдера (значения можно менять в плеймоде, чтобы быстро смотреть на результат)

- И эффектор Platform у нас создаёт зону, в которой объект начинает быть твёрдым. Например, в платформерах можно заметить, что при прыжке вверх снизу платформу можно перепрыгнуть, а сверху с платформы персонаж не падает – это вот этот вот эффектор.

Он делает коллайдер проходимым объект вне зоны его работы и делает его твёрдым (непроходимым) вне зоны его работы

Тут работа аналогичная с сёрфэйсом

-

### **Глава 6. Префабы**

#### **Урок 1. Что такое Prefab**

- PreFab – это объект с сохранёнными настройками под проект (сохранена в нём анимация, эффекты, скрипты и всё остальное), чтобы можно было быстро использовать объект на разных этапах разработки с минимальными затратами времени на пересборку объекта.

Грубо говоря, это средство, с помощью которого удобно будет делать изменения по всему проекту. Если мы, например, возьмём дерево с определёнными настройками, то его сможем легко настраивать, меняя всего один префаб

-

#### **Урок 2. Как создать Prefab**

- Просто берём и перетаскиваем наш желаемый объект из окна инспектора в окно проекта. Теперь мы можем использовать один и тот же объект много раз без перенакидывания коллайдеров, эффектов и кода

-

#### **Урок 3. Редактирование Prefab**

- Перейти внутрь префаба можно тремя способами: кликнуть в проекте по нему два раза, кликнуть в иерархии на стрелочку или в инспекторе на Open

- Галочку автосохранения можно как включить, так и выключить.

Можем спокойно изменять объект как нашей душе угодно и добавлять к нему новые объекты и компоненты.

Чтобы выйти тыкаем на стрелочку в иерархии либо по Scene

- И теперь видим, что оба объекта настроены одинаково

- Мы можем спокойно поменять параметр любого компонента у префаба пока мы находимся в проекте и эти изменения останутся только на одном префабе

- Так же, чтобы применить изменения одного префаба, которые были произведены вне окна префаба, мы можем тыкнуть по Overrides и принять либо некоторые изменения, либо все сразу

Какие изменения отображаются: добавление объекта, удаление объекта, изменение/добавление компонента и удаление компонента

### **Глава 7. Анимации**

#### **Урок 1. Анимация компонентов объекта и анимационные кривые**

- Открываем панель анимации

- Выбираем персонажа и для него создаём отдельную анимацию

- Выбираем количество кадров отображаемое в таймлайне и на определённую анимацию персонажа

- И добавляем параметр, который мы будем анимировать

- Тыкая по точке в определённом месте, мы создаём анимацию по всем параметрам

- Так же мы можем заанимировать цвет (он уже анимируется от 0 до 1)

- Так же мы можем регулировать графики и настраивать их типы

-

#### **Урок 2. Покадровая анимация спрайта**

- В Samples ставим число равное количеству кадров нашей анимации и закидываем прямо на таймлайн спрайты анимации. Если нужно ускорить анимацию, то количество сэмплов можно увеличить

-

#### **Урок 3. Костная 2D анимация**

-

-

- Сплит добавляет между костями дополнительную кость

- Так же можно тыкнуть по основанию кости и сделать для неё дочернюю кость

- Тут мы генерируем нашу геометрию для спрайта

- Параметры: детали по границе, учитывать ли полупрозрачные участки, подразделение сетки

- Так же тут можно отредактировать геометрию

- А тут можно добавить точки

- Так же тут мы генерируем веса

- Тут регулируется отображение костей и весов (их непрозрачность)

- В разных режимах можно кистью исправить влияние весов определённых костей

- Этот режим усиляет влияние выбранных костей на кости, к которым присоединены эти кости

- Этот метод сглаживает веса и делает их мягче

- Закидываем компонент Sprite Skin и нажимаем на создание костей. Теперь на нашем объекте будут кости, которые мы ему прописали

- кости можно двигать отдельно

- Либо выделить все и двигать друг за другом каждый

- Я так понял, что для нормальной записи анимации нужно выбирать главные объекты группы без дополнительных. Поэтому выбираем нужные нам кости, нажимаем на кнопку записи всех действий (красная такая) и начинаем гнуть дерево, передвигая таймлайн

- Чтобы получить зацикленную анимацию, вставляем начальные кадры в конец

-

#### **Урок 4. Работа с анимациями 3D объектов**

- Если у нашего персонажа изначально присутствует анимация, то тыкаем по нему в Project и заходим в риг. Меняем параметр на гуманоида и нажимаем на Configure

- Далее мы видим риг персонажа. Можно увидеть, что тело не полностью было зарижено, но можно подтвердить операцию конфигурации туловища

- Дальше мы обратно тыкаем в проекте на персонажа и снизу (лучше сразу во вкладке Animation) можно найти скрытую панельку, которую нужно достать

- Нам нужна вкладка Animation

- И уже в этой вкладке мы должны нарезать нашу анимацию по времени (если она не нарезана за нас). На плюсик добавляется регион и время

- Так же нам нужно зациклить некоторые анимации, чтобы они повторялись не разово, а постоянно

- Все изменения всегда нужно принимать

- Создаём на нашем префабе из иерархии Animator и для него создаём новый Animation Controller

- Открываем вкладку Animator. Выбираем в иерархии наш префаб героя. Делаем несколько пустых нодов. Делаем между ними Transitions (транизшены будут определять переходы между анимациями героя и делаем между ними связи). Так же переименовываем ноды

- В параметрах мы должны создать скорость и атаку с параметрами вещественное число и триггер соотвественно

- Дальше выделяем транзишены и определяем при каких условиях будет совершён переход между состояниями (тыкаем на плюсик и выбираем при каких условиях будет производиться переход действия). Указываем условия в обе стороны для бега (скорость >0 – движемся, скорость <0.01 - стоим)

- Для обеих анимаций отключаем время выхода в транзишенах, чтобы анимации были непрерывны

- Делаем триггер анимации при состоянии. Активируем переход на атаку при триггере

- Соединяем атаку со спокойным состоянием. Далее переносим в ноды анимации состояний

- И сейчас в переходах мы видим скорость перехода анимаций

- Так же плавность транзишена можно менять

-         А если нужно быстрое срабатывание анимации, длительность транзишена можно вообще убрать

- Тут стоит скорректировать переходы разных анимаций, чтобы сохранить плавность движений

- Дальше в иерархии на персонаже в аниматоре у нас должны находиться созданный контроллер самурая и сам аватар самурай

- Запускаем игру и в режиме рилтайма меняем скорость и активируем атаку по триггеру

-

#### **Урок 5.** **Animator**

- Делаем два контроллера с разными анимациями дерева (чтобы сделать разные анимации в разных контроллерах, я поочерёдно закидывал их в контроллер компонента Аниматор)

- И отдельно создаём контроллер для общей работы с деревом

- При создании контроллера анимации и самой анимации, которую мы создаём при закидывании в аниматор контроллера, у нас появляется отдельный файл с анимацией, который уже и закидываем в созданные ноды

- Если мы не хотим, чтобы анимация повторялась постоянно у объекта, то мы должны будем убрать отсюда галочку с Loop Time

- При проведении транзишена, если у нас стоит эта галочка, то анимация будет воспроизводиться по окончании прошлой анимации

- При такой логике выполнения, у нас Hit по дереву будет срабатывать, когда мы его назначим и после окончания анимации будет продолжаться Idle

- И мы можем добавить параметры, по которым будет создаваться анимация (там их несколько типов). Эти параметры используются в транзишенах, как условия перехода на другую анимацию. Можно использовать несколько условий (логическое И) либо одно условие (в нашем случае – триггер для удара)

- И при нажатии на наш триггер, у нас срабатывает анимация удара

- Делаем ещё один слой с теми же настройками

- А в базовом слое удалим анимацию удара

- И такой способ организации анимации в несколько слоёв позволяет воспроизводить разные анимации одновременно. То есть мы можем воспроизвести удар во время покачивания дерева без прерывания прошлой анимации, чтобы бывает иногда нужно

-

#### **Урок 6. 2****D** **Inverse** **Kinematic**

- Когда мы выделяем сразу все объекты и начинаем их двигать – это часть инверсивной кинематики, так как все кости движутся в определённом направлении за прошлыми костями.

Инверсивная кинематика подразумевает под собой то, что остальные кости будут двигаться под движение дочерних или родительских костей (например, рука будет выгибаться только в определённом направлении при её изгибании)

- Создаём на нашем объекте компонент IK Manager и можем в нём поменять вес (влияние компонента на объект)

- Выбираем один из трёх типов анимации дерева

- При выборе того же типа Limb у нас создаётся новый компонент

Effector – та кость, которая будет тянуться к какой-то точке

Target – то, к какой точке будет происходить притяжение

- И теперь после расположения конечной кости дерева (самой верхней) в эффектор и в таргет пустого объекта (то, за чем следует конечная кость)

- При повороте тагета будет поворачиваться и последняя косточка. Для исправления ситуации, мы можем отключить констреин ротейшена

- Так же можем флипнуть влияние

- Так же при выборе CCD менеджера, у нас появляется выбор количества косточек влияния. Остальные параметры – качество влияния на кости

-

#### **Урок 7. 3****D** **Inverse** **Kinematic**

- Для подключение 3Д кинематики, нам нужно в настройках базового слоя указать сам слой с персонажем и IK Pass

- Настряпать скрипт и накинуть его на персонажа (это код из официальной документации)

- И теперь персонаж смотрит за кубом

-

#### **Урок 8.** **Blend** **Tree**

- Создаём бленд-ноду и два раза кликаем по ней, чтобы войти внутрь неё

- Выбираем в качестве параметра скейл. Добавляем в смешивание анимаций сколько угодно их типов и закидываем сами анимации. В смешивании мы можем выставить в самой ноде или на графе значение и увидеть переход анимации

- Трешхолд будет отвечать за значение, которое нужно будет преодолеть для начала анимации

- И теперь через параметр Speed мы можем регулировать скорость анимации

-

### **Глава 8. Базовый скриптинг**

#### **Урок 1. Компоненты**

- Подробности в курсе от XYZ*

- Так же можно непосредственно не создавать скрипт в объекте. Скрипт можно сначала написать, а потом уже закинуть. Тут мы видим работу нашего вышеописанного скрипта

-

#### **Урок 2. Связь компонентов**

- Следующие пару уроков мы будем реализовывать смену цвета объекта. Все пояснения можно найти в XYZ

- Тут мы реализовали два поля и в поле выполнения логики мы присвоили Таргету (объекту, цвет которого будем менять) ссылку на спрайт рендерер нешего гейм обджекта

-

#### **Урок 3. Действия во времени на примере смены цвета**

- Вот тут у нас представлена реализация кода по смене цвета объекта гейм обджекта.

В методе старт у нас присвоение ссылки на определённый рендер обджект и запоминание начального цвета объекта.

В методе апдейт у нас реализован подсчёт времени, подсчёт отношения прошеднего времени к длительности (тут будет генерироваться число от 0 до 1, чтобы использовать его в постоянном изменении цвета объекта), объект новыйЦвет (который уже и будет содержать в себе ргб значения цветов) и ЗАМЕНОЙ этому объекту послужит Color.Lerp(), который уже сам сможет интерпретировать нужную градацию цветов

- Наш код будет идти примерно по такой логике: deltaTime будет выдавать время между нашими кадрами и цвет будет передвигаться в сторону конечного значения постепенно, добавляя значение таргета помноженного на дельтатайм к прошлому полученному значению

- Тут показана реализация вывода времени между кадрами и реализация вывода общего времени от начала выполнения кода объекта

-

#### **Урок 4. Поиск объектов на сцене**

- Добавим нескольким блокам теги, а оставшийся оставим без него

- И поместим наш скрипт на камеру

- Так же мы можем непосредственно обратиться к методам гейм обджекта через точку

- Тут мы описали логику удаления одного блока

- При срабатывании скрипта, объект удаляется

- А тут мы описали логику смены цвета выбранным по тегу блокам (и в комментах удаление)

- И вот мы видим, что цвет блоков поменялся

#### **Урок 5. Создание объектов на сцене**

- Закидываем нашего персонажа в иерархию и из иерархии закидываем в проект в отдельную папку для префабов

- Тут в коде мы реализовали: поле, которое будет принимать в себя объекты; гейм обджект, которому мы задали позицию через Instantiate(); поменяли цвет данному объекту

- Скрипт закидываем на камеру и в поле таргета закинем наш объект, который хотим заспавнить

- И теперь видим персонажа, который будет появляться на время запуска проекта

- Тут реализована логика спавна объекта по радиусу относительно нулевых координат

- Вписываем в скрипт камеры наши значения и получаем вывод по радиане

-

#### **Урок 6. Скрипт движения с вводом от клавиатуры**

- Легаси способ – через Input, когда мы вписываем, какие кнопки должны быть введены. Down – срабатывает при нажатии, Up – срабатывает при отпускании кнопки

- Сейчас накинем на нашего персонажа скрипт и посмотрим в консоли данную реализацию. Каждый кадр наша программа проверяет, не держим ли мы кнопку

- Вот так просто у нас реализовано передвижение персонажа в коде с использованием Time.deltaTime

- Не забываем указать скорость и радуемся тому, что персонаж движется

-

#### **Урок 7. Связь скрипта с анимациями**

- Закидываем нашего героя, закидываем на него аниматор, box collider и добавляем на него скрипт, в котором реализуем триггер. Уберём с Alarm параметр повторяющейся анимации. В аниматоре устанавливаем как стартовое состояние ноду с анимацией спокойствия и делаем новую ноду с алярмом. Переходим в алярм без времени ожидания (снимаем галочку). И реализуем переход в ноду алярм по срабатыванию триггера Alarm

- Реализуем такой код в компоненте нашего персонажа

- Теперь при нажатии на персонажа в игровом режиме у нас срабатывает анимация

#### **Урок 8. Скрипт патрулирования по уровню**

- Создаём объект Путь и в нём несколько точек. Чтобы скопировать объект, можно нажать на Ctrl+D

- Код реализации движения за точками

- И теперь персонаж сам ходит по указанным точкам

- И если мы объявим массив как сериалайз филд, то у нас появится возможность заполнить массив точек движения персонажа самостоятельно

#### **Урок 9. Рейкасты**

- Рейкаст – это физический луч, направленный в пространство мира, который даёт нам знать, пересекают ли этот луч какие-то физические объекты

-

- И теперь при повороте персонажа у нас будут удаляться блоки из уровня

#### **Урок 10. Rigidbody Cast - Пример из логической игры**

-  Создаём маленький уровень со стенками и одной преградой на пути героя. Так же для преграды сделаем отдельный слой

- Напишем такой код

- Накинем на героя скрипт, укажем РБ героя и его скорость, в фильтре добавим слой, с которым будет работать рейкаст

-

#### **Урок 11. Триггеры на примере конца уровня**

- Сейчас будем создавать триггер в конце уровня. Накидываем на блок коллайдер и ставим галочку на триггере. Чтобы блок среагировал как триггер, нужно чтобы объект, попавший в него, имел компонент RigidBody

- Так же накинем на игрока компонент Player, чтобы обратиться к нему в коде

- Компонент игрока оставим пустым

-

#### **Урок 12. События и поиск объектов по типу**

- На персонаже у нас так же должен стоять компонент плеера и РБ (для активации триггера)

- В коде добавляем использование триггеров и можем добавить новые события в наш блок конца уровня

- И сейчас, выбрав объект, мы можем назначить ему какой-либо ивент, который предусмотрен в юнити. Однако нам нужно сменить цвет блока, поэтому мы должны будем добавить адаптер

-

- И примерно так и работают адаптеры. Это другие скрипты, которые вызываются из одних скриптов

- Наш результат: персонаж проходит через блоки и срабатывает смена цвета

- Создадим родительский объект для наших кубиков, которые меняют цвета. В этот объект закинем скрипт, в котором опишем лог завершения уровня при достижении конечной точки

- Тут у нас показана реализация связки скриптов дочернего объекта и родительского.

В родительском объекте показан подсчёт информации о затронутых героем блоках. При задевании этих блоков игроку выпадает лог с окончанием уровня (в консоли)

В дочернем объекте (EndPoint) у нас передаётся информация о задевании

#### **Урок 13. Привязываем звуки и эффекты к событиям**

- Первым делом, сделанные партиклы мы закинем в дочерку нашего основного объекта

- Накинув на префаб героя Audio Source, нам не нужно закидывать звук в поле AudioClip, так как звук будем проигрывать его через компонент EndPoint

- Далее закинем наш эффект в эндпоинт

- Отключаем включение при просыпании и лупинг

- Далее закидываем компонент звука и сам сурс

-

#### **Урок 14. Подпрыгивание по нажатию**

- Первым делом нам нужно создать систему ивентов и на камеру накинуть рейкастер (рейкастер будет сообщать кто и с кем столкнулся)

-

- На блоке должен быть коллайдер, риджидбади (в котором мы скорректируем гравитацию и заблочим перемещение по осям X и Z), а так же накинем компонент Block (в который закинем риджид бади и выставим силу)

-

#### **Урок 15. Collision и столкновение с блоками**

-  Модифицируем код компонента героя, который мы ранее создали, но не модифицировали

- Далее накидываем анимацию партиклов в героя и настраиваем её

- Кидаем в скрипт плеера анимацию и выставляем настройку при срабатывании

- (у меня) И тут при соударении с чем-то, герой начинает ругаться на этот объект в консоли

-

#### **Урок 16. Линейная интерполяция векторов**

- В первую очередь создаём слайдер и располагаем его в удобном месте

- Дальше применяем Lerp – это метод, который высчитывает положение между двумя точками

- Применяем компонент на слайдер и накидываем в компонент точки А, Б и сам таргет. Теперь в плее мы можем тягать слайдер и перемещать объект. Так же можно менять положение блоков, чтобы менять траекторию вектора

- Зададим перемещение по времени

- Задаём время в компоненте и смотрим на результатиксы

- При таком способе смены позиции у нас будет плавная анимация в начале и в конце

-

#### **Урок 17. Корутины**

- Кортуины – это инструмент, который позволяет останавливать выполнение кода на момент, пока не будет осуществлён переход на следующий кадр (тут каждый кадр меняется непрозрачность объекта, присваивается значение по циклу каждый кадр отдельно)

-

### **Глава 9. Рекомендации по коду**

#### **Оформление полей**

-

#### **Require** **Component**

- RequireComponent будет явно требовать от юнити, чтобы присутствовал компонент, который мы отметили и не даст его удалить

-

#### **Типизированные шаблоны объектов**

- Опишем объект Coin и его генерацию. В генерации мы обращаемся на гейм обджект и создаём любой объект, подразумевая, что это коин

- Сейчас мы генерируем сам коин без подразумеваний и это сокращает нам код

- Эта команда находит все ссылки на данный компонент на сцене

-

#### **Работа с тегами**

- Чуть ранее мы написали код, в котором описали работу блоков, когда в них попадает игрок. Проверить, что производится действие с определённым блоком можно по компоненту, имени и тегу. В примере по компоненту Player (просто был создан скрипт и закинуть в гейм обджект) определили взаимодействие. По компонентам лучше и определять объекты

-

#### **Зависимости компонентов**

- Всегда, когда мы говорим про зависимость объекта Б от объекта А, мы говорим про зависимости. Эти зависимости не стоит искать на сцене. В примере мы используем компоненты: 1 – отображение количества монет у игрока и 2 – кошелёк игрока (Wallet)

- Самый простой способ отобразить такую зависимость – это обозначить в компоненте отображения монет поле кошелька. Однако, когда кошелёк не отображён на сцене, то такой способ не подойдёт

- Поэтому можно получить компонент через «получение компонентов в дочернем» либо также воспользоваться методом Init()

### **Глава 10. Математика**

#### **Понятие вектора и базовых операций над ним**

- Вектора неразрывно связаны с координатными осями и на ней они и отображаются

- P – положение, S – скорость, D – направление, TD – сужение шага (уменьшает шаг перемещения в данном случае с 1 до 0,5)

- Так работает определение расстояния между векторами

- Через D, так же можем определить расстояние в промежутках времени

- Нормализованный вектор (вектор единичной длины) – вектор, который разбит на отрезки, длиной равной единице

- L - длина между векторами (сумма компонентов векторов в квадрате), D – нормализованный B, Pn – положение игрока в системе

-

#### **Углы и скалярное произведение векторов**

- Перед нами стоит простая задача: A – игрок, B – противник, нужно определить попадает ли игрок в поле зрения противника

- Двойные палочки – нормализация вектора, одинарные – длина вектора

- Чтобы узнать угол между веткорами, нам нужно найти его скалярную величину и потом узнать арккосинус получившегося числа и перевести этот arccos в градусы

-

#### **Продвинутый контролер движения в 2D**

-

-

-

-

### **Глава 11.** **DOTWeen**

-

Что такое DOTween и как его установить

Как устроена документация

Создание задержки

Повторение и зацикливание анимации

Простейшее движение

Работа с цветом

Работа с текстом

Преследование

Следование по замкнутому пути

Изменение значения Slider

Создание последовательностей

-

-

### **Глава 12.** **User** **Interface**

-

-

-

### **Глава 13. Подъем предметов 2D персонажем с IK**

-

Риг персонажа 2D

Настройка IK для рук персонажа

Полнотельное IK

Подстраивание ног под поверхность

-

-

### **Глава 14. Scriptable Object**

-

Что такое SO и с чем его едят

Гибкая система заклинаний

Использование SO на примере коллекционных карточек

Создание простейшего магазина

Полиморфизм на примере разных типов товаров

-

-

### **Глава 15. Практика - бесконечный раннер**

-

-

-

### **Глава 16. Практика - Swamp Attack с монетизацией**

-

-

-

### **Глава 17. Практика -** **Flappy** **Bird**

-

-

-

### **Глава 18.** **New** **Input** **System**

-

Новая система ввода и ее интеграция

Создание карты событий

Работа со схемой через скрипт

Возможные Actions

Практика написания простых действий

Добавляем возможность брать, класть, бросать

Работа со схемой через PlayerInput

Считывание значения с Actions

Interactions

Написание собственных Interactions

Processors

-

-

### **Глава 19. AR практика - разработка декоратора комнат**

-

-

-

### **Глава 20. AR практика - разработка шутера**

-

-

-

### **Глава 21. Разработка Viforia**

-

-

-

### **Глава 22. Viforia практика - Создание шутера 1х1**

-

-

-

### **Глава 23. Основы Particle System**

-

-

-

### **Глава 24. Практика создания простых эффектов**

-

-

-

### **Глава 25. Работа с Appodeal**

-

-

-

### **Глава 26. Выпускной**

#### **Последний урок. Финальное задание**

- Делаем игру и заливаем её на гит. Так же на платформе IJunior есть урок по гиту

-

-




