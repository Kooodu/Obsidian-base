### Глава 1. Платформер – пазл

#### Урок 1. Знакомство с Unity

- На первом скрине мы создаём 2Д спрайт, который будет храниться у нас в ассетах. И в инспекторе нам нужно добавить компонент рендера на объект, чтобы он отображался у нас в сцене
![](_png/Pasted%20image%2020221017100254.png)
![](_png/Pasted%20image%2020221017100306.png)
- Как и в любой другой 3Д программе в юнити присутсвует иерархия и дочерние объекты будут брать за нулевую позицию положение координаты родителя
![](_png/Pasted%20image%2020221017100317.png)
- Q, W, E, R, T, Y – шорткаты вызова даннных инструментов
![](_png/Pasted%20image%2020221017100322.png)
- Камера – это обычный гейм обджект с компонентном камеры. Она уже показывает нашу сцену
![](_png/Pasted%20image%2020221017100326.png)
- Шорткаты
![](_png/Pasted%20image%2020221017100331.png)
- Так же мы можем на объект добавить тэг, чтобы была возможность обратиться к нему из кода
![](_png/Pasted%20image%2020221017100335.png)
![](_png/Pasted%20image%2020221017100340.png)
- Галка статик позволяет прорендерить данный объект за один проход
![](_png/Pasted%20image%2020221017100345.png)
- Домашнее задание:

1. Самостоятельное выполнение этапов лекции

2. Настройка окружения под себя

- Используемая в лекциях версия Unity:

https://unity3d.com/unity/whats-new/2019.4.21

#### **Урок 2. Создание сцены**

- Импорт ассетов можно сделать через юнитипэккдеж

- Либо можно просто закинуть ассеты. Обязательно путь не должен содержать кириллицы

- Так же можно легко создать пэккедж текстур для отправки

- SpriteShyt – вся анимация персонажа находится в одном спрайте  

- TileMap – спрайт, в котором находятся разные объекты. Им мы должны устанавливать режим Multiple

- Так же для спрайтов нам нужно задать размер в тайлах. Так мы построим относительные размеры их в пространстве для всех объектов. Размер данного пропса мы должны поставить равным размеру одного тайла 

- Изменение типа меша. Тайд строит форму меша подобную объекту, а фулл рект строит форму одним квадратом.

Тайд отрисовывает только непрозрачные пиксели в то время как фулл рект строит полностью весь спрайт. Так как у нас спрайты мелкие, то можно оставить тайд, так как он не создаёт много дополнительной геометрии

- Данный параметр расширяет края меша

- Pivot отвечает за положение якорной точки

- Эта галочка генерирует физическикорректную структуру объекта для взаимодействия с остальными объектами. Если взаимодействия не будет (соударения и так далее), то стоит галочку убрать

Например, спайкам (шипам) можно оставить галку, так как они будут участвовать в коллизии. А уже дверям можно убрать, так как это просто энвайропмент

- Использование сРГБ цветового пространства (отключаем только при необходимости работы с шейдерами), альфа сурс тоже не нужно менять (так как она может убрать альфаканал) и остальные параметры тоже не трогаем

- Врап мод отвечает за получение значений текстуры за границами её размеров. Галка не актуальна при работе со спрайтами.

Если же накинуть нашу текстуру с клампом на 3Д объект, то тут уже мы начнём сдвигать текстуру в разные стороны относительно плэйна

- При использовании репита, текстура будет тайлиться бесконечно

- При мирроре текстура отзеркалится и будет иметь бесконечный тайл. При миррор уанс у нас просто отзеркалится текстура без бесконечного тайла

- Дальше у нас идёт важный параметр Filter Mode.

Если мы просто закидываем текстуру на объект и размер тексруы равен количеству отображаемых пикселей на экране (тексура показывается в полном размере), то у нас пиксели отображаются 1 к 1 (рендер в игре и отображение на экране)

Однако когда мы уменьшаем размер текстуры (то есть она отдаляется от игрока в игре), то нам нужно решить, в каком месте какой пиксель должен отображаться, чтобы корректно отобразить текстуру издалека

- Первый способ отображения текстуры - **Point**  - он просто уменьшает масштаб изображения пропорционально. Такой способ плох, так как создаёт множество артефактов и искривляет изображение, делая его менее детализированным

Второй способ: **Bilinear** – он уже сглаживает изображение и для уменьшения картинки берёт информацию из соседних четырёх пикселей

- Так же билинеар сглаживает текстуру при очень сильном приближении, что лишает её ступенчатости как при использовании поинта

- Так же мы можем генерировать **МипМапы**, которые генерируют для каждого нового расстояния свои текстуры (увеличивают занимаемое пространство до 33%, но увеличивают в производительности)

Но если мы используем билинеар интерполцию, то можно увидеть небольшие артефакты при смене расстояний и уже чтобы ищбавиться от этой проблемы, нам нужно использовать **trilinear** интерполяци

- Трилинейная интерполяция вместе с тем, чтобы просто интерполировать сами текстуры, так же берёт ближайшие значения и из МиМапов, что позволяет сделать безшовные переходы текстур от одной к другой при смене расстояния

- Так же можно заметить, что дальность текстуры под наклоном тоже влияет на её прорисовку

Если мы включим анизантропную фильтрацию, то мы уже сможем при изменении угла наклона делать дальние объекты более чёткими

- И тут представлена анизотропическая карта объекта под разными углами

Если мы правильно построим проекцию объекта под разными углами, то получим правильные цвета пикселя для разного угла наклона камеры

- Однако в нашем случае, так как делаем пиксель арт, то нужно использовать поинтовое отображение

- Далее нам нужно определиться, как сильно мы будем сжимать текстуры для разных платформ (сколько установили, столько и будет тут вкладок)

- Выбираем максимально разрешение и алгоритм изменения размера. Первый даёт более сглаженную картинку, но скрывает больше деталей. Второй же сохраняет нужные детали

- И так же у нас есть компрессия, которая уже отвечает за параметр сжатия изображения _без потери качества_.

Ниже идёт параметр сжатия _с потерей качества_

- Однако компрессию нужно всегда убирать из спрайтов. Сама компрессия происходит за счёт сжатия цветов, поэтому это сильно бьёт по цветовой гамме

- Для пиксель арта важны данные параметры:

- Так же если мы будем работать с анимацией спрайтов, то она будет находиться в одном файле. Чтобы разрезать спрайт на равные нужные нам части, нужно поставить Спрайт Мод на Мультиплай и в самом спрайт-эдиторе выбрать режим разрезки по сетке. Ставим галку, чтобы резалось и пустое пространство (если нам нужна та же анимация исчезновения) и режем изображение

- И далее порезанное изображение мы можем раскрыть и использовать его объекты отдельно

- Так же наши порезанные спрайты можно закинуть в гейм обджект просто через панельку спрайтов

**Sprite** **Render**

- Дальше у нас идёт параметр tint

- Дальше мы можем флипнуть спрайт

- Дальше нам нужно выбрать тип меша как полностью квадратный в самом спрайте и мы сможем затайлить текстуру по обеим координатам

- Так же дальше в сплайн эдиторе в режиме сингл, нам нужно выделить линиями область и в гейм обджекте можем выбрать режим слайсед, чтобы растянуть нужный нам объект

- Так же мы можем сделать маску для отображения объектов

- Спрайт сорт поинт отвечает у нас за то, чтобы отцентрировать все спрайты относительно камеры.

Материал же отвечает за назначение материала на объекты

- Тут у нас располагаются слои. Чем больше число слоя, тем ближе этот слой к камере (да-да, тут не как в монтажках или фотошопе). Так же можно объекты запихнуть на один слой и в нём же ордером определить, какой из объектов будет ближе к камере

**Camera**

- Первый параметр отвечает за то, какой у нас будет фон виден через камеру. В 3Д играх располагаются скайбоксы. В Обычных 2Дшках у нас солидовые слои. Последний пункт не будет стирать прошлые кадры (рендер новых будет, но старые трогать не будет)

- Куллинг маска нам позволяет не отображать в камере определённые объекты

- Дальше у нас идут два режима камеры:

Перспективный – тут имеется перспектива, объекты к камере можно приблизить и отдалить, можно поменять угол обзора, чтобы захватить разный объём пространства

Ортографический – вид, при котором сохраняется перспектива, при разном отдалении от камеры остаётся одинаковый размер объекта, область видимости меняется параметром size

- Так же можно определить область видимости камеры

- Этот параметр отвечает за то, какую часть вьюпорта будет занимать камера. Можно сделать две камеры, которые будут занимать по пол экрана

- Глубина у нас отвечает за то, с какой камеры изображение будет появляться первее. Так же можно поставить режим отображения Don’t Clear, чтобы камеры не затирали друг друга

- Так же тут можно производить рендер по пасам

-

- Эта галка в камере отвечает за рендер объектов за другими объектами. Так как у нас 2Д-игра, то нам эта функция малополезна, но в 3Д-проектах это может поднять немного производительности

- Тут уже у нас HDR (повышенный динамический диапазон), MSAA (мультисэмплинговый антиалясинг) и ADR (понижает разрешение камеры, при высокой нагрузке ЦП)

- Первый параметр отвечает за рендер игры в отдельное окно (тут возможен вывод на несколько мониторов). Второй параметр позволяет определить, в какой глаз будет рендериться картинка, в VR-проекте

- Дальше для создания подходящей камеры, мы накинем модель pixel perfect.

Так же подставим размер тайла (у нас 32 пикселя).

Так же имеется галочка Upscale Render Texture, которую можно нажать, а можно убрать. Она у нас отвечает за то, будет ли пикселизация уходить в более ретро-стиль (пиксели становятся более острыми)

Потом идёт кроп фрейма до референса (который указан чуть выше)

Потом идёт стретч филл, который появляется, если активированы обе галочки

Последняя кнопка у нас запускает модуль данной камеры

- Сейчас порежем биомы на блоки по 32 юнита на тайл и сможем использовать разные части блоков

- Перемещать объекты с привязкой к сетке, можно удерживая ctrl

- И теперь можно просто перетянуть наши порезанные части спрайтов в сцену и удерживая Ctrl распределить их просто перетаскивая мышкой

-

Домашняя работа №1:

1. Импортировать и настроить ресурсы

2. Настроить pixel perfect camera

3. Собрать небольшую сцену с площадкой из тайлов, героем и пиками.

#### **Урок 3. Оживляем сцену**

- Создаём компонент кода и накидываем его нашему персонажу

-

-

- Теперь нам хватит всего лишь сохранить файл нашего скрипта, запустить игру и сразу поставить на паузу (там будут постоянно генерироваться сообщения о кадрах). Теперь мы можем увидеть вывод сообщений о срабатывании объектов в консоли

- Теперь снимем галочку объекта, отожмём паузу и увидим, что появилось предупреждение об отключении.

Так же при уничтожении/скрытии объекта, у нас и будут отсутствовать срабатывания Update.

Останутся работать при уничтожении объекта только методы Awake и OnDestroy (не зависят от состояния объекта)

- И при удалении объекта, появляется OnDestroy

- Если оставить в коде только методы Awake и OnDestroy, то у нас пропадёт галочка, потому что ничто не будет больше работать с данным персонажем

- На основе этих методов создаётся некоторая простая архитектура и определённые рамки для реализации логики объектов.

Тут можно просмотреть полный список жизненного цикла:

[https://docs.unity3d.com/ru/530/Manual/ExecutionOrder.html](https://docs.unity3d.com/ru/530/Manual/ExecutionOrder.html)

**Ниже код не работает!**

- В компоненте игрока можно использовать одну из методов ввода передвижения: легаси и новую. Тут представлен легаси-метод через сбор информации и вводе игрока. То есть через статический метод Input

- И дальше идут условия, по которым определяется какое-то действие для персонажа (вписывается логика передвижения)

- Но хорошим тоном в программировании является раазделение сбора информации и передвижения героя. Мы создадим новый скрипт Hero и будем в классе HeroInputReader устанавливать направление, в которое герой будет двигаться, а в классе Hero будем двигать самого героя

Вот тут мы реализуем движение внешнее, через условие, которое отображает, какие кнопки нажаты

А тут мы уже подкопотно реализуем логику передвижения

- Так же нужно отметить, что с помощью атрибута можно вывести приватное поле для редактирования в юнити и так же любое публичное поле выводится в юнити

- Так же можно посмотреть внутренности нашей сцены

- Сейчас мы хардкодили наши кнопки, чтобы реализовать передвижение. Однако можно поступить чуть более правильно. Можно воспользоваться встроенным инструментарием Unity, чтобы реализовать получение кнопок. Для этого и предназначен InputManager

В нём уже вписаны стороны передвижения, названия и принимаемые значения кнопок

Gravity – будет отвечать за скорость замедления персонажа. Dead – определить чувствительность к мёртвым зонам. Snap – если зажать сразу обе кнопки, то будет результат движения = 0

-

#### **Урок 4. Физика и коллизии**

-

-

-

-

#### **Урок 5. Таилсеты и камера**

-

-

-

-

#### **Урок 6. Анимация**

-

-

-

-

#### **Урок 07. Программирования игровых механик**

-

-

-

-

#### **Урок 8. Партиклы и инстанцирование**

-

-

-

-

#### **Урок 9. Курсовая работа**

-

-

-

-

### **Глава 2. Бой и NPC**

### **Глава 3. UI и новые игровые механики**

### **Глава 4. Продвинутые игровые механики и красивости**

### **Глава 5. Оптимизация и аналитика**

### **Глава 6. Диплом**



